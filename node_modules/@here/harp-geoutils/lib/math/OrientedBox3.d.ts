import { Frustum, Matrix4, Plane, Ray, Vector3 } from "three";
import { OrientedBox3Like } from "./OrientedBox3Like";
export declare class OrientedBox3 implements OrientedBox3Like {
    /**
     * The position of the center of this `OrientedBox3`.
     */
    readonly position: Vector3;
    /**
     * The x-axis of this `OrientedBox3`.
     */
    readonly xAxis: Vector3;
    /**
     * The y-axis of this `OrientedBox3`.
     */
    readonly yAxis: Vector3;
    /**
     * The z-axis of this `OrientedBox3`.
     */
    readonly zAxis: Vector3;
    /**
     * The extents of this `OrientedBox3`.
     */
    readonly extents: Vector3;
    /**
     * Creates a new `OrientedBox3`.
     */
    constructor();
    /**
     * Creates a new `OrientedBox3` with the given position, orientation and extents.
     *
     * @param position - The position of the center of the `OrientedBox3`.
     * @param rotationMatrix - The rotation of the `OrientedBox3`.
     * @param extents - The extents of the `OrientedBox3`.
     */
    constructor(position: Vector3, rotationMatrix: Matrix4, extents: Vector3);
    /**
     * Create a copy of this [[OrientedBoundingBox]].
     */
    clone(): OrientedBox3;
    /**
     * Copies the values of `other` to this {@link OrientedBox3}.
     * @param other - The other {@link OrientedBox3} to copy.
     */
    copy(other: OrientedBox3): void;
    /**
     * Gets the center position of this {@link OrientedBox3}.
     *
     * @param center - The returned center position.
     */
    getCenter(center?: Vector3): Vector3;
    /**
     * Gets the size of this {@link OrientedBox3}.
     *
     * @param size - The returned size.
     */
    getSize(size?: Vector3): Vector3;
    /**
     * Gets the orientation matrix of this `OrientedBox3`.
     * @param matrix - The output orientation matrix.
     */
    getRotationMatrix(matrix?: Matrix4): Matrix4;
    /**
     * Checks intersection with the given `THREE.Frustum` or array of `THREE.Plane`s.
     *
     * @param frustumOrPlanes - Frustum or array of planes.
     */
    intersects(frustumOrPlanes: Plane[] | Frustum): boolean;
    /**
     * Checks intersection with the given ray.
     *
     * @param ray - The ray to test.
     * @returns distance from ray origin to intersection point if it exist, undefined otherwise.
     */
    intersectsRay(ray: Ray): number | undefined;
    /**
     * Returns true if this {@link OrientedBox3} contains the given point.
     *
     * @param point - A valid point.
     */
    contains(point: Vector3): boolean;
    /**
     * Returns the distance from this {@link OrientedBox3} and the given `point`.
     *
     * @param point - A point.
     */
    distanceToPoint(point: Vector3): number;
    /**
     * Returns the squared distance from this {@link OrientedBox3} and the given `point`.
     *
     * @param point - A point.
     */
    distanceToPointSquared(point: Vector3): number;
}
//# sourceMappingURL=OrientedBox3.d.ts.map