"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeoPolygon = exports.isAntimeridianCrossing = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const three_1 = require("three");
const GeoBox_1 = require("./GeoBox");
const GeoCoordinates_1 = require("./GeoCoordinates");
const GeoCoordLike_1 = require("./GeoCoordLike");
function computeLonSpanAcrossGreewich(lonA, lonB) {
    return Math.max(lonA, lonB) - Math.min(lonA, lonB);
}
function isLeftToRightAntimeridianCrossing(lonStart, lonEnd) {
    return lonStart > 0 && lonEnd < 0 && computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180;
}
function isRightToLeftAntimeridianCrossing(lonStart, lonEnd) {
    return isLeftToRightAntimeridianCrossing(lonEnd, lonStart);
}
function isAntimeridianCrossing(lonStart, lonEnd) {
    return (Math.sign(lonStart) === -Math.sign(lonEnd) &&
        computeLonSpanAcrossGreewich(lonStart, lonEnd) > 180);
}
exports.isAntimeridianCrossing = isAntimeridianCrossing;
/**
 * A GeoPolygon in 2D Space (altitudes will be ignored).
 * Coordinates are expected in counter-clockwise order, for convex polygons a sorting is
 * available.
 * Clockwise ordered or selfintersecting Polygons might lead to no or unexpected results.
 *
 * @beta @internal
 */
class GeoPolygon {
    /**
     * Creates a GeoPolygon instance
     *
     * @param coordinates An array of GeoCoordinates acting as the Vertices of the Polygon.
     * @param needsSort  If `true` it will sort the coordinates in ccw order, this will only
     *  result correctly for convex polygons @default false
     * @param needsWrapping  If `true` it will wrap around coordinates crossing the antemeridian.
     * Only supported for polygons with sides that don't span more than 180 degrees longitude.
     * @default false
     */
    constructor(coordinates, needsSort = false, needsWrapping = false) {
        this.m_coordinates = coordinates.map(coord => {
            return GeoCoordLike_1.geoCoordLikeToGeoCoordinatesLike(coord);
        });
        if (needsSort) {
            this.sortCCW();
        }
        if (needsWrapping) {
            this.wrapCoordinatesAround();
        }
    }
    get coordinates() {
        return this.m_coordinates;
    }
    /**
     * Gets a BoundingBox for the Polygon
     *
     * Might have unexpected results for twisted or concave Polygons
     */
    getGeoBoundingBox() {
        const centroid = this.getCentroid();
        if (centroid === undefined) {
            //return a BBox without extend if the centroid could not be generated
            return GeoBox_1.GeoBox.fromCoordinates(this.coordinates[0], this.coordinates[0]);
        }
        const { east, west } = this.getEastAndWest(centroid);
        const { north, south } = this.getNorthAndSouth();
        return GeoBox_1.GeoBox.fromCoordinates(new GeoCoordinates_1.GeoCoordinates(south, west), new GeoCoordinates_1.GeoCoordinates(north, east));
    }
    /**
     * Gets the Centroid for the Polygon
     *
     * Might be undefined or with unexpected results for twisted or concave Polygons.
     */
    getCentroid() {
        const area = this.getArea();
        if (area === 0) {
            return undefined;
        }
        let latitude = 0;
        let longitude = 0;
        let f;
        let previousIndex = this.m_coordinates.length - 1;
        this.m_coordinates.forEach((coordinate, index) => {
            const previousCoordinate = this.m_coordinates[previousIndex];
            f =
                coordinate.latitude * previousCoordinate.longitude -
                    previousCoordinate.latitude * coordinate.longitude;
            latitude += (coordinate.latitude + previousCoordinate.latitude) * f;
            longitude += (coordinate.longitude + previousCoordinate.longitude) * f;
            previousIndex = index;
        });
        f = area * 6;
        return new GeoCoordinates_1.GeoCoordinates(latitude / f, area < 0 /* antimeridian crossing */ ? -180 + longitude / f : longitude / f);
    }
    sortCCW() {
        const polyCenter = this.getPolyAverageCenter();
        if (!polyCenter) {
            return;
        }
        //sorts by angle from x-axis
        this.m_coordinates.sort((a, b) => {
            const veca = new three_1.Vector2(a.latitude - polyCenter.latitude, a.longitude - polyCenter.longitude).normalize();
            const vecb = new three_1.Vector2(b.latitude - polyCenter.latitude, b.longitude - polyCenter.longitude).normalize();
            return vecb.angle() - veca.angle();
        });
    }
    wrapCoordinatesAround() {
        const firstAntimerCrossIndex = this.m_coordinates.findIndex((val, index) => {
            const prevLonIndex = index === 0 ? this.m_coordinates.length - 1 : index - 1;
            const prevLon = this.m_coordinates[prevLonIndex].longitude;
            const lon = val.longitude;
            return isLeftToRightAntimeridianCrossing(prevLon, lon);
        });
        if (firstAntimerCrossIndex < 0) {
            return;
        }
        let wrapAround = true;
        for (let i = 0; i < this.m_coordinates.length; i++) {
            const index = (firstAntimerCrossIndex + i) % this.m_coordinates.length;
            const currentLon = this.m_coordinates[index].longitude;
            const nextLon = this.m_coordinates[(index + 1) % this.m_coordinates.length].longitude;
            if (wrapAround) {
                this.m_coordinates[index].longitude += 360;
            }
            if (isRightToLeftAntimeridianCrossing(currentLon, nextLon)) {
                wrapAround = false;
            }
            else if (isLeftToRightAntimeridianCrossing(currentLon, nextLon)) {
                wrapAround = true;
            }
        }
    }
    getPolyAverageCenter() {
        const polySum = this.m_coordinates.reduce((prev, curr) => {
            return new GeoCoordinates_1.GeoCoordinates(prev.latitude + curr.latitude, prev.longitude + curr.longitude);
        });
        //create an average center point
        return new GeoCoordinates_1.GeoCoordinates(polySum.latitude / this.m_coordinates.length, polySum.longitude / this.m_coordinates.length);
    }
    getArea() {
        let area = 0;
        let previousIndex = this.m_coordinates.length - 1;
        this.m_coordinates.forEach((coordinate, index) => {
            const previousCoordinate = this.m_coordinates[previousIndex];
            area += coordinate.latitude * previousCoordinate.longitude;
            area -= coordinate.longitude * previousCoordinate.latitude;
            previousIndex = index;
        });
        return (area /= 2);
    }
    getEastAndWest(center) {
        let west = center.longitude;
        let east = center.longitude;
        let previousIndex = this.m_coordinates.length - 1;
        this.m_coordinates.forEach((coordinate, index) => {
            const previousCoordinate = this.m_coordinates[previousIndex];
            previousIndex = index;
            const veca = new three_1.Vector2(coordinate.latitude - center.latitude, coordinate.longitude - center.longitude).normalize();
            const vecb = new three_1.Vector2(previousCoordinate.latitude - center.latitude, previousCoordinate.longitude - center.longitude).normalize();
            let ccw = Math.sign(vecb.angle() - veca.angle()) === 1;
            // overwrite in case of angle over axis
            if (vecb.y >= 0 && veca.y < 0) {
                ccw = true;
            }
            const long = coordinate.longitude;
            if (long < center.longitude) {
                if (ccw) {
                    west = Math.min(west, long);
                }
                else {
                    east = Math.min(east, long);
                }
            }
            else {
                if (ccw) {
                    east = Math.max(east, long);
                }
                else {
                    west = Math.max(west, long);
                }
            }
        });
        return { east, west };
    }
    getNorthAndSouth() {
        let north = GeoCoordinates_1.MIN_LATITUDE;
        let south = GeoCoordinates_1.MAX_LATITUDE;
        this.m_coordinates.forEach((coordinate, index) => {
            north = Math.max(north, coordinate.latitude);
            south = Math.min(south, coordinate.latitude);
        });
        return { north, south };
    }
}
exports.GeoPolygon = GeoPolygon;
//# sourceMappingURL=GeoPolygon.js.map