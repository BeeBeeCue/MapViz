import { GeoCoordinatesLike } from "./GeoCoordinatesLike";
import { GeoCoordLike } from "./GeoCoordLike";
import { GeoPointLike } from "./GeoPointLike";
import { LatLngLike } from "./LatLngLike";
export declare const MAX_LATITUDE = 90;
export declare const MIN_LATITUDE = -90;
export declare const MAX_LONGITUDE = 180;
export declare const MIN_LONGITUDE = -180;
/**
 * `GeoCoordinates` is used to represent geo positions.
 */
export declare class GeoCoordinates implements GeoCoordinatesLike {
    latitude: number;
    longitude: number;
    altitude?: number | undefined;
    /**
     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude - Latitude in degrees.
     * @param longitude - Longitude in degrees.
     * @param altitude - Altitude in meters.
     */
    static fromDegrees(latitude: number, longitude: number, altitude?: number): GeoCoordinates;
    /**
     * Returns a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude - Latitude in radians.
     * @param longitude - Longitude in radians.
     * @param altitude - Altitude in meters.
     */
    static fromRadians(latitude: number, longitude: number, altitude?: number): GeoCoordinates;
    /**
     * Creates a {@link GeoCoordinates} from a {@link LatLngLike} literal.
     * ```typescript
     * const center = { lat: 53.3, lng: 13.4 };
     * mapView.geoCenter = GeoCoordinates.fromLatLng(center);
     * ```
     * @param latLng - A {@link LatLngLike} object literal.
     */
    static fromLatLng(latLng: LatLngLike): GeoCoordinates;
    /**
     * Creates a {@link GeoCoordinates} from a [[GeoPointLike]] tuple.
     *
     * Example:
     * ```typescript
     * mapView.geoCenter = GeoCoordinates.fromGeoPoint([longitude, latitude]);
     *
     * let geoCoords: number[] = ...;
     *
     * if (isGeoPointLike(geoCoords)) {
     *     const p = GeoCoordinates.fromGeoPoint(geoCoords);
     * }
     * ```
     * @param geoPoint - An [[Array]] of at least two elements following the order
     * longitude, latitude, altitude.
     */
    static fromGeoPoint(geoPoint: GeoPointLike): GeoCoordinates;
    /**
     * Creates a {@link GeoCoordinates} from different types of geo coordinate objects.
     *
     * Example:
     * ```typescript
     * const fromGeoPointLike = GeoCoordinates.fromObject([longitude, latitude]);
     * const fromGeoCoordinateLike = GeoCoordinates.fromObject({ longitude, latitude });
     * const fromGeoCoordinate = GeoCoordinates.fromObject(new GeoCoordinates(latitude, longitude));
     * const fromLatLngLike = GeoCoordinates.fromObject({ lat: latitude , lng: longitude });
     * ```
     *
     * @param geoPoint - Either [[GeoPointLike]], {@link GeoCoordinatesLike}
     * or {@link LatLngLike} object literal.
     */
    static fromObject(geoPoint: GeoCoordLike): GeoCoordinates;
    /**
     * Returns a `GeoCoordinates` resulting from the linear interpolation of other two.
     * @param geoCoords0 - One of the `GeoCoordinates` used for interpolation.
     * @param geoCoords1 - The other `GeoCoordinates` used for interpolation.
     * @param factor - Interpolation factor. If `0` result will be equal to `geoCoords0`, if `1`
     * it'll be equal to `geoCoords1`.
     * @param wrap - If `true`, interpolation will be done across the antimeridian, otherwise it's
     * done across the Greenwich meridian. Supported only if longitude span is less than 360 deg.
     * @default false
     * @param normalize - If `true`, interpolation result will be normalized. @default false
     */
    static lerp(geoCoords0: GeoCoordinates, geoCoords1: GeoCoordinates, factor: number, wrap?: boolean, normalize?: boolean): GeoCoordinates;
    /**
     * Creates a `GeoCoordinates` from the given latitude, longitude, and optional altitude.
     *
     * @param latitude - Latitude in degrees.
     * @param longitude - Longitude in degrees.
     * @param altitude - Altitude in meters.
     */
    constructor(latitude: number, longitude: number, altitude?: number | undefined);
    /**
     * Returns the latitude in radians.
     */
    get latitudeInRadians(): number;
    /**
     * Returns the longitude in radians.
     */
    get longitudeInRadians(): number;
    /**
     * Returns the latitude in degrees.
     * @deprecated Use the [[latitude]] property instead.
     */
    get latitudeInDegrees(): number;
    /**
     * Returns the longitude in degrees.
     * @deprecated Use the [[longitude]] property instead.
     */
    get longitudeInDegrees(): number;
    /**
     * The latitude in the degrees.
     */
    get lat(): number;
    /**
     * The longitude in the degrees.
     */
    get lng(): number;
    /**
     * Returns `true` if this `GeoCoordinates` is valid; returns `false` otherwise.
     */
    isValid(): boolean;
    /**
     * Returns the normalized `GeoCoordinates`.
     */
    normalized(): GeoCoordinates;
    /**
     * Returns `true` if this `GeoCoordinates` is equal to the other.
     *
     * @param other - GeoCoordinatesLike to compare to.
     */
    equals(other: GeoCoordinatesLike): boolean;
    /**
     * Copy values from the other.
     *
     * @param other - GeoCoordinatesLike to copy all values from.
     */
    copy(other: GeoCoordinatesLike): GeoCoordinates;
    /**
     * Clones this `GeoCoordinates`.
     */
    clone(): GeoCoordinates;
    /**
     * Returns this {@link GeoCoordinates} as {@link LatLngLike} literal.
     */
    toLatLng(): LatLngLike;
    /**
     * Converts this {@link GeoCoordinates} to a [[GeoPointLike]].
     */
    toGeoPoint(): GeoPointLike;
    /**
     * Returns the minimum longitude span from this `GeoCoordinates` to another.
     *
     * @param other - The other GeoCoordinatesLike defining the longitude span.
     */
    minLongitudeSpanTo(other: GeoCoordinatesLike): number;
}
//# sourceMappingURL=GeoCoordinates.d.ts.map