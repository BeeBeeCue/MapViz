"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.OmvDataAdapter = exports.asGeometryType = exports.createFeatureEnv = void 0;
const index_decoder_1 = require("@here/harp-datasource-protocol/index-decoder");
const Long = require("long");
const three_1 = require("three");
const OmvDecoderDefs_1 = require("../../OmvDecoderDefs");
const OmvUtils_1 = require("../../OmvUtils");
const OmvData_1 = require("./OmvData");
const vector_tile_1 = require("./proto/vector_tile");
const propertyCategories = [
    "stringValue",
    "floatValue",
    "doubleValue",
    "intValue",
    "uintValue",
    "sintValue",
    "boolValue"
];
function simplifiedValue(value) {
    const hasOwnProperty = Object.prototype.hasOwnProperty;
    for (const category of propertyCategories) {
        if (hasOwnProperty.call(value, category)) {
            const v = value[category];
            if (v === undefined) {
                throw new Error("unpexted undefined value");
            }
            return Long.isLong(v) ? v.toNumber() : v;
        }
    }
    throw new Error("not happening");
}
function replaceReservedName(name) {
    switch (name) {
        case "id":
            return "$id";
        default:
            return name;
    } // switch
}
function decodeFeatureId(feature, logger) {
    if (feature.hasOwnProperty("id")) {
        const id = feature.id;
        if (typeof id === "number") {
            return id;
        }
        else if (id) {
            if (logger !== undefined && id.greaterThan(Number.MAX_SAFE_INTEGER)) {
                logger.error("Invalid ID: Larger than largest available Number in feature: ", feature);
            }
            return id.toNumber();
        }
    }
    return undefined;
}
function readAttributes(layer, feature, defaultAttributes = {}) {
    const attrs = new OmvData_1.FeatureAttributes();
    const attributes = defaultAttributes || {};
    attrs.accept(layer, feature, {
        visitAttribute: (name, value) => {
            attributes[replaceReservedName(name)] = simplifiedValue(value);
            return true;
        }
    });
    return attributes;
}
function createFeatureEnv(layer, feature, geometryType, storageLevel, storageLevelOffset, logger, parent) {
    const attributes = {
        $layer: layer.name,
        $level: storageLevel,
        $zoom: Math.max(0, storageLevel - (storageLevelOffset !== null && storageLevelOffset !== void 0 ? storageLevelOffset : 0)),
        $geometryType: geometryType
    };
    // Some sources serve `id` directly as `IFeature` property ...
    const featureId = decodeFeatureId(feature, logger);
    if (featureId !== undefined) {
        attributes.$id = featureId;
    }
    readAttributes(layer, feature, attributes);
    return new index_decoder_1.MapEnv(attributes, parent);
}
exports.createFeatureEnv = createFeatureEnv;
function asGeometryType(feature) {
    if (feature === undefined) {
        return OmvDecoderDefs_1.OmvGeometryType.UNKNOWN;
    }
    switch (feature.type) {
        case vector_tile_1.com.mapbox.pb.Tile.GeomType.UNKNOWN:
            return OmvDecoderDefs_1.OmvGeometryType.UNKNOWN;
        case vector_tile_1.com.mapbox.pb.Tile.GeomType.POINT:
            return OmvDecoderDefs_1.OmvGeometryType.POINT;
        case vector_tile_1.com.mapbox.pb.Tile.GeomType.LINESTRING:
            return OmvDecoderDefs_1.OmvGeometryType.LINESTRING;
        case vector_tile_1.com.mapbox.pb.Tile.GeomType.POLYGON:
            return OmvDecoderDefs_1.OmvGeometryType.POLYGON;
        default:
            return OmvDecoderDefs_1.OmvGeometryType.UNKNOWN;
    } // switch
}
exports.asGeometryType = asGeometryType;
// Ensures ring winding follows Mapbox Vector Tile specification: outer rings must be clockwise,
// inner rings counter-clockwise.
function checkWinding(multipolygon) {
    if (multipolygon.length === 0) {
        return;
    }
    const firstPolygon = multipolygon[0];
    if (firstPolygon.rings.length === 0) {
        return;
    }
    // Opposite sign to ShapeUtils.isClockWise, since webMercator tile space has top-left origin.
    const isOuterRingClockWise = three_1.ShapeUtils.area(firstPolygon.rings[0]) > 0;
    if (isOuterRingClockWise) {
        return;
    }
    for (const polygon of multipolygon) {
        for (const ring of polygon.rings) {
            ring.reverse();
        }
    }
}
function roundUpCoordinates(coordinates, layerExtents) {
    coordinates.forEach(p => {
        if (p.x === layerExtents - 1) {
            p.x = layerExtents;
        }
    });
}
function roundUpPolygonCoordinates(geometry, layerExtents) {
    geometry.forEach(polygon => polygon.rings.forEach(r => roundUpCoordinates(r, layerExtents)));
}
function roundUpLineCoordinates(geometry, layerExtents) {
    geometry.forEach(line => roundUpCoordinates(line.positions, layerExtents));
}
/**
 * The class `OmvDataAdapter` converts OMV protobuf geo data
 * to geometries for the given `IGeometryProcessor`.
 */
class OmvDataAdapter {
    /**
     * Constructs a new [[OmvProtobufDataAdapter]].
     *
     * @param processor - The [[IGeometryProcessor]] used to process the data.
     * @param dataFilter - The [[OmvFeatureFilter]] used to filter features.
     * @param logger - The [[ILogger]] used to log diagnostic messages.
     */
    constructor(processor, dataFilter, logger) {
        this.id = "omv-protobuf";
        this.m_geometryCommands = new OmvData_1.GeometryCommands();
        this.roundUpCoordinatesIfNeeded = false;
        this.m_processor = processor;
        this.m_dataFilter = dataFilter;
        this.m_logger = logger;
    }
    /**
     * The [[OmvFeatureFilter]] used to filter features.
     */
    get dataFilter() {
        return this.m_dataFilter;
    }
    /**
     * The [[OmvFeatureFilter]] used to filter features.
     */
    set dataFilter(dataFilter) {
        this.m_dataFilter = dataFilter;
    }
    /**
     * Checks that the given data can be processed by this [[OmvProtobufDataAdapter]].
     */
    canProcess(data) {
        return OmvUtils_1.isArrayBufferLike(data);
    }
    /**
     * Processes the given data payload using this adapter's [[IGeometryProcessor]].
     *
     * @param data - The data payload to process.
     * @param decodeInfo - The [[DecodedInfo]] of the tile to proceess.
     */
    process(data, decodeInfo) {
        const { tileKey } = decodeInfo;
        const payload = new Uint8Array(data);
        const proto = vector_tile_1.com.mapbox.pb.Tile.decode(payload);
        this.m_tileKey = tileKey;
        OmvData_1.visitOmv(proto, this);
    }
    /**
     * Visits the OMV layer.
     *
     * @param layer - The OMV layer to process.
     */
    visitLayer(layer) {
        this.m_layer = layer;
        const storageLevel = this.m_tileKey.level;
        const layerName = layer.name;
        if (this.m_dataFilter !== undefined &&
            !this.m_dataFilter.wantsLayer(layerName, storageLevel)) {
            return false;
        }
        return true;
    }
    /**
     * Visits point features.
     *
     * @param feature - The OMV point features to process.
     */
    visitPointFeature(feature) {
        var _a;
        if (feature.geometry === undefined) {
            return;
        }
        const storageLevel = this.m_tileKey.level;
        const layerName = this.m_layer.name;
        const layerExtents = (_a = this.m_layer.extent) !== null && _a !== void 0 ? _a : 4096;
        if (this.m_dataFilter !== undefined &&
            !this.m_dataFilter.wantsPointFeature(layerName, asGeometryType(feature), storageLevel)) {
            return;
        }
        const geometry = [];
        this.m_geometryCommands.accept(feature.geometry, {
            type: "Point",
            visitCommand: command => {
                if (OmvData_1.isMoveToCommand(command)) {
                    geometry.push(command.position);
                }
            }
        });
        if (geometry.length === 0) {
            return;
        }
        const env = createFeatureEnv(this.m_layer, feature, "point", storageLevel, this.m_processor.storageLevelOffset, this.m_logger);
        this.m_processor.processPointFeature(layerName, layerExtents, geometry, env, storageLevel);
    }
    /**
     * Visits the line features.
     *
     * @param feature - The line features to process.
     */
    visitLineFeature(feature) {
        var _a;
        if (feature.geometry === undefined) {
            return;
        }
        const storageLevel = this.m_tileKey.level;
        const layerName = this.m_layer.name;
        const layerExtents = (_a = this.m_layer.extent) !== null && _a !== void 0 ? _a : 4096;
        if (this.m_dataFilter !== undefined &&
            !this.m_dataFilter.wantsLineFeature(layerName, asGeometryType(feature), storageLevel)) {
            return;
        }
        const geometry = [];
        let positions;
        this.m_geometryCommands.accept(feature.geometry, {
            type: "Line",
            visitCommand: command => {
                if (OmvData_1.isMoveToCommand(command)) {
                    positions = [command.position];
                    geometry.push({ positions });
                }
                else if (OmvData_1.isLineToCommand(command)) {
                    positions.push(command.position);
                }
            }
        });
        if (geometry.length === 0) {
            return;
        }
        if (this.mustRoundUpCoordinates) {
            roundUpLineCoordinates(geometry, layerExtents);
        }
        const env = createFeatureEnv(this.m_layer, feature, "line", storageLevel, this.m_processor.storageLevelOffset, this.m_logger);
        this.m_processor.processLineFeature(layerName, layerExtents, geometry, env, storageLevel);
    }
    /**
     * Visits the polygon features.
     *
     * @param feature - The polygon features to process.
     */
    visitPolygonFeature(feature) {
        var _a;
        if (feature.geometry === undefined) {
            return;
        }
        const storageLevel = this.m_tileKey.level;
        const layerName = this.m_layer.name;
        const layerExtents = (_a = this.m_layer.extent) !== null && _a !== void 0 ? _a : 4096;
        if (this.m_dataFilter !== undefined &&
            !this.m_dataFilter.wantsPolygonFeature(layerName, asGeometryType(feature), storageLevel)) {
            return;
        }
        const geometry = [];
        const currentPolygon = { rings: [] };
        let currentRing;
        this.m_geometryCommands.accept(feature.geometry, {
            type: "Polygon",
            visitCommand: command => {
                if (OmvData_1.isMoveToCommand(command)) {
                    currentRing = [command.position];
                }
                else if (OmvData_1.isLineToCommand(command)) {
                    currentRing.push(command.position);
                }
                else if (OmvData_1.isClosePathCommand(command)) {
                    if (currentRing !== undefined && currentRing.length > 0) {
                        currentRing.push(currentRing[0].clone());
                        currentPolygon.rings.push(currentRing);
                    }
                }
            }
        });
        if (currentPolygon.rings.length > 0) {
            geometry.push(currentPolygon);
        }
        if (geometry.length === 0) {
            return;
        }
        if (this.mustRoundUpCoordinates) {
            roundUpPolygonCoordinates(geometry, layerExtents);
        }
        checkWinding(geometry);
        const env = createFeatureEnv(this.m_layer, feature, "polygon", storageLevel, this.m_processor.storageLevelOffset, this.m_logger);
        this.m_processor.processPolygonFeature(layerName, layerExtents, geometry, env, storageLevel);
    }
    get mustRoundUpCoordinates() {
        return (this.roundUpCoordinatesIfNeeded &&
            this.m_tileKey.level < 5 &&
            this.m_tileKey.column === this.m_tileKey.columnCount() - 1);
    }
}
exports.OmvDataAdapter = OmvDataAdapter;
//# sourceMappingURL=OmvDataAdapter.js.map