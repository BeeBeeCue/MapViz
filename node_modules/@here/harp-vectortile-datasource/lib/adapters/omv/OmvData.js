"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeometryCommands = exports.FeatureAttributes = exports.visitOmvLayer = exports.visitOmv = exports.isClosePathCommand = exports.isLineToCommand = exports.isMoveToCommand = exports.CommandKind = void 0;
const three_1 = require("three");
const vector_tile_1 = require("./proto/vector_tile");
/**
 * @hidden
 */
var CommandKind;
(function (CommandKind) {
    CommandKind[CommandKind["MoveTo"] = 1] = "MoveTo";
    CommandKind[CommandKind["LineTo"] = 2] = "LineTo";
    CommandKind[CommandKind["ClosePath"] = 7] = "ClosePath";
})(CommandKind = exports.CommandKind || (exports.CommandKind = {}));
/**
 * @hidden
 */
function isMoveToCommand(command) {
    return command.kind === CommandKind.MoveTo;
}
exports.isMoveToCommand = isMoveToCommand;
/**
 * @hidden
 */
function isLineToCommand(command) {
    return command.kind === CommandKind.LineTo;
}
exports.isLineToCommand = isLineToCommand;
/**
 * @hidden
 */
function isClosePathCommand(command) {
    return command.kind === CommandKind.ClosePath;
}
exports.isClosePathCommand = isClosePathCommand;
/**
 * @hidden
 */
function visitOmv(vectorTile, visitor) {
    if (!vectorTile.layers) {
        return;
    }
    for (const layer of vectorTile.layers) {
        if (!visitor.visitLayer || visitor.visitLayer(layer)) {
            visitOmvLayer(layer, visitor);
        }
        if (visitor.endVisitLayer) {
            visitor.endVisitLayer(layer);
        }
    }
}
exports.visitOmv = visitOmv;
/**
 * @hidden
 */
function visitOmvLayer(layer, visitor) {
    if (!visitor.visitLayer || visitor.visitLayer(layer)) {
        if (layer.features) {
            for (const feature of layer.features) {
                switch (feature.type) {
                    case vector_tile_1.com.mapbox.pb.Tile.GeomType.UNKNOWN:
                        break;
                    case vector_tile_1.com.mapbox.pb.Tile.GeomType.POINT:
                        if (visitor.visitPointFeature) {
                            visitor.visitPointFeature(feature);
                        }
                        break;
                    case vector_tile_1.com.mapbox.pb.Tile.GeomType.LINESTRING:
                        if (visitor.visitLineFeature) {
                            visitor.visitLineFeature(feature);
                        }
                        break;
                    case vector_tile_1.com.mapbox.pb.Tile.GeomType.POLYGON:
                        if (visitor.visitPolygonFeature) {
                            visitor.visitPolygonFeature(feature);
                        }
                        break;
                }
            }
        }
    }
    if (visitor.endVisitLayer) {
        visitor.endVisitLayer(layer);
    }
}
exports.visitOmvLayer = visitOmvLayer;
/**
 * @hidden
 */
class FeatureAttributes {
    accept(layer, feature, visitor) {
        const { keys, values } = layer;
        const tags = feature.tags;
        if (!tags || !keys || !values) {
            return;
        }
        for (let i = 0; i < tags.length; i += 2) {
            const key = keys[tags[i]];
            const value = values[tags[i + 1]];
            if (!visitor.visitAttribute(key, value)) {
                break;
            }
        }
    }
}
exports.FeatureAttributes = FeatureAttributes;
/**
 * @hidden
 */
class GeometryCommands {
    accept(geometry, visitor) {
        if (!geometry) {
            return;
        }
        const geometryCount = geometry.length;
        let currX = 0;
        let currY = 0;
        const xCoords = [];
        const yCoords = [];
        const commands = [];
        for (let cmdIndex = 0; cmdIndex < geometryCount;) {
            const kind = (geometry[cmdIndex] & 0x7);
            const count = geometry[cmdIndex] >> 0x3;
            ++cmdIndex;
            if (kind === CommandKind.MoveTo || kind === CommandKind.LineTo) {
                for (let n = 0; n < count; ++n) {
                    const xx = geometry[cmdIndex++];
                    const yy = geometry[cmdIndex++];
                    currX += (xx >> 1) ^ -(xx & 1);
                    currY += (yy >> 1) ^ -(yy & 1);
                    if (visitor.type === "Polygon") {
                        xCoords.push(currX);
                        yCoords.push(currY);
                    }
                    const position = new three_1.Vector2(currX, currY);
                    commands.push({ kind, position });
                }
            }
            else {
                for (const command of commands) {
                    visitor.visitCommand(command);
                }
                visitor.visitCommand({ kind });
                xCoords.length = 0;
                yCoords.length = 0;
                commands.length = 0;
            }
        }
        if (commands.length > 0) {
            for (const command of commands) {
                visitor.visitCommand(command);
            }
        }
    }
}
exports.GeometryCommands = GeometryCommands;
//# sourceMappingURL=OmvData.js.map