/**
 * A `PriorityListElement` has a priority to assist in sorting. The idea is that the items in a
 * grouped priority list will not modify their priority during processing to such an amount, that
 * they will change into another group. Smaller lists are smaller to sort, and in case of resource
 * limitation (maximum number of rendered objects reached), not all items have to be sorted at all.
 */
export interface PriorityListElement {
    /**
     * The integer value of this priority is used to group objects of "same" priority.
     */
    priority: number;
}
/**
 * The `PriorityListGroup` contains a list of {@link PriorityListElement}s that all have the same
 * (integer) priority.
 */
export declare class PriorityListGroup<T extends PriorityListElement> {
    readonly priority: number;
    elements: T[];
    constructor(priority: number, elements?: T[]);
    /**
     * Create and return a deep copy of the `PriorityListGroup<T>`.
     *
     * @returns A clone of the `PriorityListGroup<T>`.
     */
    clone(): PriorityListGroup<T>;
    /**
     * Removes an element from the group.
     * @param element - The element to remove.
     * @returns true if the element was removed, false if it was not found in the group.
     */
    remove(element: T): boolean;
}
/**
 * The `PriorityListGroupMap` is a map to map the (integer) priority to a {@link PriorityListGroup}.
 */
export declare type PriorityListGroupMap<T extends PriorityListElement> = Map<number, PriorityListGroup<T>>;
/**
 * The `GroupedPriorityList` contains a [[PriorityListGroupMap]] to manage a larger number of items
 * in priority groups.
 */
export declare class GroupedPriorityList<T extends PriorityListElement> {
    readonly groups: PriorityListGroupMap<T>;
    /**
     * Add an element to the `GroupedPriorityList`. Selects group based on the elements priority.
     *
     * @param element - Element to be added.
     */
    add(element: T): void;
    /**
     * Remove an element from the `GroupedPriorityList`.
     *
     * Note: It is required that the priority is the same as it was when the element has been added.
     * Otherwise, the removal will fail.
     *
     * @param element - Element to be removed.
     * @returns `True` if the element was removed, `false` otherwise.
     */
    remove(element: T): boolean;
    /**
     * Remove all internal {@link PriorityListGroup}s.
     */
    clear(): void;
    /**
     * Merge another {@link GroupedPriorityList} into this one.
     *
     * @param other - Other group to merge.
     */
    merge(other: GroupedPriorityList<T>): GroupedPriorityList<T>;
    clone(): GroupedPriorityList<T>;
    /**
     * Apply function to all elements in this `GroupedPriorityList`.
     *
     * @param {(element: T) => void} fun Function to apply.
     */
    forEach(fun: (element: T) => void): void;
    /**
     * Count the number of elements in this `GroupedPriorityList`.
     */
    count(): number;
    /**
     * Get group of elements that have the same (integer) priority.
     *
     * @param priority - The priority to retrieve all elements from.
     */
    private findGroup;
    /**
     * Get group of elements that have the same (integer) priority.
     *
     * @param priority - The priority to retrieve all elements from.
     */
    private getGroup;
}
//# sourceMappingURL=GroupedPriorityList.d.ts.map