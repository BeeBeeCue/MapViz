"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskQueue = void 0;
/**
 * A Pull-TaskQueue sorted by priority and group-able {@link Task}s by {@link Task.group}.
 *
 * @remarks
 *
 * @example
 * Sample Usage
 * ```
 *  const taskQueue = new TaskQueue({
 *      group: ["group1"]
 *  })
 *  taskQueue.add({
 *     group: "group1",
 *     execute: () => {
 *         console.log("task of group1 executed");
 *     },
 *     getPrio: () => {
 *         return 0;
 *     }
 *   });
 *
 * taskQueue.update();
 * taskQueue.processNext("group1");
 *
 *  ```
 */
class TaskQueue {
    constructor(m_options) {
        var _a;
        this.m_options = m_options;
        this.m_taskLists = new Map();
        (_a = this.m_options.groups) === null || _a === void 0 ? void 0 : _a.forEach(group => {
            this.m_taskLists.set(group, []);
        });
        if (this.m_options.prioSortFn) {
            this.sort = this.m_options.prioSortFn;
        }
    }
    /**
     * Updates the lists in the queue depending on their priority functions and removes
     * expired Tasks, based on their isExpired functions result.
     *
     * @param group The Group to update, if not set all groups will be updated.
     */
    update(group) {
        if (group === undefined) {
            this.m_taskLists.forEach(taskList => {
                this.updateTaskList(taskList);
            });
        }
        else {
            const taskList = this.getTaskList(group);
            if (taskList) {
                this.updateTaskList(taskList);
            }
        }
    }
    /**
     * Adds a Task to the Queue
     *
     * @param task
     * @returns true if succesfully added, otherwise false
     */
    add(task) {
        var _a;
        if (this.m_taskLists.has(task.group)) {
            const taskList = this.m_taskLists.get(task.group);
            if (!(taskList === null || taskList === void 0 ? void 0 : taskList.includes(task))) {
                (_a = this.m_taskLists.get(task.group)) === null || _a === void 0 ? void 0 : _a.push(task);
                return true;
            }
        }
        return false;
    }
    /**
     * Removes a Task from the Queue
     *
     * @param task
     * @returns true if succesfully removed, otherwise false
     */
    remove(task) {
        var _a, _b;
        if (this.m_taskLists.has(task.group)) {
            const index = (_a = this.m_taskLists.get(task.group)) === null || _a === void 0 ? void 0 : _a.indexOf(task);
            if (index !== -1) {
                (_b = this.m_taskLists.get(task.group)) === null || _b === void 0 ? void 0 : _b.splice(index, 1);
                return true;
            }
        }
        return false;
    }
    /**
     * Returns the number of remaining tasks.
     *
     * @param group if group is set, it will return only the remaining tasks for this group,
     * otherwise it will return the complete amount of tasks left.
     */
    numItemsLeft(group) {
        var _a, _b;
        let numLeft = 0;
        if (group === undefined) {
            this.m_taskLists.forEach(tasklist => {
                numLeft += tasklist.length;
            });
        }
        else {
            numLeft += (_b = (_a = this.getTaskList(group)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        }
        return numLeft;
    }
    /**
     * Processes the next Tasks for a group
     *
     * @param group The group the Tasks are pulled from.
     * @param shouldProcess A condition that, if set will be executed before the task is processed,
     * if returns true, the task will run
     * @param n The amount of tasks that should be pulled, @defaults to 1
     * @returns false if thte list was empty
     */
    processNext(group, shouldProcess, n = 1) {
        if (!this.getTaskList(group) || this.numItemsLeft(group) <= 0) {
            return false;
        }
        for (let i = 0; i < n && this.numItemsLeft(group) > 0; i++) {
            const nextTask = this.pull(group, true);
            if (nextTask !== undefined) {
                //if a condition is set, execute it
                if (!shouldProcess || (shouldProcess === null || shouldProcess === void 0 ? void 0 : shouldProcess(nextTask))) {
                    nextTask.execute();
                }
                else {
                    //as the task was not executed but already pulled, add it back
                    //TODO: dont even pull it if it will not execute, this currently
                    // interferes with the skipping and removal of expired tasks on this.pull
                    this.add(nextTask);
                }
            }
        }
        return true;
    }
    pull(group, checkIfExpired = false) {
        var _a, _b;
        const taskList = this.getTaskList(group);
        let nextTask;
        if (taskList) {
            nextTask = (_a = this.getTaskList(group)) === null || _a === void 0 ? void 0 : _a.pop();
            if (checkIfExpired && nextTask && ((_b = nextTask.isExpired) === null || _b === void 0 ? void 0 : _b.call(nextTask))) {
                return this.pull(group, checkIfExpired);
            }
        }
        return nextTask;
    }
    sort(a, b) {
        // the highest number in the beginning as the last in the array with
        // highest priority which equals 0 will start to be processed
        return b.getPriority() - a.getPriority();
    }
    getTaskList(group) {
        return this.m_taskLists.get(group);
    }
    updateTaskList(taskList) {
        var _a;
        for (let i = 0; i < taskList.length; i++) {
            const task = taskList[i];
            if ((_a = task === null || task === void 0 ? void 0 : task.isExpired) === null || _a === void 0 ? void 0 : _a.call(task)) {
                taskList.splice(i, 1);
                i--;
            }
        }
        taskList.sort(this.sort);
    }
}
exports.TaskQueue = TaskQueue;
//# sourceMappingURL=TaskQueue.js.map