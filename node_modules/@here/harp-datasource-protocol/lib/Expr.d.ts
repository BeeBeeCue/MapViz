import { Env, Value } from "./Env";
import { OperatorDescriptor } from "./ExprEvaluator";
import { InstantiationContext } from "./ExprInstantiator";
import { ExprPool } from "./ExprPool";
import { Pixels } from "./Pixels";
import { RGBA } from "./RGBA";
import { Definitions } from "./Theme";
export * from "./Env";
/**
 * A visitor for {@link Expr} nodes.
 */
export interface ExprVisitor<Result, Context> {
    visitNullLiteralExpr(expr: NullLiteralExpr, context: Context): Result;
    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: Context): Result;
    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: Context): Result;
    visitStringLiteralExpr(expr: StringLiteralExpr, context: Context): Result;
    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: Context): Result;
    visitVarExpr(expr: VarExpr, context: Context): Result;
    visitHasAttributeExpr(expr: HasAttributeExpr, context: Context): Result;
    visitCallExpr(expr: CallExpr, context: Context): Result;
    visitMatchExpr(expr: MatchExpr, context: Context): Result;
    visitCaseExpr(expr: CaseExpr, context: Context): Result;
    visitStepExpr(expr: StepExpr, context: Context): Result;
    visitInterpolateExpr(expr: InterpolateExpr, context: Context): Result;
}
/**
 * The dependencies of an {@link Expr}.
 */
export declare class ExprDependencies {
    /**
     * The properties needed to evaluate the {@link Expr}.
     */
    readonly properties: Set<string>;
    /**
     * `true` if the expression depends on the feature state.
     */
    featureState?: boolean;
    /**
     * `true` if this expression cannot be cached.
     */
    volatile?: boolean;
}
/**
 * A type represeting JSON values.
 */
export declare type JsonValue = null | boolean | number | string | JsonObject | JsonArray;
/**
 * A type representing JSON arrays.
 */
export interface JsonArray extends Array<JsonValue> {
}
/**
 * A type representing JSON objects.
 */
export interface JsonObject {
    [name: string]: JsonValue;
}
/**
 * The JSON representation of an {@link Expr} object.
 */
export declare type JsonExpr = JsonArray;
export declare function isJsonExpr(v: any): v is JsonExpr;
/**
 * The evaluation scope of an {@link Expr}.
 */
export declare enum ExprScope {
    /**
     * The scope of an {@link Expr} used as value of an attribute.
     */
    Value = 0,
    /**
     * The scope of an {@link Expr} used in a [[Technique]] `when` condition.
     */
    Condition = 1,
    /**
     * The scope of an {@link Expr} used as dynamic property attribute value.
     */
    Dynamic = 2
}
/**
 * Abstract class representing the
 * {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md | style expressions}
 * used in {@link Theme}.
 */
export declare abstract class Expr {
    /**
     * Tests of given value is an {@link Expr}.
     *
     * @param value - The object to test.
     */
    static isExpr(value: any): value is Expr;
    /**
     * Creates an expression from the given `code`.
     *
     * @param code - The code to parse.
     * @returns The parsed {@link Expr}.
     * @deprecated `string` encoded expression are deprecated. Use {@link Expr.fromJSON} instead.
     */
    static parse(code: string): Expr | never;
    /**
     * Creates a style expression from JSON.
     *
     * @remarks
     * The optional set of {@link Theme.definitions | definitions} is used
     * to resolve the {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md#ref | ref expressions}.
     *
     * @param json - JSON object representing the expression to parse.
     * @param definitions - Optional set of definitions used to expand references.
     * @param definitionExprCache - Optional cache of `Expr` instances
     *
     * @example
     * ```typescript
     * const expr = Expr.fromJSON(["all",
     *     ["==", ["geometry-type"], "LineString"],
     *     ["has", "text"]
     * ]);
     * ```
     */
    static fromJSON(json: JsonValue, definitions?: Definitions, definitionExprCache?: Map<string, Expr>): Expr;
    private m_dependencies?;
    private m_isDynamic?;
    /**
     * Evaluate an expression returning a {@link Value} object.
     *
     * @param env - The {@link Env} used to lookup symbols.
     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].
     * @param cache - A cache of previously computed results.
     */
    evaluate(env: Env, scope?: ExprScope, cache?: Map<Expr, Value>): Value | never;
    /**
     * Instantiates this {@link Expr}.
     *
     * @remarks
     * references to the `get` and `has` operator using the given instantiation context.
     *
     * @param context - The [[InstantationContext]] used to resolve names.
     */
    instantiate(context: InstantiationContext): Expr;
    /**
     * Gets the dependencies of this {@link Expr}.
     */
    dependencies(): ExprDependencies;
    /**
     * Create a unique object that is structurally equivalent to this {@link Expr}.
     *
     * @param pool - The [[ExprPool]] used to create a unique
     * equivalent object of this {@link Expr}.
     */
    intern(pool: ExprPool): Expr;
    toJSON(): JsonValue;
    /**
     * Returns `true` if a dynamic execution context is required to evaluate this {@link Expr}.
     */
    isDynamic(): boolean;
    /**
     * Visits this expression.
     *
     * @param visitor The visitor used to visit the expression.
     * @param context The context passed to the vistor.
     */
    abstract accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    /**
     * Update the dynamic state of this {@link Expr}.
     *
     * `exprIsDynamic` must never be called directly.
     * @internal
     */
    protected abstract exprIsDynamic(): boolean;
}
/**
 * @internal
 */
export declare type RelationalOp = "<" | ">" | "<=" | ">=";
/**
 * @internal
 */
export declare type EqualityOp = "~=" | "^=" | "$=" | "==" | "!=";
/**
 * @internal
 */
export declare type BinaryOp = RelationalOp | EqualityOp;
/**
 * A node representing a `get` expression.
 */
export declare class VarExpr extends Expr {
    readonly name: string;
    constructor(name: string);
    /** @override */
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    /** @override */
    protected exprIsDynamic(): boolean;
}
/**
 * A node representing a `literal` expression.
 */
export declare abstract class LiteralExpr extends Expr {
    /**
     * Create a [[LiteralExpr]] from the given value.
     *
     * @param value - A constant value.
     */
    static fromValue(value: Value): Expr;
    abstract get value(): Value;
    /** @override */
    protected exprIsDynamic(): boolean;
}
/**
 * Null literal expression.
 */
export declare class NullLiteralExpr extends LiteralExpr {
    static instance: NullLiteralExpr;
    /** @override */
    readonly value: Value;
    protected constructor();
    /** @override */
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    /** @override */
    protected exprIsDynamic(): boolean;
}
/**
 * Boolean literal expression.
 */
export declare class BooleanLiteralExpr extends LiteralExpr {
    readonly value: boolean;
    constructor(value: boolean);
    /** @override */
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
}
/**
 * Number literal expression.
 */
export declare class NumberLiteralExpr extends LiteralExpr {
    readonly value: number;
    constructor(value: number);
    /** @override */
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
}
/**
 * String literal expression.
 */
export declare class StringLiteralExpr extends LiteralExpr {
    readonly value: string;
    private m_promotedValue?;
    constructor(value: string);
    /**
     * Returns the value of parsing this string as [[RGBA]] or [[Pixels]] constant.
     */
    get promotedValue(): RGBA | Pixels | undefined;
    /** @override */
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
}
/**
 * Object literal expression.
 */
export declare class ObjectLiteralExpr extends LiteralExpr {
    readonly value: object;
    constructor(value: object);
    get isArrayLiteral(): boolean;
    /** @override */
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
}
/**
 * A node reperesenting a `has` expression.
 */
export declare class HasAttributeExpr extends Expr {
    readonly name: string;
    constructor(name: string);
    /** @override */
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    /** @override */
    protected exprIsDynamic(): boolean;
}
/**
 * A node representing a `call` expression.
 */
export declare class CallExpr extends Expr {
    readonly op: string;
    readonly args: Expr[];
    descriptor?: OperatorDescriptor;
    constructor(op: string, args: Expr[]);
    /**
     * Returns the child nodes of this {@link Expr}.
     *
     * @deprecated Use {@link CallExpr.args} instead.
     */
    get children(): Expr[];
    /** @override */
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    /** @override */
    protected exprIsDynamic(): boolean;
}
/**
 * The labels of a {@link MatchExpr} expression.
 */
export declare type MatchLabel = number | string | number[] | string[];
/**
 * A node representing a `match` expression.
 */
export declare class MatchExpr extends Expr {
    readonly value: Expr;
    readonly branches: Array<[MatchLabel, Expr]>;
    readonly fallback: Expr;
    /**
     * Tests if the given JSON node is a valid label for the `"match"` operator.
     *
     * @param node - A JSON value.
     */
    static isValidMatchLabel(node: JsonValue): node is MatchLabel;
    constructor(value: Expr, branches: Array<[MatchLabel, Expr]>, fallback: Expr);
    /** @override */
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    /** @override */
    protected exprIsDynamic(): boolean;
}
/**
 * A node representing a `case` expression.
 */
export declare class CaseExpr extends Expr {
    readonly branches: Array<[Expr, Expr]>;
    readonly fallback: Expr;
    constructor(branches: Array<[Expr, Expr]>, fallback: Expr);
    /** @override */
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    /** @override */
    protected exprIsDynamic(): boolean;
}
/**
 * A node representing a `step` expression.
 */
export declare class StepExpr extends Expr {
    readonly input: Expr;
    readonly defaultValue: Expr;
    readonly stops: Array<[number, Expr]>;
    constructor(input: Expr, defaultValue: Expr, stops: Array<[number, Expr]>);
    /** @override */
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    /** @override */
    protected exprIsDynamic(): boolean;
}
/**
 * The type of the interpolation mode.
 */
export declare type InterpolateMode = ["discrete"] | ["linear"] | ["cubic"] | ["exponential", number];
/**
 * A node representing an `interpolate` expression.
 */
export declare class InterpolateExpr extends Expr {
    readonly mode: InterpolateMode;
    readonly input: Expr;
    readonly stops: Array<[number, Expr]>;
    constructor(mode: InterpolateMode, input: Expr, stops: Array<[number, Expr]>);
    /** @override */
    accept<Result, Context>(visitor: ExprVisitor<Result, Context>, context: Context): Result;
    /** @override */
    protected exprIsDynamic(): boolean;
}
//# sourceMappingURL=Expr.d.ts.map