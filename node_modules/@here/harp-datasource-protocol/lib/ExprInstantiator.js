"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExprInstantiator = void 0;
const Env_1 = require("./Env");
const Expr_1 = require("./Expr");
const emptyEnv = new Env_1.Env();
/**
 * @hidden
 */
class ExprInstantiator {
    visitNullLiteralExpr(expr, _context) {
        return expr;
    }
    visitBooleanLiteralExpr(expr, _context) {
        return expr;
    }
    visitNumberLiteralExpr(expr, _context) {
        return expr;
    }
    visitStringLiteralExpr(expr, _context) {
        return expr;
    }
    visitObjectLiteralExpr(expr, _context) {
        return expr;
    }
    visitVarExpr(expr, context) {
        if (context.preserve && context.preserve.has(expr.name)) {
            return expr;
        }
        const value = context.env.lookup(expr.name);
        return Expr_1.LiteralExpr.fromValue(value !== undefined ? value : null);
    }
    visitHasAttributeExpr(expr, context) {
        if (context.preserve && context.preserve.has(expr.name)) {
            return expr;
        }
        const value = context.env.lookup(expr.name) !== undefined;
        return Expr_1.LiteralExpr.fromValue(value);
    }
    visitCallExpr(expr, context) {
        const args = expr.args.map(arg => arg.accept(this, context));
        if (args.some((a, i) => a !== expr.args[i])) {
            return new Expr_1.CallExpr(expr.op, args);
        }
        return expr;
    }
    visitMatchExpr(match, context) {
        const value = match.value.accept(this, context);
        if (value instanceof Expr_1.LiteralExpr) {
            const r = value.value;
            for (const [label, body] of match.branches) {
                if (Array.isArray(label) && label.includes(r)) {
                    return body.accept(this, context);
                }
                else if (label === r) {
                    return body.accept(this, context);
                }
            }
            return match.fallback.accept(this, context);
        }
        let changed = match.value !== value;
        const branches = match.branches.map(([label, branch]) => {
            const newBranch = branch.accept(this, context);
            if (newBranch !== branch) {
                changed = true;
            }
            return [label, newBranch];
        });
        const fallback = match.fallback.accept(this, context);
        if (fallback !== match.fallback) {
            changed = true;
        }
        return changed ? new Expr_1.MatchExpr(value, branches, fallback) : match;
    }
    visitCaseExpr(expr, context) {
        const branches = [];
        let changed = false;
        for (const [condition, branch] of expr.branches) {
            const newCondition = condition.accept(this, context);
            const deps = newCondition.dependencies();
            if (!condition.isDynamic() && deps.properties.size === 0) {
                if (Boolean(newCondition.evaluate(emptyEnv, Expr_1.ExprScope.Condition))) {
                    return branch.accept(this, context);
                }
            }
            else {
                if (newCondition !== condition) {
                    changed = true;
                }
                branches.push([newCondition, branch]);
            }
        }
        if (branches.length === 0) {
            // all the conditions of this CaseExpr evaluated
            // to false, so the resulting of instantiating this CaseExpr
            // is the same as instantiating its fallback expression.
            return expr.fallback.accept(this, context);
        }
        if (branches.length !== expr.branches.length) {
            // the number of branches changed, this means that
            // some of the branches had constant expressions that
            // evaluate to false. In this case the resulting
            // `CaseExpr` has less branches.
            changed = true;
        }
        // Instantiate the body of all the branches of this CaseExpr
        // that have dynamic conditions.
        branches.forEach(branch => {
            const instantiatedBranch = branch[1].accept(this, context);
            if (instantiatedBranch !== branch[1]) {
                changed = true;
            }
            branch[1] = instantiatedBranch;
        });
        const fallback = expr.fallback.accept(this, context);
        if (fallback !== expr.fallback) {
            changed = true;
        }
        if (!changed) {
            // nothing changed, return the old expression.
            return expr;
        }
        return new Expr_1.CaseExpr(branches, fallback);
    }
    visitStepExpr(expr, context) {
        const input = expr.input.accept(this, context);
        const defaultValue = expr.defaultValue.accept(this, context);
        const stops = expr.stops.map(([key, value]) => [
            key,
            value.accept(this, context)
        ]);
        return new Expr_1.StepExpr(input, defaultValue, stops);
    }
    visitInterpolateExpr(expr, context) {
        const input = expr.input.accept(this, context);
        const stops = expr.stops.map(([key, value]) => [
            key,
            value.accept(this, context)
        ]);
        return new Expr_1.InterpolateExpr(expr.mode, input, stops);
    }
}
exports.ExprInstantiator = ExprInstantiator;
//# sourceMappingURL=ExprInstantiator.js.map