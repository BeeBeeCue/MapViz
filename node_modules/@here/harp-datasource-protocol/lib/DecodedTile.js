"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFeatureText = exports.getFeatureName = exports.getFeatureId = exports.getProjectionName = exports.getProjection = exports.GeometryType = exports.getArrayConstructor = void 0;
const harp_geoutils_1 = require("@here/harp-geoutils");
const Expr_1 = require("./Expr");
const TechniqueAttr_1 = require("./TechniqueAttr");
const Techniques_1 = require("./Techniques");
/**
 * Returns an array with the data type specified as parameter.
 *
 * @param attr - specifies which type of data is being stored in the array
 */
function getArrayConstructor(attr) {
    switch (attr) {
        case "float":
            return Float32Array;
        case "uint8":
            return Uint8Array;
        case "uint16":
            return Uint16Array;
        case "uint32":
            return Uint32Array;
        case "int8":
            return Int8Array;
        case "int16":
            return Int16Array;
        case "int32":
            return Int32Array;
    }
}
exports.getArrayConstructor = getArrayConstructor;
/**
 * Geometry types supported by [[Geometry]] objects.
 */
var GeometryType;
(function (GeometryType) {
    GeometryType[GeometryType["Unspecified"] = 0] = "Unspecified";
    GeometryType[GeometryType["Point"] = 1] = "Point";
    GeometryType[GeometryType["Line"] = 2] = "Line";
    GeometryType[GeometryType["SolidLine"] = 3] = "SolidLine";
    GeometryType[GeometryType["Text"] = 4] = "Text";
    GeometryType[GeometryType["TextPath"] = 5] = "TextPath";
    GeometryType[GeometryType["ExtrudedLine"] = 6] = "ExtrudedLine";
    GeometryType[GeometryType["Polygon"] = 7] = "Polygon";
    GeometryType[GeometryType["ExtrudedPolygon"] = 8] = "ExtrudedPolygon";
    GeometryType[GeometryType["Object3D"] = 9] = "Object3D";
    GeometryType[GeometryType["Other"] = 1000] = "Other";
})(GeometryType = exports.GeometryType || (exports.GeometryType = {}));
/**
 * Returns the projection object specified in the parameter.
 *
 * @param projectionName - string describing projection to be used
 */
function getProjection(projectionName) {
    switch (projectionName) {
        case "mercator":
            return harp_geoutils_1.mercatorProjection;
        case "webMercator":
            return harp_geoutils_1.webMercatorProjection;
        case "sphere":
            return harp_geoutils_1.sphereProjection;
        case "normalizedEquirectangular":
            return harp_geoutils_1.normalizedEquirectangularProjection;
        case "equirectangular":
            return harp_geoutils_1.equirectangularProjection;
        default:
            throw new Error(`Unknown projection ${projectionName}`);
    } // switch
}
exports.getProjection = getProjection;
/**
 * String with the projection's name.
 *
 * @param projection - `Projection` object containing the name of the projection to retrieve
 */
function getProjectionName(projection) {
    if (projection === harp_geoutils_1.mercatorProjection) {
        return "mercator";
    }
    else if (projection === harp_geoutils_1.webMercatorProjection) {
        return "webMercator";
    }
    else if (projection === harp_geoutils_1.sphereProjection) {
        return "sphere";
    }
    else if (projection === harp_geoutils_1.normalizedEquirectangularProjection) {
        return "normalizedEquirectangular";
    }
    else if (projection === harp_geoutils_1.equirectangularProjection) {
        return "equirectangular";
    }
    throw new Error("Unknown projection");
}
exports.getProjectionName = getProjectionName;
/**
 * @returns Feature id from the provided attribute map.
 */
function getFeatureId(attributeMap) {
    if (attributeMap === undefined) {
        return 0;
    }
    if (typeof attributeMap === "number") {
        return attributeMap;
    }
    if (attributeMap.hasOwnProperty("$id")) {
        return attributeMap.$id;
    }
    return 0;
}
exports.getFeatureId = getFeatureId;
/**
 * Determine the name of (OMV) feature. It implements the special handling required
 * to determine the text content of a feature from its tags, which are passed in as the `env`.
 *
 * @param env - Environment containing the tags from the (OMV) feature.
 * @param useAbbreviation - `true` to use the abbreviation if available.
 * @param useIsoCode - `true` to use the tag "iso_code".
 * @param languages - List of languages to use, for example: Specify "en" to use the tag "name_en"
 *                  as the text of the string. Order reflects priority.
 */
function getFeatureName(env, basePropName, useAbbreviation, useIsoCode, languages) {
    var _a;
    let name;
    if (basePropName === undefined) {
        basePropName = "name";
    }
    if (useAbbreviation) {
        const abbreviation = env.lookup(`${basePropName}:short`);
        if (typeof abbreviation === "string" && abbreviation.length > 0) {
            return abbreviation;
        }
    }
    if (useIsoCode) {
        const isoCode = env.lookup(`iso_code`);
        if (typeof isoCode === "string" && isoCode.length > 0) {
            return isoCode;
        }
    }
    if (languages !== undefined) {
        for (const lang of languages) {
            name = (_a = env.lookup(`${basePropName}:${lang}`)) !== null && _a !== void 0 ? _a : env.lookup(`${basePropName}_${lang}`);
            if (typeof name === "string" && name.length > 0) {
                return name;
            }
        }
    }
    name = env.lookup(basePropName);
    if (typeof name === "string") {
        return name;
    }
    return undefined;
}
exports.getFeatureName = getFeatureName;
/**
 * Determine the text string of the map feature. It implements the special handling required
 * to determine the text content of a feature from its tags, which are passed in as the `env`.
 *
 * @param feature - Feature, including properties from the (OMV) feature.
 * @param technique - technique defining how text should be created from feature
 * @param languages - List of languages to use, for example: Specify "en" to use the tag "name_en"
 *                  as the text of the string. Order reflects priority.
 */
function getFeatureText(context, technique, languages) {
    let useAbbreviation;
    let useIsoCode;
    const env = context instanceof Expr_1.Env ? context : context.env;
    let propName = "name";
    if (Techniques_1.isTextTechnique(technique) ||
        Techniques_1.isPoiTechnique(technique) ||
        Techniques_1.isLineMarkerTechnique(technique)) {
        if (technique.text !== undefined) {
            return TechniqueAttr_1.evaluateTechniqueAttr(context, technique.text);
        }
        if (technique.label !== undefined) {
            propName = TechniqueAttr_1.evaluateTechniqueAttr(context, technique.label);
            if (typeof propName !== "string") {
                return undefined;
            }
        }
        useAbbreviation = technique.useAbbreviation;
        useIsoCode = technique.useIsoCode;
    }
    return getFeatureName(env, propName, useAbbreviation, useIsoCode, languages);
}
exports.getFeatureText = getFeatureText;
//# sourceMappingURL=DecodedTile.js.map