"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPropertyValue = void 0;
const harp_utils_1 = require("@here/harp-utils");
const Expr_1 = require("./Expr");
const Pixels_1 = require("./Pixels");
const RGBA_1 = require("./RGBA");
const StringEncodedNumeral_1 = require("./StringEncodedNumeral");
const logger = harp_utils_1.LoggerManager.instance.create("PropertyValue");
/**
 * Get the value of the specified property in given `env`.
 *
 * @param property - Property of a technique.
 * @param env - The {@link Env} used to evaluate the property
 * @param cache - An optional expression cache.
 */
function getPropertyValue(property, env, cache) {
    var _a, _b, _c;
    if (Expr_1.Expr.isExpr(property)) {
        try {
            let r = property.evaluate(env, Expr_1.ExprScope.Dynamic, cache);
            if (typeof r === "string") {
                r = (_b = (_a = RGBA_1.RGBA.parse(r)) !== null && _a !== void 0 ? _a : Pixels_1.Pixels.parse(r)) !== null && _b !== void 0 ? _b : r;
            }
            if (r instanceof RGBA_1.RGBA) {
                return r.getHex();
            }
            else if (r instanceof Pixels_1.Pixels) {
                return r.value * ((_c = Number(env.lookup("$pixelToMeters"))) !== null && _c !== void 0 ? _c : 1);
            }
            return r;
        }
        catch (error) {
            logger.error("failed to evaluate expression", JSON.stringify(property), "error", String(error));
            return null;
        }
    }
    if (property === null || typeof property === "undefined") {
        return null;
    }
    else if (typeof property !== "string") {
        // Property in numeric or array, etc. format
        return property;
    }
    else {
        // Non-interpolated string encoded numeral parsing
        const pixelToMeters = env.lookup("$pixelToMeters") || 1;
        const value = StringEncodedNumeral_1.parseStringEncodedNumeral(property, pixelToMeters);
        return value !== undefined ? value : property;
    }
}
exports.getPropertyValue = getPropertyValue;
//# sourceMappingURL=PropertyValue.js.map