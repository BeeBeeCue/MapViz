"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.isTextureBuffer = exports.PlacementToken = exports.PoiStackMode = exports.TextureCoordinateType = exports.GeometryKindSet = exports.GeometryKind = exports.StandardGeometryKind = void 0;
/**
 * Standard kinds of geometry.
 */
var StandardGeometryKind;
(function (StandardGeometryKind) {
    /**
     * Used in the enabledKinds/disabledKinds filter to match any kind.
     */
    StandardGeometryKind["All"] = "_all_";
    /**
     * Background geometry.
     */
    StandardGeometryKind["Background"] = "background";
    /**
     * Terrain geometry.
     */
    StandardGeometryKind["Terrain"] = "terrain";
    /**
     * Default value for the FillTechnique.
     */
    StandardGeometryKind["Area"] = "area";
    /**
     * Default value for all line techniques.
     */
    StandardGeometryKind["Line"] = "line";
    /**
     * Default value for the FillTechnique.
     */
    StandardGeometryKind["Water"] = "water";
    /**
     * Political borders.
     */
    StandardGeometryKind["Border"] = "border";
    /**
     * Basis for all roads.
     */
    StandardGeometryKind["Road"] = "road";
    /**
     * Default value for the ExtrudedPolygonTechnique.
     */
    StandardGeometryKind["Building"] = "building";
    /**
     * Default value for the TextTechnique, LineMarkerTechnique and the PoiTechnique.
     */
    StandardGeometryKind["Label"] = "label";
    /**
     * Anything that may show up last.
     */
    StandardGeometryKind["Detail"] = "detail";
})(StandardGeometryKind = exports.StandardGeometryKind || (exports.StandardGeometryKind = {}));
exports.GeometryKind = StandardGeometryKind;
/**
 * A set of {@link GeometryKind}s.
 */
class GeometryKindSet extends Set {
    /**
     * Return `true` if the Set is a superset of the set 'subset'.
     */
    isSuperset(subset) {
        for (const elem of subset) {
            if (!this.has(elem)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Return `true` if the Set intersects Set 'set'.
     */
    hasIntersection(set) {
        for (const elem of set) {
            if (this.has(elem)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Return `true` if the Set either intersects Set 'set' (if set is a Set), of has element 'set'
     * if set is not a Set.
     */
    hasOrIntersects(set) {
        if (set instanceof Set) {
            return this.hasIntersection(set);
        }
        return this.has(set);
    }
    /**
     * Return `true` if this set and the array of elements share at least a single element.
     */
    hasOrIntersectsArray(subset) {
        for (const elem of subset) {
            if (this.has(elem)) {
                return true;
            }
        }
        return false;
    }
}
exports.GeometryKindSet = GeometryKindSet;
var TextureCoordinateType;
(function (TextureCoordinateType) {
    /**
     * Texture coordinates are in tile space.
     *
     * @remarks
     * SW of the tile will have (0,0) and NE will have (1,1).
     */
    TextureCoordinateType["TileSpace"] = "tile-space";
    /**
     * Texture coordinates are in equirectangular space.
     *
     * @remarks
     * (u, v) = ( (longitude+180) / 360, (latitude+90) / 180).
     */
    TextureCoordinateType["EquirectangularSpace"] = "equirectangular-space";
    /**
     * Texture coordinates in feature space.
     *
     * @remarks
     * To compute texture coordinates in feature space,
     * the feature must have a property named `bbox` with value
     * the tuple `[west, south, east, north]`.
     */
    TextureCoordinateType["FeatureSpace"] = "feature-space";
})(TextureCoordinateType = exports.TextureCoordinateType || (exports.TextureCoordinateType = {}));
/**
 * Define the stacking option. Enum values for theme file are in "kebab-case".
 */
var PoiStackMode;
(function (PoiStackMode) {
    /**
     * Show in a stack.
     */
    PoiStackMode["Show"] = "show-in-stack";
    /**
     * Do not show in a stack.
     */
    PoiStackMode["Hide"] = "hide-in-stack";
    /**
     * Show category parent in the stack.
     */
    PoiStackMode["ShowParent"] = "show-parent";
})(PoiStackMode = exports.PoiStackMode || (exports.PoiStackMode = {}));
/**
 * Defines options (tokens) supported for text placements defined via [[placements]] attribute.
 *
 * @remarks
 * Possible values are defined as vertical placement letter and horizontal letter, where
 * one of the axis may be ignored and then assumed centered. Moving clock-wise, we have:
 * `TL` (top-left), `T` (top-center), `TR` (top-right), `R` (center-right), `BR` (bottom-right),
 * `B` (bottom-center), `BL` (bottom-left), `L` (left), `C` (center-center).
 * Alternatively instead of `T`, `B`, `L`, `R` geographic directions may be used accordingly:
 * `NW` (north-west), `N` (north), `NE` (north-east), `E` (east), `SE` (south-east), `S` (south),
 * `SW` (south-west), `W` (west).
 */
var PlacementToken;
(function (PlacementToken) {
    PlacementToken["TopLeft"] = "TL";
    PlacementToken["Top"] = "T";
    PlacementToken["TopRight"] = "TR";
    PlacementToken["Right"] = "R";
    PlacementToken["BottomRight"] = "BR";
    PlacementToken["Bottom"] = "B";
    PlacementToken["BottomLeft"] = "BL";
    PlacementToken["Left"] = "L";
    PlacementToken["Center"] = "C";
    PlacementToken["NorthWest"] = "NW";
    PlacementToken["North"] = "N";
    PlacementToken["NorthEast"] = "NE";
    PlacementToken["East"] = "E";
    PlacementToken["SouthEast"] = "SE";
    PlacementToken["South"] = "S";
    PlacementToken["SouthWest"] = "SW";
    PlacementToken["West"] = "W";
})(PlacementToken = exports.PlacementToken || (exports.PlacementToken = {}));
/**
 * Type guard to check if an object is an instance of `TextureBuffer`.
 */
function isTextureBuffer(object) {
    return object && object.buffer && typeof object.type === "string";
}
exports.isTextureBuffer = isTextureBuffer;
//# sourceMappingURL=TechniqueParams.js.map