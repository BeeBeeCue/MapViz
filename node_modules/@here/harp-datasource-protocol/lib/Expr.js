"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InterpolateExpr = exports.StepExpr = exports.CaseExpr = exports.MatchExpr = exports.CallExpr = exports.HasAttributeExpr = exports.ObjectLiteralExpr = exports.StringLiteralExpr = exports.NumberLiteralExpr = exports.BooleanLiteralExpr = exports.NullLiteralExpr = exports.LiteralExpr = exports.VarExpr = exports.Expr = exports.ExprScope = exports.isJsonExpr = exports.ExprDependencies = void 0;
const THREE = require("three");
const ExprEvaluator_1 = require("./ExprEvaluator");
const ExprInstantiator_1 = require("./ExprInstantiator");
const ExprParser_1 = require("./ExprParser");
const InterpolatedPropertyDefs_1 = require("./InterpolatedPropertyDefs");
const Pixels_1 = require("./Pixels");
const RGBA_1 = require("./RGBA");
__exportStar(require("./Env"), exports);
const exprEvaluator = new ExprEvaluator_1.ExprEvaluator();
const exprInstantiator = new ExprInstantiator_1.ExprInstantiator();
/**
 * The dependencies of an {@link Expr}.
 */
class ExprDependencies {
    constructor() {
        /**
         * The properties needed to evaluate the {@link Expr}.
         */
        this.properties = new Set();
    }
}
exports.ExprDependencies = ExprDependencies;
class ComputeExprDependencies {
    /**
     * Gets the dependencies of an {@link Expr}.
     *
     * @param expr - The {@link Expr} to process.
     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].
     * @param dependencies - The output [[Set]] of dependency names.
     */
    static of(expr) {
        const dependencies = new ExprDependencies();
        expr.accept(this.instance, dependencies);
        return dependencies;
    }
    visitNullLiteralExpr(expr, context) {
        // nothing to do
    }
    visitBooleanLiteralExpr(expr, context) {
        // nothing to do
    }
    visitNumberLiteralExpr(expr, context) {
        // nothing to do
    }
    visitStringLiteralExpr(expr, context) {
        // nothing to do
    }
    visitObjectLiteralExpr(expr, context) {
        // nothing to do
    }
    visitVarExpr(expr, context) {
        context.properties.add(expr.name);
    }
    visitHasAttributeExpr(expr, context) {
        context.properties.add(expr.name);
    }
    visitCallExpr(expr, context) {
        expr.args.forEach(childExpr => childExpr.accept(this, context));
        switch (expr.op) {
            case "dynamic-properties":
                context.volatile = true;
                break;
            case "feature-state":
                context.featureState = true;
                context.properties.add("$state");
                context.properties.add("$id");
                break;
            case "id":
                context.properties.add("$id");
                break;
            case "zoom":
            case "world-ppi-scale":
            case "world-discrete-ppi-scale":
                context.properties.add("$zoom");
                break;
            case "geometry-type":
                context.properties.add("$geometryType");
                break;
            default:
                break;
        }
    }
    visitMatchExpr(expr, context) {
        expr.value.accept(this, context);
        expr.branches.forEach(([_, branch]) => branch.accept(this, context));
        expr.fallback.accept(this, context);
    }
    visitCaseExpr(expr, context) {
        expr.branches.forEach(([condition, branch]) => {
            condition.accept(this, context);
            branch.accept(this, context);
        });
        expr.fallback.accept(this, context);
    }
    visitStepExpr(expr, context) {
        expr.input.accept(this, context);
        expr.defaultValue.accept(this, context);
        expr.stops.forEach(([_, value]) => value.accept(this, context));
    }
    visitInterpolateExpr(expr, context) {
        expr.input.accept(this, context);
        expr.stops.forEach(([_, value]) => value.accept(this, context));
    }
}
ComputeExprDependencies.instance = new ComputeExprDependencies();
function isJsonExpr(v) {
    return Array.isArray(v) && v.length > 0 && typeof v[0] === "string";
}
exports.isJsonExpr = isJsonExpr;
/**
 * The evaluation scope of an {@link Expr}.
 */
var ExprScope;
(function (ExprScope) {
    /**
     * The scope of an {@link Expr} used as value of an attribute.
     */
    ExprScope[ExprScope["Value"] = 0] = "Value";
    /**
     * The scope of an {@link Expr} used in a [[Technique]] `when` condition.
     */
    ExprScope[ExprScope["Condition"] = 1] = "Condition";
    /**
     * The scope of an {@link Expr} used as dynamic property attribute value.
     */
    ExprScope[ExprScope["Dynamic"] = 2] = "Dynamic";
})(ExprScope = exports.ExprScope || (exports.ExprScope = {}));
/**
 * Abstract class representing the
 * {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md | style expressions}
 * used in {@link Theme}.
 */
class Expr {
    /**
     * Tests of given value is an {@link Expr}.
     *
     * @param value - The object to test.
     */
    static isExpr(value) {
        return value instanceof Expr;
    }
    /**
     * Creates an expression from the given `code`.
     *
     * @param code - The code to parse.
     * @returns The parsed {@link Expr}.
     * @deprecated `string` encoded expression are deprecated. Use {@link Expr.fromJSON} instead.
     */
    static parse(code) {
        const parser = new ExprParser_1.ExprParser(code);
        const expr = parser.parse();
        return expr;
    }
    /**
     * Creates a style expression from JSON.
     *
     * @remarks
     * The optional set of {@link Theme.definitions | definitions} is used
     * to resolve the {@link https://github.com/heremaps/harp.gl/blob/master/%40here/harp-datasource-protocol/StyleExpressions.md#ref | ref expressions}.
     *
     * @param json - JSON object representing the expression to parse.
     * @param definitions - Optional set of definitions used to expand references.
     * @param definitionExprCache - Optional cache of `Expr` instances
     *
     * @example
     * ```typescript
     * const expr = Expr.fromJSON(["all",
     *     ["==", ["geometry-type"], "LineString"],
     *     ["has", "text"]
     * ]);
     * ```
     */
    static fromJSON(json, definitions, definitionExprCache) {
        const referenceResolverState = definitions !== undefined
            ? {
                definitions,
                lockedNames: new Set(),
                cache: definitionExprCache !== null && definitionExprCache !== void 0 ? definitionExprCache : new Map()
            }
            : undefined;
        return parseNode(json, referenceResolverState);
    }
    /**
     * Evaluate an expression returning a {@link Value} object.
     *
     * @param env - The {@link Env} used to lookup symbols.
     * @param scope - The evaluation scope. Defaults to [[ExprScope.Value]].
     * @param cache - A cache of previously computed results.
     */
    evaluate(env, scope = ExprScope.Value, cache) {
        return this.accept(exprEvaluator, new ExprEvaluator_1.ExprEvaluatorContext(exprEvaluator, env, scope, cache));
    }
    /**
     * Instantiates this {@link Expr}.
     *
     * @remarks
     * references to the `get` and `has` operator using the given instantiation context.
     *
     * @param context - The [[InstantationContext]] used to resolve names.
     */
    instantiate(context) {
        return this.accept(exprInstantiator, context);
    }
    /**
     * Gets the dependencies of this {@link Expr}.
     */
    dependencies() {
        if (!this.m_dependencies) {
            this.m_dependencies = ComputeExprDependencies.of(this);
        }
        return this.m_dependencies;
    }
    /**
     * Create a unique object that is structurally equivalent to this {@link Expr}.
     *
     * @param pool - The [[ExprPool]] used to create a unique
     * equivalent object of this {@link Expr}.
     */
    intern(pool) {
        return pool.add(this);
    }
    toJSON() {
        return new ExprSerializer().serialize(this);
    }
    /**
     * Returns `true` if a dynamic execution context is required to evaluate this {@link Expr}.
     */
    isDynamic() {
        if (this.m_isDynamic === undefined) {
            this.m_isDynamic = this.exprIsDynamic();
        }
        return this.m_isDynamic;
    }
}
exports.Expr = Expr;
/**
 * A node representing a `get` expression.
 */
class VarExpr extends Expr {
    constructor(name) {
        super();
        this.name = name;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitVarExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.VarExpr = VarExpr;
/**
 * A node representing a `literal` expression.
 */
class LiteralExpr extends Expr {
    /**
     * Create a [[LiteralExpr]] from the given value.
     *
     * @param value - A constant value.
     */
    static fromValue(value) {
        switch (typeof value) {
            case "boolean":
                return new BooleanLiteralExpr(value);
            case "number":
                return new NumberLiteralExpr(value);
            case "string":
                return new StringLiteralExpr(value);
            case "object":
                return value === null ? NullLiteralExpr.instance : new ObjectLiteralExpr(value);
            default:
                throw new Error(`failed to create a literal from '${value}'`);
        } // switch
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.LiteralExpr = LiteralExpr;
/**
 * Null literal expression.
 */
class NullLiteralExpr extends LiteralExpr {
    constructor() {
        super();
        /** @override */
        this.value = null;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitNullLiteralExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.NullLiteralExpr = NullLiteralExpr;
NullLiteralExpr.instance = new NullLiteralExpr();
/**
 * Boolean literal expression.
 */
class BooleanLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitBooleanLiteralExpr(this, context);
    }
}
exports.BooleanLiteralExpr = BooleanLiteralExpr;
/**
 * Number literal expression.
 */
class NumberLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitNumberLiteralExpr(this, context);
    }
}
exports.NumberLiteralExpr = NumberLiteralExpr;
/**
 * String literal expression.
 */
class StringLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    /**
     * Returns the value of parsing this string as [[RGBA]] or [[Pixels]] constant.
     */
    get promotedValue() {
        var _a, _b, _c;
        if (this.m_promotedValue === undefined) {
            this.m_promotedValue = (_b = (_a = RGBA_1.RGBA.parse(this.value)) !== null && _a !== void 0 ? _a : Pixels_1.Pixels.parse(this.value)) !== null && _b !== void 0 ? _b : null;
        }
        return (_c = this.m_promotedValue) !== null && _c !== void 0 ? _c : undefined;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitStringLiteralExpr(this, context);
    }
}
exports.StringLiteralExpr = StringLiteralExpr;
/**
 * Object literal expression.
 */
class ObjectLiteralExpr extends LiteralExpr {
    constructor(value) {
        super();
        this.value = value;
    }
    get isArrayLiteral() {
        return Array.isArray(this.value);
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitObjectLiteralExpr(this, context);
    }
}
exports.ObjectLiteralExpr = ObjectLiteralExpr;
/**
 * A node reperesenting a `has` expression.
 */
class HasAttributeExpr extends Expr {
    constructor(name) {
        super();
        this.name = name;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitHasAttributeExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return false;
    }
}
exports.HasAttributeExpr = HasAttributeExpr;
/**
 * A node representing a `call` expression.
 */
class CallExpr extends Expr {
    constructor(op, args) {
        super();
        this.op = op;
        this.args = args;
    }
    /**
     * Returns the child nodes of this {@link Expr}.
     *
     * @deprecated Use {@link CallExpr.args} instead.
     */
    get children() {
        return this.args;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitCallExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        var _a;
        const descriptor = (_a = this.descriptor) !== null && _a !== void 0 ? _a : ExprEvaluator_1.ExprEvaluator.getOperator(this.op);
        if (descriptor && descriptor.isDynamicOperator && descriptor.isDynamicOperator(this)) {
            return true;
        }
        return this.args.some(e => e.isDynamic());
    }
}
exports.CallExpr = CallExpr;
/**
 * A node representing a `match` expression.
 */
class MatchExpr extends Expr {
    constructor(value, branches, fallback) {
        super();
        this.value = value;
        this.branches = branches;
        this.fallback = fallback;
    }
    /**
     * Tests if the given JSON node is a valid label for the `"match"` operator.
     *
     * @param node - A JSON value.
     */
    static isValidMatchLabel(node) {
        switch (typeof node) {
            case "number":
            case "string":
                return true;
            case "object":
                if (!Array.isArray(node) || node.length === 0) {
                    return false;
                }
                const elementTy = typeof node[0];
                if (elementTy === "number" || elementTy === "string") {
                    return node.every(t => typeof t === elementTy);
                }
                return false;
            default:
                return false;
        } // switch
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitMatchExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return (this.value.isDynamic() ||
            this.branches.some(([_, branch]) => branch.isDynamic()) ||
            this.fallback.isDynamic());
    }
}
exports.MatchExpr = MatchExpr;
/**
 * A node representing a `case` expression.
 */
class CaseExpr extends Expr {
    constructor(branches, fallback) {
        super();
        this.branches = branches;
        this.fallback = fallback;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitCaseExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return (this.branches.some(([cond, branch]) => cond.isDynamic() || branch.isDynamic()) ||
            this.fallback.isDynamic());
    }
}
exports.CaseExpr = CaseExpr;
/**
 * A node representing a `step` expression.
 */
class StepExpr extends Expr {
    constructor(input, defaultValue, stops) {
        super();
        this.input = input;
        this.defaultValue = defaultValue;
        this.stops = stops;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitStepExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return (this.input.isDynamic() ||
            this.defaultValue.isDynamic() ||
            this.stops.some(([_, value]) => value.isDynamic()));
    }
}
exports.StepExpr = StepExpr;
/**
 * A node representing an `interpolate` expression.
 */
class InterpolateExpr extends Expr {
    constructor(mode, input, stops) {
        super();
        this.mode = mode;
        this.input = input;
        this.stops = stops;
    }
    /** @override */
    accept(visitor, context) {
        return visitor.visitInterpolateExpr(this, context);
    }
    /** @override */
    exprIsDynamic() {
        return this.input.isDynamic() || this.stops.some(([_, value]) => value.isDynamic());
    }
}
exports.InterpolateExpr = InterpolateExpr;
/**
 * Serializes the Expr to JSON.
 *
 * @internal
 */
class ExprSerializer {
    serialize(expr) {
        return expr.accept(this, undefined);
    }
    visitNullLiteralExpr(expr, context) {
        return null;
    }
    visitBooleanLiteralExpr(expr, context) {
        return expr.value;
    }
    visitNumberLiteralExpr(expr, context) {
        return expr.value;
    }
    visitStringLiteralExpr(expr, context) {
        return expr.value;
    }
    visitObjectLiteralExpr(expr, context) {
        if (expr.value instanceof THREE.Vector2) {
            return ["make-vector", expr.value.x, expr.value.y];
        }
        else if (expr.value instanceof THREE.Vector3) {
            return ["make-vector", expr.value.x, expr.value.y, expr.value.z];
        }
        else if (expr.value instanceof THREE.Vector4) {
            return ["make-vector", expr.value.x, expr.value.y, expr.value.z, expr.value.w];
        }
        return ["literal", expr.value];
    }
    visitVarExpr(expr, context) {
        return ["get", expr.name];
    }
    visitHasAttributeExpr(expr, context) {
        return ["has", expr.name];
    }
    visitCallExpr(expr, context) {
        return [expr.op, ...expr.args.map(childExpr => this.serialize(childExpr))];
    }
    visitMatchExpr(expr, context) {
        const branches = [];
        for (const [label, body] of expr.branches) {
            branches.push(label, this.serialize(body));
        }
        return ["match", this.serialize(expr.value), ...branches, this.serialize(expr.fallback)];
    }
    visitCaseExpr(expr, context) {
        const branches = [];
        for (const [condition, body] of expr.branches) {
            branches.push(this.serialize(condition), this.serialize(body));
        }
        return ["case", ...branches, this.serialize(expr.fallback)];
    }
    visitStepExpr(expr, context) {
        const result = ["step"];
        result.push(this.serialize(expr.input));
        result.push(this.serialize(expr.defaultValue));
        expr.stops.forEach(([key, value]) => {
            result.push(key);
            result.push(this.serialize(value));
        });
        return result;
    }
    visitInterpolateExpr(expr, context) {
        const result = ["interpolate", expr.mode];
        result.push(this.serialize(expr.input));
        expr.stops.forEach(([key, value]) => {
            result.push(key);
            result.push(this.serialize(value));
        });
        return result;
    }
}
function parseNode(node, referenceResolverState) {
    if (Array.isArray(node)) {
        return parseCall(node, referenceResolverState);
    }
    else if (node === null) {
        return NullLiteralExpr.instance;
    }
    else if (typeof node === "boolean") {
        return new BooleanLiteralExpr(node);
    }
    else if (typeof node === "number") {
        return new NumberLiteralExpr(node);
    }
    else if (typeof node === "string") {
        return new StringLiteralExpr(node);
    }
    throw new Error(`failed to create expression from: ${JSON.stringify(node)}`);
}
function parseCall(node, referenceResolverState) {
    const op = node[0];
    if (typeof op !== "string") {
        throw new Error("expected a builtin function name");
    }
    switch (op) {
        case "!has":
        case "!in":
            return new CallExpr("!", [parseCall([op.slice(1), ...node.slice(1)])]);
        case "ref":
            return resolveReference(node, referenceResolverState);
        case "get":
            return parseGetExpr(node, referenceResolverState);
        case "has":
            return parseHasExpr(node, referenceResolverState);
        case "literal":
            return parseLiteralExpr(node);
        case "match":
            return parseMatchExpr(node, referenceResolverState);
        case "case":
            return parseCaseExpr(node, referenceResolverState);
        case "interpolate":
            return parseInterpolateExpr(node, referenceResolverState);
        case "step":
            return parseStepExpr(node, referenceResolverState);
        default:
            return makeCallExpr(op, node, referenceResolverState);
    } // switch
}
function parseGetExpr(node, referenceResolverState) {
    if (node[2] !== undefined) {
        return makeCallExpr("get", node, referenceResolverState);
    }
    const name = node[1];
    if (typeof name !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    return new VarExpr(name);
}
function parseHasExpr(node, referenceResolverState) {
    if (node[2] !== undefined) {
        return makeCallExpr("has", node, referenceResolverState);
    }
    const name = node[1];
    if (typeof name !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    return new HasAttributeExpr(name);
}
function parseLiteralExpr(node) {
    const obj = node[1];
    if (obj === null || typeof obj !== "object") {
        throw new Error("expected an object or array literal");
    }
    return new ObjectLiteralExpr(obj);
}
function parseMatchExpr(node, referenceResolverState) {
    if (node.length < 4) {
        throw new Error("not enough arguments");
    }
    if (!(node.length % 2)) {
        throw new Error("fallback is missing in 'match' expression");
    }
    const value = parseNode(node[1], referenceResolverState);
    const conditions = [];
    for (let i = 2; i < node.length - 1; i += 2) {
        const label = node[i];
        if (!MatchExpr.isValidMatchLabel(label)) {
            throw new Error(`'${JSON.stringify(label)}' is not a valid label for 'match'`);
        }
        const expr = parseNode(node[i + 1], referenceResolverState);
        conditions.push([label, expr]);
    }
    const fallback = parseNode(node[node.length - 1], referenceResolverState);
    return new MatchExpr(value, conditions, fallback);
}
function parseCaseExpr(node, referenceResolverState) {
    if (node.length < 3) {
        throw new Error("not enough arguments");
    }
    if (node.length % 2) {
        throw new Error("fallback is missing in 'case' expression");
    }
    const branches = [];
    for (let i = 1; i < node.length - 1; i += 2) {
        const condition = parseNode(node[i], referenceResolverState);
        const expr = parseNode(node[i + 1], referenceResolverState);
        branches.push([condition, expr]);
    }
    const caseFallback = parseNode(node[node.length - 1], referenceResolverState);
    return new CaseExpr(branches, caseFallback);
}
function isInterpolationMode(object) {
    if (!Array.isArray(object)) {
        return false;
    }
    switch (object[0]) {
        case "discrete":
        case "linear":
        case "cubic":
        case "exponential":
            return true;
        default:
            return false;
    }
}
function parseInterpolateExpr(node, referenceResolverState) {
    const mode = node[1];
    if (!isInterpolationMode(mode)) {
        throw new Error("expected an interpolation type");
    }
    if (mode[0] === "exponential" && typeof mode[1] !== "number") {
        throw new Error("expected the base of the exponential interpolation");
    }
    const input = node[2] !== undefined ? parseNode(node[2], referenceResolverState) : undefined;
    if (!Expr.isExpr(input)) {
        throw new Error(`expected the input of the interpolation`);
    }
    if (node.length === 3 || !(node.length % 2)) {
        throw new Error("invalid number of samples");
    }
    const stops = [];
    for (let i = 3; i < node.length - 1; i += 2) {
        const key = node[i];
        const value = parseNode(node[i + 1], referenceResolverState);
        stops.push([key, value]);
    }
    return new InterpolateExpr(mode, input, stops);
}
function parseStepExpr(node, referenceResolverState) {
    if (node.length < 2) {
        throw new Error("expected the input of the 'step' operator");
    }
    if (node.length < 3 || !(node.length % 2)) {
        throw new Error("not enough arguments");
    }
    const input = parseNode(node[1], referenceResolverState);
    const defaultValue = parseNode(node[2], referenceResolverState);
    const stops = [];
    for (let i = 3; i < node.length; i += 2) {
        const key = node[i];
        const value = parseNode(node[i + 1], referenceResolverState);
        stops.push([key, value]);
    }
    return new StepExpr(input, defaultValue, stops);
}
function makeCallExpr(op, node, referenceResolverState) {
    return new CallExpr(op, node.slice(1).map(childExpr => parseNode(childExpr, referenceResolverState)));
}
function resolveReference(node, referenceResolverState) {
    if (typeof node[1] !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    if (referenceResolverState === undefined) {
        throw new Error(`ref used with no definitions`);
    }
    const name = node[1];
    if (referenceResolverState.lockedNames.has(name)) {
        throw new Error(`circular referene to '${name}'`);
    }
    if (!(name in referenceResolverState.definitions)) {
        throw new Error(`definition '${name}' not found`);
    }
    const cachedEntry = referenceResolverState.cache.get(name);
    if (cachedEntry !== undefined) {
        return cachedEntry;
    }
    let definitionEntry = referenceResolverState.definitions[name];
    let result;
    if (InterpolatedPropertyDefs_1.isInterpolatedPropertyDefinition(definitionEntry.value)) {
        // found a reference to an interpolation using
        // the deprecated object-like syntax.
        return Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(definitionEntry.value));
    }
    else if (isJsonExpr(definitionEntry.value)) {
        definitionEntry = definitionEntry.value;
    }
    else {
        return Expr.fromJSON(definitionEntry.value);
    }
    if (isJsonExpr(definitionEntry)) {
        referenceResolverState.lockedNames.add(name);
        try {
            result = parseNode(definitionEntry, referenceResolverState);
        }
        finally {
            referenceResolverState.lockedNames.delete(name);
        }
    }
    else {
        throw new Error(`unsupported definition ${name}`);
    }
    referenceResolverState.cache.set(name, result);
    return result;
}
//# sourceMappingURL=Expr.js.map