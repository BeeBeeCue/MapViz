"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makeDecodedTechnique = exports.StyleSetEvaluator = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = require("@here/harp-utils");
const Expr_1 = require("./Expr");
const ExprPool_1 = require("./ExprPool");
const InterpolatedPropertyDefs_1 = require("./InterpolatedPropertyDefs");
const TechniqueDescriptors_1 = require("./TechniqueDescriptors");
const Techniques_1 = require("./Techniques");
const logger = harp_utils_1.LoggerManager.instance.create("StyleSetEvaluator");
const DEFAULT_TECHNIQUE_ATTR_SCOPE = TechniqueDescriptors_1.AttrScope.TechniqueGeometry;
/**
 * Get the attribute scope of the given style property.
 *
 * @remarks
 * Certain Style properties change their dynamic scope behavior
 * based on other properties. For example, the `color` property
 * of `extruded-polygon` change behavior based on the usage
 * of `vertexColors`.
 *
 * @param style A valid Style.
 * @param attrName The name of the attribute of the {@link style}.
 */
function getStyleAttributeScope(style, attrName) {
    var _a, _b;
    if (style.technique === "extruded-polygon") {
        if (attrName === "color" && style.vertexColors !== false) {
            return DEFAULT_TECHNIQUE_ATTR_SCOPE;
        }
    }
    return ((_b = (_a = TechniqueDescriptors_1.getTechniqueAttributeDescriptor(style.technique, attrName)) === null || _a === void 0 ? void 0 : _a.scope) !== null && _b !== void 0 ? _b : DEFAULT_TECHNIQUE_ATTR_SCOPE);
}
/**
 * `StyleConditionClassifier` searches for usages of `$layer` in `when` conditions
 * associated with styling rules.
 *
 * @hidden
 */
class StyleConditionClassifier {
    classify(style) {
        if (style._whenExpr) {
            const savedStyle = this.switchStyle(style);
            style._whenExpr = style._whenExpr.accept(this, undefined);
            this._style = savedStyle;
        }
    }
    visitNullLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitBooleanLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitNumberLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitStringLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitObjectLiteralExpr(expr, enclosingExpr) {
        return expr;
    }
    visitVarExpr(expr, enclosingExpr) {
        return expr;
    }
    visitHasAttributeExpr(expr, enclosingExpr) {
        return expr;
    }
    visitMatchExpr(expr, enclosingExpr) {
        return expr;
    }
    visitCaseExpr(expr, enclosingExpr) {
        return expr;
    }
    visitCallExpr(call, enclosingExpr) {
        if (call.op === "all") {
            // processing of an `["all", e1, e2, ... eN]` expression. In this case
            // search for expressions matching comparison of `$layer` and string literals
            // in the sub expressions.
            const children = call.args
                .map(childExpr => childExpr.accept(this, call))
                .filter(childExpr => childExpr !== undefined);
            return new Expr_1.CallExpr(call.op, children);
        }
        else if (enclosingExpr) {
            // `call` is a direct child expression of an `"all"` operator.
            const matched = this.matchVarStringComparison(call);
            if (matched) {
                if (this._style.layer === undefined && matched.name === "$layer") {
                    // found a subexpression `["==", ["get", "$layer"], "some layer name"]`
                    // enclosed in an `["all", e1...eN]` expression. Remove it from
                    // its parent expression and store the value of the expected $layer in
                    // [[StyleInternalParams]].
                    this._style.layer = matched.value;
                    // return `undefined` to remove this sub expression from its parent.
                    return undefined;
                }
                else if (this._style._geometryType === undefined &&
                    matched.name === "$geometryType") {
                    // found a subexpression `["==", ["get", "$geometryType"], "geometry"]`
                    // enclosed in an `["all", e1...eN]` expression. Remove it from
                    // its parent expression and store the value of the expected $geometryType in
                    // [[StyleInternalParams]].
                    this._style._geometryType = matched.value;
                    // return `undefined` to remove this sub expression from its parent.
                    return undefined;
                }
            }
        }
        return call;
    }
    visitStepExpr(expr, enclosingExpr) {
        return expr;
    }
    visitInterpolateExpr(expr, enclosingExpr) {
        return expr;
    }
    /**
     * Tests if the given `call` matches the structure ["==", ["get", name], value].
     * If a match is found returns an object containing the `name` and the `value`;
     *
     * @param call - The expression to match.
     */
    matchVarStringComparison(call) {
        if (call.op === "==") {
            const left = call.args[0];
            const right = call.args[1];
            if (left instanceof Expr_1.VarExpr && right instanceof Expr_1.StringLiteralExpr) {
                return { name: left.name, value: right.value };
            }
            if (right instanceof Expr_1.VarExpr && left instanceof Expr_1.StringLiteralExpr) {
                return { name: right.name, value: left.value };
            }
        }
        return undefined;
    }
    /**
     * Sets the given `style` as current.
     *
     * @returns The previous `style`.
     */
    switchStyle(style) {
        const saved = this._style;
        this._style = style;
        return saved;
    }
}
class OptimizedSubSetKey {
    constructor(layer, geometryType) {
        this.key = "";
        this.set(layer, geometryType);
    }
    set(layer, geometryType, env) {
        let keyUpdateNeeded = false;
        if (layer === undefined) {
            const envLayer = env !== undefined ? env.lookup("$layer") : undefined;
            layer = typeof envLayer === "string" ? envLayer : undefined;
        }
        if (this.layer !== layer) {
            this.layer = layer;
            keyUpdateNeeded = true;
        }
        if (geometryType === undefined) {
            const envGeometryType = env !== undefined ? env.lookup("$geometryType") : undefined;
            geometryType = typeof envGeometryType === "string" ? envGeometryType : undefined;
        }
        if (this.geometryType !== geometryType) {
            this.geometryType = geometryType;
            keyUpdateNeeded = true;
        }
        if (keyUpdateNeeded) {
            this.updateKey();
        }
        return this;
    }
    updateKey() {
        if (this.layer !== undefined) {
            if (this.geometryType !== undefined) {
                this.key = `${this.layer}:${this.geometryType}`;
            }
            else {
                this.key = `${this.layer}:`;
            }
        }
        else {
            if (this.geometryType !== undefined) {
                this.key = `:${this.geometryType}`;
            }
            else {
                this.key = "all";
            }
        }
        this.cachedStyleSet = undefined;
    }
}
/**
 * Combine data from datasource and apply the rules from a specified theme to show it on the map.
 */
class StyleSetEvaluator {
    constructor(m_options) {
        this.m_options = m_options;
        this.m_techniques = [];
        this.m_exprPool = new ExprPool_1.ExprPool();
        this.m_cachedResults = new Map();
        this.m_styleConditionClassifier = new StyleConditionClassifier();
        this.m_subStyleSetCache = new Map();
        this.m_definitionExprCache = new Map();
        this.m_tmpOptimizedSubSetKey = new OptimizedSubSetKey();
        this.m_emptyEnv = new Expr_1.Env();
        this.m_featureDependencies = [];
        this.m_definitions = this.m_options.definitions;
        this.styleSet = resolveReferences(this.m_options.styleSet, this.m_definitions);
        computeDefaultRenderOrder(this.styleSet);
        this.compileStyleSet();
    }
    /**
     * Find all techniques that fit the current objects' environment.
     * *The techniques in the resulting array may not be modified* since they are being reused for
     * identical objects.
     *
     * @param env - The objects environment, i.e. the attributes that are relevant for its
     * representation.
     * @param layer - The optional layer name used to filter techniques.
     * @param geometryType - The optional geometryType used to filter techniques.
     */
    getMatchingTechniques(env, layer, geometryType) {
        if (this.m_previousResult &&
            this.m_previousEnv &&
            this.m_featureDependencies.every(p => { var _a; return ((_a = this.m_previousEnv) === null || _a === void 0 ? void 0 : _a.lookup(p)) === env.lookup(p); })) {
            return this.m_previousResult;
        }
        const result = [];
        this.m_cachedResults.clear();
        const optimizedSubSetKey = this.m_tmpOptimizedSubSetKey;
        optimizedSubSetKey.set(layer, geometryType, env);
        // get the requested $layer and $geometryType, if any.
        this.m_layer = optimizedSubSetKey.layer;
        this.m_geometryType = optimizedSubSetKey.geometryType;
        this.m_zoomLevel = env.lookup("$zoom");
        const searchedStyleSet = this.getOptimizedStyleSet(optimizedSubSetKey);
        for (const currStyle of searchedStyleSet) {
            if (this.processStyle(env, currStyle, result)) {
                break;
            }
        }
        this.m_previousResult = result;
        this.m_previousEnv = env;
        return result;
    }
    /**
     * Check if `styleSet` contains any rule related to `layer`.
     *
     * @param layer - name of layer
     */
    wantsLayer(layer) {
        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, undefined)).length > 0);
    }
    /**
     * Check if `styleSet` contains any rule related to particular `[layer, geometryType]` pair.
     *
     * @param layer - name of layer
     * @param geometryType - type of layer - `point`, `line` or `polygon`
     */
    wantsFeature(layer, geometryType) {
        return (this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(layer, geometryType))
            .length > 0);
    }
    /**
     * Get the expression evaluation cache, for further feature processing.
     *
     * This object is valid until next `getMatchingTechniques` call.
     */
    get expressionEvaluatorCache() {
        return this.m_cachedResults;
    }
    /**
     * Reset array of techniques.
     *
     * Cleans technique array and indices, so it doesn't accumulate accross several decoding runs.
     */
    resetTechniques() {
        for (const techinque of this.m_techniques) {
            techinque._index = undefined;
        }
        this.m_techniques.length = 0;
        this.m_previousResult = undefined;
        this.m_previousEnv = undefined;
    }
    /**
     * Get the (current) array of techniques that have been created during decoding.
     */
    get techniques() {
        return this.m_techniques;
    }
    /**
     * Get the (current) array of techniques that have been created during decoding.
     */
    get decodedTechniques() {
        return this.m_techniques.map(makeDecodedTechnique);
    }
    getOptimizedStyleSet(subSetKey) {
        if (subSetKey.cachedStyleSet !== undefined) {
            return subSetKey.cachedStyleSet;
        }
        let optimizedStyleSet = this.m_subStyleSetCache.get(subSetKey.key);
        if (optimizedStyleSet !== undefined) {
            subSetKey.cachedStyleSet = optimizedStyleSet;
            return optimizedStyleSet;
        }
        optimizedStyleSet = this.createPreFilteredStyleSet(subSetKey);
        this.m_subStyleSetCache.set(subSetKey.key, optimizedStyleSet);
        subSetKey.cachedStyleSet = optimizedStyleSet;
        return optimizedStyleSet;
    }
    createPreFilteredStyleSet(subSetKey) {
        const { layer, geometryType } = subSetKey;
        return this.styleSet.filter(style => {
            if (layer !== undefined && style.layer !== undefined && style.layer !== layer) {
                return false;
            }
            if (geometryType !== undefined &&
                style._geometryType !== undefined &&
                style._geometryType !== geometryType) {
                return false;
            }
            return true;
        });
    }
    /**
     * Compile the `when` conditions found when traversting the styling rules.
     */
    compileStyleSet() {
        this.m_featureDependencies = ["$layer", "$geometryType", "$zoom"];
        this.styleSet.forEach(style => this.compileStyle(style));
        // Create optimized styleSets for each `layer` & `geometryType` tuple.
        this.styleSet.forEach(style => {
            this.getOptimizedStyleSet(this.m_tmpOptimizedSubSetKey.set(style.layer, style._geometryType));
        });
    }
    /**
     * Compile the `when` conditions reachable from the given `style`.
     *
     * @param style - The current style.
     */
    compileStyle(style) {
        this.checkStyleDynamicAttributes(style);
        if (style.when !== undefined) {
            try {
                style._whenExpr = Array.isArray(style.when)
                    ? Expr_1.Expr.fromJSON(style.when, this.m_definitions, this.m_definitionExprCache)
                    : Expr_1.Expr.parse(style.when);
                // search for usages of '$layer' and any other
                // special symbol that can be used to speed up the evaluation
                // of the `when` conditions associated to this `style`.
                this.m_styleConditionClassifier.classify(style);
                if (style._whenExpr !== undefined) {
                    style._whenExpr = style._whenExpr.intern(this.m_exprPool);
                }
                const deps = style._whenExpr.dependencies();
                deps === null || deps === void 0 ? void 0 : deps.properties.forEach(prop => {
                    if (!this.m_featureDependencies.includes(prop)) {
                        this.m_featureDependencies.push(prop);
                    }
                });
                if (Expr_1.isJsonExpr(style.minZoomLevel)) {
                    style._minZoomLevelExpr = Expr_1.Expr.fromJSON(style.minZoomLevel).intern(this.m_exprPool);
                }
                if (Expr_1.isJsonExpr(style.maxZoomLevel)) {
                    style._maxZoomLevelExpr = Expr_1.Expr.fromJSON(style.maxZoomLevel).intern(this.m_exprPool);
                }
            }
            catch (err) {
                logger.log("failed to evaluate expression", JSON.stringify(style.when), "error", String(err));
            }
        }
    }
    /**
     * Process a style (and its sub-styles) hierarchically to look for the technique that fits the
     * current objects' environment. The attributes of the styles are assembled to create a unique
     * technique for every object.
     *
     * @param env - The objects environment, i.e. the attributes that are relevant for its
     *            representation.
     * @param style - Current style (could also be top of stack).
     * @param result - The array of resulting techniques. There may be more than one technique per
     *               object, resulting in multiple graphical objects for representation.
     * @returns `true` if style has been found and processing is finished. `false` if not found, or
     *          more than one technique should be applied.
     */
    processStyle(env, style, result) {
        if (!this.checkZoomLevel(env, style)) {
            return false;
        }
        if (this.m_layer !== undefined &&
            style.layer !== undefined &&
            style.layer !== this.m_layer) {
            return false;
        }
        if (this.m_geometryType !== undefined &&
            style._geometryType !== undefined &&
            style._geometryType !== this.m_geometryType) {
            return false;
        }
        if (style._whenExpr) {
            try {
                if (!style._whenExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults)) {
                    // Stop processing this styling rule. The `when` condition
                    // associated with the current `style` evaluates to false so
                    // no techinque defined by this style should be applied.
                    return false;
                }
            }
            catch (error) {
                logger.error(`failed to evaluate expression '${JSON.stringify(style.when)}': ${error}`);
                return false;
            }
        }
        if (style.technique === undefined) {
            return false;
        }
        // we found a technique!
        if (style.technique !== "none") {
            result.push(this.getTechniqueForStyleMatch(env, style));
        }
        // stop processing if "final" is set
        return style.final === true;
    }
    checkZoomLevel(env, style) {
        if (style.minZoomLevel === undefined && style.maxZoomLevel === undefined) {
            return true;
        }
        const zoomLevel = this.m_zoomLevel;
        if (zoomLevel === undefined) {
            return true;
        }
        if (style.minZoomLevel !== undefined) {
            let minZoomLevel = style.minZoomLevel;
            if (style._minZoomLevelExpr) {
                // the constraint is defined as expression, evaluate it and
                // use its value
                try {
                    minZoomLevel = style._minZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);
                }
                catch (error) {
                    logger.error(`failed to evaluate expression '${JSON.stringify(style._minZoomLevelExpr)}': ${error}`);
                }
            }
            if (typeof minZoomLevel === "number" && zoomLevel < minZoomLevel) {
                return false;
            }
        }
        if (style.maxZoomLevel !== undefined) {
            let maxZoomLevel = style.maxZoomLevel;
            if (style._maxZoomLevelExpr) {
                try {
                    maxZoomLevel = style._maxZoomLevelExpr.evaluate(env, Expr_1.ExprScope.Condition, this.m_cachedResults);
                }
                catch (error) {
                    logger.error(`failed to evaluate expression '${JSON.stringify(style._maxZoomLevelExpr)}': ${error}`);
                }
            }
            if (typeof maxZoomLevel === "number" && zoomLevel > maxZoomLevel) {
                return false;
            }
        }
        return true;
    }
    getTechniqueForStyleMatch(env, style) {
        let technique;
        if (style._dynamicTechniques !== undefined) {
            const dynamicAttributes = this.evaluateTechniqueProperties(style, env);
            const key = this.getDynamicTechniqueKey(style, dynamicAttributes);
            technique = style._dynamicTechniques.get(key);
            if (technique === undefined) {
                technique = this.createTechnique(style, key, dynamicAttributes);
                style._dynamicTechniques.set(key, technique);
            }
        }
        else {
            technique = style._staticTechnique;
            if (technique === undefined) {
                style._staticTechnique = technique = this.createTechnique(style, `${style._styleSetIndex}`, []);
            }
        }
        if (technique._index === undefined) {
            technique._index = this.m_techniques.length;
            this.m_techniques.push(technique);
        }
        return technique;
    }
    getDynamicTechniqueKey(style, dynamicAttributes) {
        const dynamicAttrKey = dynamicAttributes
            .map(([_attrName, attrValue]) => {
            if (attrValue === undefined) {
                return "U";
            }
            else {
                return JSON.stringify(attrValue);
            }
        })
            .join(":");
        return `${style._styleSetIndex}:${dynamicAttrKey}`;
    }
    checkStyleDynamicAttributes(style) {
        var _a;
        if (style._dynamicTechniqueAttributes !== undefined || style.technique === "none") {
            return;
        }
        style._dynamicTechniqueAttributes = [];
        style._dynamicFeatureAttributes = [];
        style._dynamicForwardedAttributes = [];
        style._staticAttributes = [];
        const dynamicFeatureAttributes = style._dynamicFeatureAttributes;
        const dynamicTechniqueAttributes = style._dynamicTechniqueAttributes;
        const dynamicForwardedAttributes = style._dynamicForwardedAttributes;
        const targetStaticAttributes = style._staticAttributes;
        const processAttribute = (attrName, attrValue) => {
            if (attrValue === undefined) {
                return;
            }
            if (Expr_1.isJsonExpr(attrValue)) {
                attrValue = Expr_1.Expr.fromJSON(attrValue, this.m_definitions, this.m_definitionExprCache).intern(this.m_exprPool);
            }
            else if (InterpolatedPropertyDefs_1.isInterpolatedPropertyDefinition(attrValue)) {
                // found a property using an object-like interpolation definition.
                attrValue = Expr_1.Expr.fromJSON(InterpolatedPropertyDefs_1.interpolatedPropertyDefinitionToJsonExpr(attrValue)).intern(this.m_exprPool);
            }
            if (Expr_1.Expr.isExpr(attrValue)) {
                const deps = attrValue.dependencies();
                if (deps.featureState) {
                    if (attrName !== "enabled") {
                        logger.log("feature-state is not supported in this context");
                    }
                    else {
                        style._usesFeatureState = true;
                    }
                }
                if (deps.properties.size === 0 && !attrValue.isDynamic()) {
                    // no data-dependencies detected.
                    attrValue = attrValue.evaluate(this.m_emptyEnv);
                }
            }
            if (Expr_1.Expr.isExpr(attrValue)) {
                const attrScope = getStyleAttributeScope(style, attrName);
                const deps = attrValue.dependencies();
                deps.properties.forEach(prop => {
                    if (!this.m_featureDependencies.includes(prop)) {
                        this.m_featureDependencies.push(prop);
                    }
                });
                switch (attrScope) {
                    case TechniqueDescriptors_1.AttrScope.FeatureGeometry:
                        dynamicFeatureAttributes.push([attrName, attrValue]);
                        break;
                    case TechniqueDescriptors_1.AttrScope.TechniqueGeometry:
                        dynamicTechniqueAttributes.push([attrName, attrValue]);
                        break;
                    case TechniqueDescriptors_1.AttrScope.TechniqueRendering:
                        if (deps.properties.size === 0) {
                            dynamicForwardedAttributes.push([attrName, attrValue]);
                        }
                        else {
                            dynamicTechniqueAttributes.push([attrName, attrValue]);
                        }
                        break;
                }
            }
            else if (attrValue !== undefined && attrValue !== null) {
                targetStaticAttributes.push([attrName, attrValue]);
            }
        };
        const replacement = new Map([
            ["category", "_category"],
            ["secondaryCategory", "_secondaryCategory"]
        ]);
        for (const p in style) {
            if (!style.hasOwnProperty(p)) {
                continue;
            }
            if (p.startsWith("_")) {
                continue;
            }
            if (["when", "technique", "layer", "attr", "description"].includes(p)) {
                continue;
            }
            const pp = (_a = replacement.get(p)) !== null && _a !== void 0 ? _a : p;
            processAttribute(pp, style[p]);
        }
        if (style.attr !== undefined) {
            for (const attrName in style.attr) {
                if (!style.attr.hasOwnProperty(attrName)) {
                    continue;
                }
                processAttribute(attrName, style.attr[attrName]);
            }
        }
        if (dynamicTechniqueAttributes.length > 0) {
            style._dynamicTechniques = new Map();
        }
    }
    evaluateTechniqueProperties(style, env) {
        if (style._dynamicTechniqueAttributes === undefined) {
            return [];
        }
        return style._dynamicTechniqueAttributes.map(([attrName, attrExpr]) => {
            try {
                const evaluatedValue = attrExpr.evaluate(env, Expr_1.ExprScope.Value, this.m_cachedResults);
                return [attrName, evaluatedValue];
            }
            catch (error) {
                logger.error(`failed to evaluate expression '${attrExpr.toJSON()}': ${error}`);
                return [attrName, null];
            }
        });
    }
    createTechnique(style, key, dynamicAttrs) {
        var _a, _b;
        const technique = {};
        technique.name = style.technique;
        if (style._staticAttributes !== undefined) {
            for (const [attrName, attrValue] of style._staticAttributes) {
                if (attrValue !== null) {
                    technique[attrName] = attrValue;
                }
            }
        }
        for (const [attrName, attrValue] of dynamicAttrs) {
            if (attrValue !== null) {
                technique[attrName] = attrValue;
            }
        }
        if (style._dynamicFeatureAttributes !== undefined) {
            for (const [attrName, attrValue] of style._dynamicFeatureAttributes) {
                technique[attrName] = attrValue;
            }
        }
        if (style._dynamicForwardedAttributes !== undefined) {
            for (const [attrName, attrValue] of style._dynamicForwardedAttributes) {
                technique[attrName] = attrValue;
            }
        }
        technique._index = this.m_techniques.length;
        technique._styleSetIndex = style._styleSetIndex;
        if (style.styleSet !== undefined) {
            technique._styleSet = style.styleSet;
        }
        if (style._usesFeatureState !== undefined) {
            technique._usesFeatureState = style._usesFeatureState;
        }
        Techniques_1.setTechniqueRenderOrderOrPriority(technique, (_a = this.m_options.priorities) !== null && _a !== void 0 ? _a : [], (_b = this.m_options.labelPriorities) !== null && _b !== void 0 ? _b : []);
        this.m_techniques.push(technique);
        return technique;
    }
}
exports.StyleSetEvaluator = StyleSetEvaluator;
function computeDefaultRenderOrder(styleSet) {
    let techniqueRenderOrder = 0;
    let styleSetIndex = 0;
    for (const style of styleSet) {
        style._styleSetIndex = styleSetIndex++;
        if (style.technique !== undefined && style.renderOrder === undefined) {
            style.renderOrder = techniqueRenderOrder++;
        }
    }
}
function resolveReferences(styleSet, definitions) {
    return styleSet.map(style => resolveStyleReferences(style, definitions));
}
function resolveStyleReferences(style, definitions) {
    return Object.assign({}, style);
}
/**
 * Create transferable representation of dynamic technique.
 *
 * Converts  non-transferable {@link Expr}instances back to JSON form.
 */
function makeDecodedTechnique(technique) {
    const result = {};
    for (const attrName in technique) {
        if (!technique.hasOwnProperty(attrName)) {
            continue;
        }
        let attrValue = technique[attrName];
        if (typeof attrValue === "object" &&
            (attrValue.isVector2 || attrValue.isVector3 || attrValue.isVector4)) {
            attrValue = Expr_1.LiteralExpr.fromValue(attrValue);
        }
        if (Expr_1.Expr.isExpr(attrValue)) {
            attrValue = attrValue.toJSON();
        }
        result[attrName] = attrValue;
    }
    return result;
}
exports.makeDecodedTechnique = makeDecodedTechnique;
//# sourceMappingURL=StyleSetEvaluator.js.map