"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraAnimationBuilder = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_geoutils_1 = require("@here/harp-geoutils");
const THREE = require("three");
const CameraKeyTrackAnimation_1 = require("./CameraKeyTrackAnimation");
/**
 * A Utility class for the creation of Camera Animations
 * @beta
 */
class CameraAnimationBuilder {
    /**
     * Get the current [[LookAtParams]] from [[MapView]]
     * @beta
     *
     * @param mapView - The MapView
     */
    static getLookAtFromView(mapView) {
        return {
            target: mapView.target,
            heading: mapView.heading,
            tilt: mapView.tilt,
            distance: mapView.targetDistance
        };
    }
    /**
     * Appends a [[ControlPoint]] to [[CameraKeyTrackAnimationOptions]]
     * @beta
     *
     * @param options - The [[CameraKeyTrackAnimationOptions]] that the [[ControlPoint]] should be
     * appended to
     * @param point - The [[ControlPoint]] to append.
     * @param appendTime - The time it should take from the former end of the animation to the
     * appended [[ControlPoint]] in seconds, per default takes the controlpoints timestamp
     */
    static appendControlPoint(options, point, appendTime) {
        appendTime = appendTime !== null && appendTime !== void 0 ? appendTime : 10;
        if (options.controlPoints.length > 0 &&
            (point.timestamp === undefined ||
                point.timestamp <=
                    options.controlPoints[options.controlPoints.length - 1].timestamp)) {
            point.timestamp =
                options.controlPoints[options.controlPoints.length - 1].timestamp + appendTime;
        }
        options.controlPoints.push(point);
    }
    /**
     * Adds a [[ControlPoint]] to the beginning of an [[CameraKeyTrackAnimationOptions]]
     * @beta
     *
     * @param options -
     * @param point -
     * @param prependTime - The time the animation from the inserted key to the next should take,
     *  in seconds, @default 10 seconds
     */
    static prependControlPoint(options, point, prependTime) {
        prependTime = prependTime !== undefined ? prependTime : 10;
        for (const controlPoint of options.controlPoints) {
            controlPoint.timestamp += prependTime;
        }
        point.timestamp = 0;
        options.controlPoints.unshift(point);
    }
    /**
     *
     * Creates Options for a Bow Animation from the start to the target [[ControlPoint]]
     * @beta
     *
     * @param mapView -
     * @param startControlPoint -
     * @param targetControlPoint -
     * @param altitude - The maximal altitude the bow should have, defaults to twice the start to
     * target distance
     * @param duration - The duration of the Animation in seconds, @default 10
     */
    static createBowFlyToOptions(mapView, startControlPoint, targetControlPoint, altitude, duration = 10) {
        const controlPoints = [startControlPoint];
        const startWorldTarget = new THREE.Vector3();
        mapView.projection.projectPoint(startControlPoint.target, startWorldTarget);
        let maxAltitude = altitude !== null && altitude !== void 0 ? altitude : 2 *
            startWorldTarget.distanceTo(mapView.projection.projectPoint(targetControlPoint.target));
        // use a minimum altitude of the sum of distances to
        // actually create a bow for small distance CP
        maxAltitude = Math.max(startControlPoint.distance + targetControlPoint.distance, maxAltitude);
        //calculate two ControlPoints on the maximal altitude in between the start and target points
        const midCoord0 = harp_geoutils_1.GeoCoordinates.lerp(startControlPoint.target, targetControlPoint.target, 0.25);
        const midPoint0 = new CameraKeyTrackAnimation_1.ControlPoint({
            target: midCoord0,
            distance: maxAltitude,
            timestamp: duration / 3,
            tilt: harp_geoutils_1.MathUtils.interpolateAnglesDeg(startControlPoint.tilt, targetControlPoint.tilt, 0.25),
            heading: harp_geoutils_1.MathUtils.interpolateAnglesDeg(startControlPoint.heading, targetControlPoint.heading, 0.25)
        });
        controlPoints.push(midPoint0);
        const midCoord1 = harp_geoutils_1.GeoCoordinates.lerp(startControlPoint.target, targetControlPoint.target, 0.75);
        const midPoint1 = new CameraKeyTrackAnimation_1.ControlPoint({
            target: midCoord1,
            distance: maxAltitude,
            timestamp: (duration / 3) * 2,
            tilt: harp_geoutils_1.MathUtils.interpolateAnglesDeg(startControlPoint.tilt, targetControlPoint.tilt, 0.75),
            heading: harp_geoutils_1.MathUtils.interpolateAnglesDeg(startControlPoint.heading, targetControlPoint.heading, 0.75)
        });
        controlPoints.push(midPoint1);
        targetControlPoint.timestamp = duration;
        controlPoints.push(targetControlPoint);
        return { controlPoints };
    }
    /**
     * Creates [[CameraKeyTrackAnimationOptions]] for an Orbit Animation
     * @beta
     *
     * @param startControlPoint -
     * @param duration -
     */
    static createOrbitOptions(startControlPoint, duration = 10) {
        const amountOfKeys = 4;
        const controlPoints = [startControlPoint];
        const steps = amountOfKeys - 1;
        const headingStep = 360 / steps;
        const timeStep = duration / steps;
        for (let n = 1; n < amountOfKeys; n++) {
            const prev = controlPoints[n - 1];
            controlPoints.push(Object.assign(Object.assign({}, prev), { heading: prev.heading - headingStep, timestamp: prev.timestamp + timeStep }));
        }
        return { controlPoints };
    }
}
exports.CameraAnimationBuilder = CameraAnimationBuilder;
//# sourceMappingURL=CameraAnimationBuilder.js.map