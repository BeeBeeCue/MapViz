"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerServiceManager = void 0;
const harp_datasource_protocol_1 = require("@here/harp-datasource-protocol");
const WorkerService_1 = require("./WorkerService");
/**
 * Manages dynamic worker services in Web Worker context.
 *
 * Handles `CreateService` and `DestroyService` messages sent to Web Worker. Singleton (in scope of
 * one worker runtime!), starts automatically with first [[getInstance]] call.
 */
class WorkerServiceManager extends WorkerService_1.WorkerService {
    constructor(serviceId = harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID) {
        super(serviceId);
        /**
         * Contains all registered service factories indexed by `serviceType`.
         */
        this.m_factories = new Map();
        /**
         * Contains all managed worker services indexed by their `serviceId`.
         */
        this.m_services = new Map();
    }
    /**
     * Gets the default instance of `WorkerServiceManager`. Starts the service when first called.
     */
    static getInstance() {
        if (this.m_service === undefined) {
            this.m_service = new WorkerServiceManager(harp_datasource_protocol_1.WorkerServiceProtocol.WORKER_SERVICE_MANAGER_SERVICE_ID);
        }
        return this.m_service;
    }
    /**
     * Register [[WorkerService]] class to this manager.
     *
     * @param workerServiceDescriptor - service type and factory
     */
    register(workerServiceDescriptor) {
        this.m_factories.set(workerServiceDescriptor.serviceType, workerServiceDescriptor.factory);
    }
    /** @override */
    handleRequest(request) {
        if (request.type === harp_datasource_protocol_1.WorkerServiceProtocol.Requests.CreateService) {
            const existingService = this.m_services.get(request.targetServiceId);
            if (existingService !== undefined) {
                throw Error(`error - service with targetServiceId='${request.targetServiceId}' already running, ignoring CreateService request`);
            }
            const factory = this.m_factories.get(request.targetServiceType);
            if (factory === undefined) {
                throw Error(`unknown targetServiceType requested: '${request.targetServiceType}'`);
            }
            const service = factory(request.targetServiceId);
            this.m_services.set(request.targetServiceId, service);
        }
        if (request.type === harp_datasource_protocol_1.WorkerServiceProtocol.Requests.DestroyService) {
            const service = this.m_services.get(request.targetServiceId);
            if (service === undefined) {
                throw Error(`unknown targetServiceId '${request.targetServiceId}'`);
            }
            service.destroy();
            this.m_services.delete(request.targetServiceId);
        }
        return Promise.resolve({
            response: {}
        });
    }
}
exports.WorkerServiceManager = WorkerServiceManager;
//# sourceMappingURL=WorkerServiceManager.js.map