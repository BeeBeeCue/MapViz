"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TilerService = void 0;
const harp_datasource_protocol_1 = require("@here/harp-datasource-protocol");
const harp_geoutils_1 = require("@here/harp-geoutils");
const GeoJsonTiler_1 = require("./GeoJsonTiler");
const WorkerService_1 = require("./WorkerService");
/**
 * An extension to {@link WorkerService}, the `TilerService`
 * implements an asynchronous (message based)
 * service to tile untiled payloads in web workers.
 *
 * @remarks
 * The `TilerService` itself lives in the web
 * worker, and communicates with messages by means of a `ConcurrentWorkerSet` with the
 * application.
 *
 * The `TilerService` registers tile indices (parent tile to be subdivided) by handling a
 * `RegisterIndexRequest`, and can later retrieve tiled payloads from through the `TileRequest`.
 * The data is sent back in form of a {@link WorkerServiceResponse}.
 */
class TilerService extends WorkerService_1.WorkerService {
    /**
     * Set up the `TilerService`. The name of the service must be unique
     *
     * @param serviceId - Service id. Must be unique.
     */
    constructor(serviceId) {
        super(serviceId);
        this.serviceId = serviceId;
        this.tiler = new GeoJsonTiler_1.GeoJsonTiler();
    }
    /**
     * Start a `TilerService`.
     *
     * @param serviceId - Service id. Must be unique.
     */
    static start(serviceId) {
        return new TilerService(serviceId);
    }
    /**
     * Handle incoming request messages. Identifies message type and processes the request.
     *
     * @param request - {@link WorkerTilerProtocol} request.
     * @returns A promise which resolves to a {@link WorkerServiceResponse}.
     * @override
     */
    handleRequest(request) {
        if (harp_datasource_protocol_1.WorkerTilerProtocol.isRegisterIndexRequest(request)) {
            return this.handleRegisterIndexRequest(request);
        }
        else if (harp_datasource_protocol_1.WorkerTilerProtocol.isUpdateIndexRequest(request)) {
            return this.handleUpdateIndexRequest(request);
        }
        else if (harp_datasource_protocol_1.WorkerTilerProtocol.isTileRequest(request)) {
            return this.handleTileRequest(request);
        }
        else {
            return super.handleRequest(request);
        }
    }
    async handleTileRequest(request) {
        const tileKey = harp_geoutils_1.TileKey.fromMortonCode(request.tileKey);
        const tile = await this.tiler.getTile(request.index, tileKey);
        return { response: tile || {} };
    }
    async handleRegisterIndexRequest(message) {
        const input = typeof message.input === "string" ? new URL(message.input) : message.input;
        await this.tiler.registerIndex(message.id, input);
        return { response: {} };
    }
    async handleUpdateIndexRequest(message) {
        const input = typeof message.input === "string" ? new URL(message.input) : message.input;
        this.tiler.updateIndex(message.id, input);
        return { response: {} };
    }
}
exports.TilerService = TilerService;
//# sourceMappingURL=TilerService.js.map