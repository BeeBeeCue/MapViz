"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnicodeUtils = void 0;
/**
 * Namespace containing useful information when dealing with Unicode's code points.
 */
var UnicodeUtils;
(function (UnicodeUtils) {
    /**
     * Range of Unicode code points considered as white space.
     * https://en.wikipedia.org/wiki/Whitespace_character
     */
    UnicodeUtils.whiteSpaceRanges = [
        [0x0009, 0x0009],
        [0x0020, 0x0020],
        [0x1680, 0x1680],
        [0x2000, 0x2006],
        [0x2008, 0x200a],
        [0x205f, 0x3000],
        [0x180e, 0x180e],
        [0x200b, 0x200d]
    ];
    /**
     * Checks if a character should be considered as a white space.
     *
     * @param codePoint - Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isWhiteSpace(codePoint) {
        for (const range of UnicodeUtils.whiteSpaceRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return true;
            }
        }
        return false;
    }
    UnicodeUtils.isWhiteSpace = isWhiteSpace;
    /**
     * Range of Unicode code points considered as `NewLine`.
     * https://en.wikipedia.org/wiki/Newline#Unicode
     */
    UnicodeUtils.newLineRanges = [
        [0x000a, 0x000d],
        [0x0085, 0x0085],
        [0x2028, 0x2029]
    ];
    /**
     * Checks if a character should be considered as a new line.
     *
     * @param codePoint - Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isNewLine(codePoint) {
        for (const range of UnicodeUtils.newLineRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return true;
            }
        }
        return false;
    }
    UnicodeUtils.isNewLine = isNewLine;
    /**
     * Range of Unicode code points considered as non-printable.
     * https://en.wikipedia.org/wiki/Unicode_control_characters
     */
    UnicodeUtils.nonPrintableRanges = [
        [0x0000, 0x001f],
        [0x007f, 0x009f]
    ];
    /**
     * Checks if a character's can be printed (rendered).
     *
     * @param codePoint - Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isPrintable(codePoint) {
        for (const range of UnicodeUtils.nonPrintableRanges) {
            if (codePoint >= range[0] && codePoint <= range[1]) {
                return false;
            }
        }
        return true;
    }
    UnicodeUtils.isPrintable = isPrintable;
    /**
     * Unicode code point direction.
     */
    let Direction;
    (function (Direction) {
        Direction[Direction["Neutral"] = 0] = "Neutral";
        Direction[Direction["Weak"] = 0.5] = "Weak";
        Direction[Direction["LTR"] = 1] = "LTR";
        Direction[Direction["RTL"] = -1] = "RTL";
    })(Direction = UnicodeUtils.Direction || (UnicodeUtils.Direction = {}));
    // TODO: Review/Remove/Add any additional needed blocks (HARP-3330).
    /**
     * Unicode Blocks which have inherent RTL direction.
     * These blocks correspond to the scripts described here:
     * https://en.wikipedia.org/wiki/Right-to-left#List_of_RTL_scripts
     */
    UnicodeUtils.rtlBlocks = [
        "Hebrew",
        "Alphabetic Presentation Forms",
        "Arabic",
        "Arabic Supplement",
        "Arabic Extended-A",
        "Arabic Presentation Forms-A",
        "Arabic Presentation Forms-B",
        "Arabic Mathematical Alphabetic Symbols",
        "Indic Siyaq Numbers",
        "Rumi Numeral Symbols",
        "Syriac",
        "Syriac Supplement",
        "Samaritan",
        "Mandaic",
        "Thaana",
        "Mende Kikakui",
        "NKo",
        "Adlam",
        "Hanifi Rohingya"
    ];
    /**
     * ASCII punctuation is considered to have neutral direction:
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     */
    UnicodeUtils.neutralBidirectionalRanges = [
        [0x0020, 0x002f],
        [0x003a, 0x0040],
        [0x005b, 0x0060],
        [0x007b, 0x007e]
    ];
    /**
     * Latin and arabic numerals are considered to have weak directionality:
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     * https://en.wikipedia.org/wiki/Arabic_(Unicode_block)#Block
     */
    UnicodeUtils.weakBidirectionalRanges = [
        [0x0030, 0x0039],
        [0x0660, 0x0669],
        [0x06f0, 0x06f9]
    ];
    /**
     * Returns the Unicode's character direction.
     *
     * @param codePoint - Character's Unicode code point.
     * @param block - Character's Unicode block.
     *
     * @returns Character's direction.
     */
    function getDirection(codePoint, block) {
        // Test for neutral and weak code points first (they're inside LTR/RTL ranges).
        for (const weakRange of UnicodeUtils.weakBidirectionalRanges) {
            if (codePoint >= weakRange[0] && codePoint <= weakRange[1]) {
                return Direction.Weak;
            }
        }
        for (const neutralRange of UnicodeUtils.neutralBidirectionalRanges) {
            if (codePoint >= neutralRange[0] && codePoint <= neutralRange[1]) {
                return Direction.Neutral;
            }
        }
        // Check for RTL/LTR.
        const rtl = UnicodeUtils.rtlBlocks.find(element => {
            return element === block;
        });
        if (rtl !== undefined) {
            return Direction.RTL;
        }
        else {
            return Direction.LTR;
        }
    }
    UnicodeUtils.getDirection = getDirection;
    /**
     * Some punctuation characters (like: (, ), <, >, [,], {, }) need to be mirrored when rendering
     * a RTL string to preserve their intrinsic meaning.
     * https://en.wikipedia.org/wiki/Basic_Latin_(Unicode_block)#Table_of_characters
     */
    UnicodeUtils.rtlMirroredCodePoints = [
        0x0028,
        0x0029,
        0x003c,
        0x003e,
        0x005b,
        0x005d,
        0x007b,
        0x007d
    ];
    /**
     * Checks if a character should be mirrored on an RTL run.
     *
     * @param codePoint - Character's Unicode code point.
     *
     * @returns Result of the test.
     */
    function isRtlMirrored(codePoint) {
        return (UnicodeUtils.rtlMirroredCodePoints.find(element => {
            return element === codePoint;
        }) !== undefined);
    }
    UnicodeUtils.isRtlMirrored = isRtlMirrored;
})(UnicodeUtils = exports.UnicodeUtils || (exports.UnicodeUtils = {}));
//# sourceMappingURL=UnicodeUtils.js.map