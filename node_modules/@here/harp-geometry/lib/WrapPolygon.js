"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.wrapPolygon = void 0;
const harp_geoutils_1 = require("@here/harp-geoutils");
const harp_utils_1 = require("@here/harp-utils");
const three_1 = require("three");
const ClipPolygon_1 = require("./ClipPolygon");
class ClipEdge extends ClipPolygon_1.ClippingEdge {
    constructor(p0, p1, isInside) {
        super();
        this.isInside = isInside;
        this.p0 = new three_1.Vector2().fromArray(p0);
        this.p1 = new three_1.Vector2().fromArray(p1);
    }
    inside(point, extent) {
        return this.isInside(point);
    }
    /**
     * Computes the intersection of a line and this clipping edge.
     *
     * @remarks
     * {@link https://en.wikipedia.org/wiki/Line%E2%80%93line_intersection
     *    | line-line intersection}.
     */
    computeIntersection(a, b, extent) {
        const result = new three_1.Vector2();
        harp_utils_1.Math2D.intersectLines(a.x, a.y, b.x, b.y, this.p0.x, this.p0.y, this.p1.x, this.p1.y, result);
        return result;
    }
}
const ec = harp_geoutils_1.EarthConstants.EQUATORIAL_CIRCUMFERENCE;
const border = ec * 0.05;
const WRAP_MIDDLE_CLIP_EDGES = [
    new ClipEdge([0 - border, ec], [0 - border, 0], p => p.x > 0 - border),
    new ClipEdge([ec + border, 0], [ec + border, ec], p => p.x < ec + border)
];
const WRAP_LEFT_CLIP_EDGES = [
    new ClipEdge([-ec - border, ec], [-ec - border, 0], p => p.x > -ec - border),
    new ClipEdge([0 + border, 0], [0 + border, ec], p => p.x < 0 + border)
];
const WRAP_RIGHT_CLIP_EDGES = [
    new ClipEdge([ec - border, ec], [ec - border, 0], p => p.x > ec - border),
    new ClipEdge([ec * 2 + border, 0], [ec * 2 + border, ec], p => p.x < ec * 2 + border)
];
function wrapPolygonHelper(polygon, edges, offset) {
    for (const clip of edges) {
        polygon = clip.clipPolygon(polygon, 0);
    }
    const worldP = new three_1.Vector3();
    const coordinates = polygon.map(({ x, y }) => {
        worldP.set(x, y, 0);
        const geoPoint = harp_geoutils_1.webMercatorProjection.unprojectPoint(worldP);
        geoPoint.longitude += offset;
        return geoPoint;
    });
    return coordinates.length > 0 ? coordinates : undefined;
}
/**
 * Wrap the given polygon.
 *
 * @remarks
 * This function splits this input polygon in three parts.
 *
 * The `left` member of the result contains the part of the polygon with longitude less than `-180`.
 *
 * The `middle` member contains the part of the polygon with longitude in the range `[-180, 180]`.
 *
 * The `right` member contains the part of the polygon with longitude greater than `180`.
 *
 * @param coordinates The coordinates of the polygon to wrap.
 */
function wrapPolygon(coordinates) {
    const worldP = new three_1.Vector3();
    const projectedPolygon = coordinates.map(g => {
        const { x, y } = harp_geoutils_1.webMercatorProjection.projectPoint(g, worldP);
        return new three_1.Vector2(x, y);
    });
    return {
        left: wrapPolygonHelper(projectedPolygon, WRAP_LEFT_CLIP_EDGES, 360),
        middle: wrapPolygonHelper(projectedPolygon, WRAP_MIDDLE_CLIP_EDGES, 0),
        right: wrapPolygonHelper(projectedPolygon, WRAP_RIGHT_CLIP_EDGES, -360)
    };
}
exports.wrapPolygon = wrapPolygon;
//# sourceMappingURL=WrapPolygon.js.map