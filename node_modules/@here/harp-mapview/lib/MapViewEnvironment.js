"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapViewEnvironment = exports.DEFAULT_CLEAR_COLOR = void 0;
const harp_geoutils_1 = require("@here/harp-geoutils");
const harp_utils_1 = require("@here/harp-utils");
const THREE = require("three");
const BackgroundDataSource_1 = require("./BackgroundDataSource");
const MapViewFog_1 = require("./MapViewFog");
const SkyBackground_1 = require("./SkyBackground");
const ThemeHelpers_1 = require("./ThemeHelpers");
const logger = harp_utils_1.LoggerManager.instance.create("MapViewEnvironment");
//  the default breaks the ibct tests, seems it had not been used in all cases before
exports.DEFAULT_CLEAR_COLOR = 0xffffff; //0xefe9e1;
const cache = {
    vector3: [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()],
    frustumPoints: [
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3(),
        new THREE.Vector3()
    ]
};
/**
 * Class handling the Scene Environment, like fog, sky, background datasource, clearColor etc
 *  for MapView
 */
class MapViewEnvironment {
    constructor(m_mapView, options) {
        this.m_mapView = m_mapView;
        this.m_fog = new MapViewFog_1.MapViewFog(this.m_mapView.scene);
        if (options.addBackgroundDatasource !== false) {
            this.m_backgroundDataSource = new BackgroundDataSource_1.BackgroundDataSource();
            this.m_mapView.addDataSource(this.m_backgroundDataSource);
        }
        if (options.backgroundTilingScheme !== undefined &&
            this.m_backgroundDataSource !== undefined) {
            this.m_backgroundDataSource.setTilingScheme(options.backgroundTilingScheme);
        }
        this.updateClearColor();
    }
    get lights() {
        var _a;
        return (_a = this.m_createdLights) !== null && _a !== void 0 ? _a : [];
    }
    get fog() {
        return this.m_fog;
    }
    updateBackgroundDataSource() {
        if (this.m_backgroundDataSource) {
            this.m_backgroundDataSource.updateStorageLevelOffset();
        }
    }
    setBackgroundTheme(theme) {
        if (theme !== undefined && this.m_backgroundDataSource !== undefined) {
            this.m_backgroundDataSource.setTheme(theme);
        }
    }
    update() {
        this.m_fog.update(this.m_mapView, this.m_mapView.viewRanges.maximum);
        if (this.m_skyBackground !== undefined &&
            this.m_mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            this.m_skyBackground.updateCamera(this.m_mapView.camera);
        }
        this.updateLights();
    }
    updateClearColor(theme) {
        if (theme !== undefined && theme.clearColor !== undefined) {
            this.m_mapView.renderer.setClearColor(new THREE.Color(theme.clearColor), theme.clearAlpha);
        }
        else {
            this.m_mapView.renderer.setClearColor(exports.DEFAULT_CLEAR_COLOR, theme === null || theme === void 0 ? void 0 : theme.clearAlpha);
        }
    }
    updateSkyBackground(theme) {
        if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && theme.sky !== undefined) {
            // there is a sky in the view and there is a sky option in the theme. Update the colors
            this.updateSkyBackgroundColors(theme.sky, theme.clearColor);
        }
        else if (this.m_skyBackground === undefined && theme.sky !== undefined) {
            // there is no sky in the view but there is a sky option in the theme
            this.addNewSkyBackground(theme.sky, theme.clearColor);
            return;
        }
        else if (this.m_skyBackground instanceof SkyBackground_1.SkyBackground && theme.sky === undefined) {
            // there is a sky in the view, but not in the theme
            this.removeSkyBackGround();
        }
    }
    updateLighting(theme) {
        var _a;
        if (this.m_createdLights) {
            this.m_createdLights.forEach((light) => {
                this.m_mapView.scene.remove(light);
            });
        }
        (_a = this.m_overlayCreatedLights) === null || _a === void 0 ? void 0 : _a.forEach(light => {
            this.m_mapView.overlayScene.remove(light);
            if (light instanceof THREE.DirectionalLight) {
                this.m_mapView.overlayScene.remove(light.target);
            }
        });
        if (theme.lights !== undefined) {
            this.m_createdLights = [];
            this.m_overlayCreatedLights = [];
            theme.lights.forEach((lightDescription) => {
                const light = ThemeHelpers_1.createLight(lightDescription);
                if (!light) {
                    logger.warn(`MapView: failed to create light ${lightDescription.name} of type ${lightDescription.type}`);
                    return;
                }
                this.m_mapView.scene.add(light);
                if (light.isDirectionalLight) {
                    const directionalLight = light;
                    // This is needed so that the target is updated automatically, see:
                    // https://threejs.org/docs/#api/en/lights/DirectionalLight.target
                    this.m_mapView.scene.add(directionalLight.target);
                }
                this.m_createdLights.push(light);
                const clonedLight = light.clone();
                this.m_mapView.overlayScene.add(clonedLight);
                if (clonedLight instanceof THREE.DirectionalLight) {
                    this.m_mapView.overlayScene.add(clonedLight.target.clone());
                }
            });
        }
    }
    /**
     * Update the directional light camera. Note, this requires the cameras to first be updated.
     */
    updateLights() {
        // TODO: HARP-9479 Globe doesn't support shadows.
        if (!this.m_mapView.shadowsEnabled ||
            this.m_mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical ||
            this.m_createdLights === undefined ||
            this.m_createdLights.length === 0) {
            return;
        }
        const points = [
            // near plane points
            { x: -1, y: -1, z: -1 },
            { x: 1, y: -1, z: -1 },
            { x: -1, y: 1, z: -1 },
            { x: 1, y: 1, z: -1 },
            // far planes points
            { x: -1, y: -1, z: 1 },
            { x: 1, y: -1, z: 1 },
            { x: -1, y: 1, z: 1 },
            { x: 1, y: 1, z: 1 }
        ];
        const transformedPoints = points.map((p, i) => this.m_mapView.ndcToView(p, cache.frustumPoints[i]));
        this.m_createdLights.forEach(element => {
            const directionalLight = element;
            if (directionalLight.isDirectionalLight === true) {
                const lightDirection = cache.vector3[0];
                lightDirection.copy(directionalLight.target.position);
                lightDirection.sub(directionalLight.position);
                lightDirection.normalize();
                const normal = cache.vector3[1];
                if (this.m_mapView.projection.type === harp_geoutils_1.ProjectionType.Planar) {
                    // -Z points to the camera, we can't use Projection.surfaceNormal, because
                    // webmercator and mercator give different results.
                    normal.set(0, 0, -1);
                }
                else {
                    // Enable shadows for globe...
                    //this.projection.surfaceNormal(target, normal);
                }
                // The camera of the shadow has the same height as the map camera, and the target is
                // also the same. The position is then calculated based on the light direction and
                // the height
                // using basic trigonometry.
                const tilt = this.m_mapView.tilt;
                const cameraHeight = this.m_mapView.targetDistance * Math.cos(THREE.MathUtils.degToRad(tilt));
                const lightPosHyp = cameraHeight / normal.dot(lightDirection);
                directionalLight.target.position
                    .copy(this.m_mapView.worldTarget)
                    .sub(this.m_mapView.camera.position);
                directionalLight.position.copy(this.m_mapView.worldTarget);
                directionalLight.position.addScaledVector(lightDirection, -lightPosHyp);
                directionalLight.position.sub(this.m_mapView.camera.position);
                directionalLight.updateMatrixWorld();
                directionalLight.shadow.updateMatrices(directionalLight);
                const camera = directionalLight.shadow.camera;
                const pointsInLightSpace = transformedPoints.map(p => this.viewToLightSpace(p.clone(), camera));
                const box = new THREE.Box3();
                pointsInLightSpace.forEach(point => {
                    box.expandByPoint(point);
                });
                camera.left = box.min.x;
                camera.right = box.max.x;
                camera.top = box.max.y;
                camera.bottom = box.min.y;
                // Moving back to the light the near plane in order to catch high buildings, that
                // are not visible by the camera, but existing on the scene.
                camera.near = -box.max.z * 0.95;
                camera.far = -box.min.z;
                camera.updateProjectionMatrix();
            }
        });
    }
    addNewSkyBackground(sky, clearColor) {
        if (sky.type === "gradient" && sky.groundColor === undefined) {
            sky.groundColor = harp_utils_1.getOptionValue(clearColor, "#000000");
        }
        this.m_skyBackground = new SkyBackground_1.SkyBackground(sky, this.m_mapView.projection.type, this.m_mapView.camera);
        this.m_mapView.scene.background = this.m_skyBackground.texture;
    }
    removeSkyBackGround() {
        this.m_mapView.scene.background = null;
        if (this.m_skyBackground !== undefined) {
            this.m_skyBackground.dispose();
            this.m_skyBackground = undefined;
        }
    }
    updateSkyBackgroundColors(sky, clearColor) {
        var _a;
        if (sky.type === "gradient" && sky.groundColor === undefined) {
            sky.groundColor = harp_utils_1.getOptionValue(clearColor, "#000000");
        }
        if (this.m_skyBackground !== undefined) {
            this.m_skyBackground.updateTexture(sky, this.m_mapView.projection.type);
            this.m_mapView.scene.background = (_a = this.m_skyBackground) === null || _a === void 0 ? void 0 : _a.texture;
        }
    }
    /**
     * Transfer from view space to camera space.
     * @param viewPos - position in view space, result is stored here.
     */
    viewToLightSpace(viewPos, camera) {
        return viewPos.applyMatrix4(camera.matrixWorldInverse);
    }
}
exports.MapViewEnvironment = MapViewEnvironment;
//# sourceMappingURL=MapViewEnvironment.js.map