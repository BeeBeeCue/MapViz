"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PickListener = void 0;
const harp_utils_1 = require("@here/harp-utils");
// Default sorting by distance first and then by reversed render order.
function defaultSort(lhs, rhs) {
    const distanceDiff = lhs.distance - rhs.distance;
    const haveRenderOrder = lhs.renderOrder !== undefined && rhs.renderOrder !== undefined;
    if (distanceDiff !== 0 || !haveRenderOrder) {
        return distanceDiff;
    }
    return rhs.renderOrder - lhs.renderOrder;
}
/**
 * Collects results from a picking (intersection) test.
 *
 * @internal
 */
class PickListener {
    /**
     * Constructs a new `PickListener`.
     *
     * @param m_parameters - Optional parameters to customize picking behaviour.
     */
    constructor(m_parameters) {
        this.m_parameters = m_parameters;
        this.m_results = [];
        this.m_sorted = true;
        this.m_finished = true;
    }
    /**
     * Adds a pick result.
     *
     * @param result - The result to be added.
     */
    addResult(result) {
        // Add the result only if it's a different feature from the ones already collected.
        const foundFeatureIdx = this.m_results.findIndex(otherResult => {
            var _a, _b, _c, _d;
            const sameType = otherResult.type === result.type;
            const dataSource = (_b = (_a = result.intersection) === null || _a === void 0 ? void 0 : _a.object.userData) === null || _b === void 0 ? void 0 : _b.dataSource;
            const sameDataSource = dataSource && ((_d = (_c = otherResult.intersection) === null || _c === void 0 ? void 0 : _c.object.userData) === null || _d === void 0 ? void 0 : _d.dataSource) === dataSource;
            const sameId = result.featureId !== undefined && otherResult.featureId === result.featureId;
            const noId = result.featureId === undefined && otherResult.featureId === undefined;
            const sameUserData = result.userData && otherResult.userData === result.userData;
            return sameType && sameDataSource && (sameId || (noId && sameUserData));
        });
        if (foundFeatureIdx < 0) {
            this.m_sorted = false;
            this.m_finished = false;
            this.m_results.push(result);
            return;
        }
        // Replace the result for the same feature if it's sorted after the new result.
        const oldResult = this.m_results[foundFeatureIdx];
        if (defaultSort(result, oldResult) < 0) {
            this.m_results[foundFeatureIdx] = result;
            this.m_sorted = false;
            this.m_finished = false;
        }
    }
    /**
     * Indicates whether the listener is satisfied with the results already provided.
     * @returns `True` if the listener doesn't expect more results, `False` otherwise.
     */
    get done() {
        return this.maxResults ? this.m_results.length >= this.maxResults : false;
    }
    /**
     * Orders the collected results by distance first, then by reversed render order
     * (topmost/highest render order first), and limits the number of results to the maximum
     * accepted number, see {@link IntersectParams.maxResultCount}.
     */
    finish() {
        // Keep only the closest max results.
        this.sortResults();
        if (this.maxResults && this.m_results.length > this.maxResults) {
            this.m_results.length = this.maxResults;
        }
        this.m_finished = true;
    }
    /**
     * Returns the collected results. {@link PickListener.finish} should be called first to ensure
     * the proper sorting and result count.
     * @returns The pick results.
     */
    get results() {
        harp_utils_1.assert(this.m_finished, "finish() was not called before getting the results");
        return this.m_results;
    }
    /**
     * Returns the closest result collected so far, following the order documented in
     * {@link PickListener.finish}
     * @returns The closest pick result, or `undefined` if no result was collected.
     */
    get closestResult() {
        this.sortResults();
        return this.m_results.length > 0 ? this.m_results[0] : undefined;
    }
    /**
     * Returns the furtherst result collected so far, following the order documented in
     * {@link PickListener.results}
     * @returns The furthest pick result, or `undefined` if no result was collected.
     */
    get furthestResult() {
        this.sortResults();
        return this.m_results.length > 0 ? this.m_results[this.m_results.length - 1] : undefined;
    }
    get maxResults() {
        var _a, _b;
        const maxCount = (_b = (_a = this.m_parameters) === null || _a === void 0 ? void 0 : _a.maxResultCount) !== null && _b !== void 0 ? _b : 0;
        return maxCount > 0 ? maxCount : undefined;
    }
    sortResults() {
        if (!this.m_sorted) {
            this.m_results.sort(defaultSort);
            this.m_sorted = true;
        }
    }
}
exports.PickListener = PickListener;
//# sourceMappingURL=PickListener.js.map