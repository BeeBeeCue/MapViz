import { MapView } from "../MapView";
import { ImageItem } from "./Image";
/**
 * `ImageCache` is a singleton, so it can be used with multiple MapViews on a single page.
 *
 * @remarks
 * This allows to have an image loaded only once for multiple views.
 * THREE is doing something similar,
 * but does not allow to share images that have been loaded from a canvas (which we may need to do
 * if we use SVG images for textures).
 *
 * One application that makes our own cache necessary is the generation of our own textures from
 * data that is not an URL.
 *
 * The `ImageCache` can be improved by adding satistics for memory footprint as well.
 */
export declare class ImageCache {
    /**
     * Returns the singleton `instance` of the `ImageCache`.
     */
    static get instance(): ImageCache;
    /**
     * Dispose the singleton object.
     *
     * @remarks
     * Not normally implemented for singletons, but good for debugging.
     */
    static dispose(): void;
    private static m_instance;
    private m_images;
    /**
     * Add an image definition to the global cache. Useful when the image data is already loaded.
     *
     * @param mapView - Specifiy which {@link MapView} requests the image.
     * @param url - URL of image.
     * @param imageData - Optional {@link ImageData}containing the image content.
     * @param htmlElement - Optional containing a HtmlCanvasElement or a HtmlImageElement as conten.
     */
    registerImage(mapView: MapView, url: string, imageData?: ImageData | ImageBitmap, htmlElement?: HTMLImageElement | HTMLCanvasElement): ImageItem;
    /**
     * Add an image definition, and optionally start loading the content.
     *
     * @param mapView - {@link MapView} requesting the image.
     * @param url - URL of image.
     * @param startLoading - Optional flag. If `true` the image will be loaded in the background.
     * @param htmlElement - Optional containing a HtmlCanvasElement or a HtmlImageElement as content,
     * if set, `startLoading = true` will start the rendering process in the background.
     */
    addImage(mapView: MapView, url: string, startLoading?: boolean, htmlElement?: HTMLImageElement | HTMLCanvasElement): ImageItem | Promise<ImageItem | undefined> | undefined;
    /**
     * Remove an image from the cache..
     *
     * @param url - URL of the image.
     * @returns `true` if image has been removed.
     */
    removeImage(url: string): boolean;
    /**
     * Remove an image from the cache.
     *
     * @param imageItem - Item identifying the image.
     * @returns `true` if image has been removed.
     */
    removeImageItem(imageItem: ImageItem): boolean;
    /**
     * Remove images from the cache using a filter function.
     *
     * @param itemFilter - Filter to identify images to remove. Should return `true` if item
     * should be removed.
     * @returns Number of images removed.
     */
    removeImageItems(itemFilter: (item: ImageItem) => boolean): number;
    /**
     * Find {@link ImageItem} for the specified URL.
     *
     * @param url - URL of image.
     * @returns `ImageItem` for the URL if the URL is registered, `undefined` otherwise.
     */
    findImage(url: string): ImageItem | undefined;
    /**
     * Clear all {@link ImageItem}s belonging to a {@link MapView}.
     *
     * @remarks
     * May remove cached items if no
     * {@link MapView} are registered anymore.
     *
     * @param mapView - MapView to remove all {@link ImageItem}s from.
     * @returns Number of images removed.
     */
    clear(mapView: MapView): number;
    /**
     * Clear all {@link ImageItem}s from all {@link MapView}s.
     */
    clearAll(): void;
    /**
     * Returns the number of all cached {@link ImageItem}s.
     */
    get size(): number;
    /**
     * Load an {@link ImageItem}.
     *
     * @remarks
     * If the loading process is already running, it returns the current promise.
     *
     * @param imageItem - `ImageItem` containing the URL to load image from.
     * @returns An {@link ImageItem} if the image has already been loaded, a promise otherwise.
     */
    loadImage(imageItem: ImageItem): ImageItem | Promise<ImageItem | undefined>;
    /**
     * Apply a function to every `ImageItem` in the cache.
     *
     * @param func - Function to apply to every `ImageItem`.
     */
    apply(func: (imageItem: ImageItem) => void): void;
    private createOnImageLoaded;
    /**
     * Find the cached {@link ImageItem} by URL.
     *
     * @param url - URL of image.
     */
    private findImageCacheItem;
    /**
     * Render the `ImageItem` by using `createImageBitmap()` or by rendering the image into a
     * `HTMLCanvasElement`.
     *
     * @param imageItem - {@link ImageItem} to assign image data to.
     * @param image - `HTMLImageElement`
     */
    private renderImage;
    /**
     * Cancel loading an image.
     *
     * @param imageItem - Item to cancel loading.
     */
    private cancelLoading;
}
//# sourceMappingURL=ImageCache.d.ts.map