"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapViewImageCache = void 0;
const ImageCache_1 = require("./ImageCache");
/**
 * Cache images wrapped into {@link ImageItem}s for a {@link MapView}.
 *
 * @remarks
 * An image may have multiple names in a theme, the `MapViewImageCache` maps different names to the
 * same image URL, and allows to share the image by URL to different MapViews.
 * Within a MapView instance, the (optional) name is unique, so registering multiple images with the
 * same name is invalid.
 *
 * The `MapViewImageCache` uses a global {@link ImageCache} to actually store (and generate) the
 * image data.
 */
class MapViewImageCache {
    /**
     * The constructor for `MapViewImageCache`.
     *
     * @param mapView - a {@link MapView} instance.
     */
    constructor(mapView) {
        this.mapView = mapView;
        this.m_name2Url = new Map();
        this.m_url2Name = new Map();
    }
    /**
     * Register an existing image by name.
     *
     * @param name - Name of the image from {@link @here/harp-datasource-protocol#Theme}.
     * @param url - URL of image.
     * @param image - Optional {@link ImageData} of image.
     * @param htmlElement - Optional raw data in case {@link HTMLImageElement} or {@link HTMLCanvasElement} reference is available.
     *                In that case url is used as a unique identifier to avoid image duplicates and the specified
     *                raw data is used for the rendering.
     */
    registerImage(name, url, image, htmlElement) {
        if (name !== undefined) {
            if (this.hasName(name)) {
                throw new Error("duplicate name in cache");
            }
            const oldNames = this.m_url2Name.get(url);
            if (oldNames !== undefined) {
                if (!oldNames.includes(name)) {
                    oldNames.push(name);
                }
            }
            else {
                this.m_url2Name.set(url, [name]);
            }
            this.m_name2Url.set(name, url);
        }
        const imageItem = ImageCache_1.ImageCache.instance.findImage(url);
        if (imageItem === undefined) {
            return ImageCache_1.ImageCache.instance.registerImage(this.mapView, url, image, htmlElement);
        }
        return imageItem;
    }
    /**
     * Add an image and optionally start loading it. Once done, the [[ImageData]] or [[ImageBitmap]]
     * will be stored in the {@link ImageItem}.
     *
     * Names are unique within a {@link MapView}. URLs are not unique, multiple images with
     * different names can have the same URL. Still, URLs are are loaded only once.
     *
     * @param name - Name of image from {@link @here/harp-datasource-protocol#Theme}.
     * @param url URL of image.
     * @param htmlElement Optional raw data in case HTMLImageElement or HTMLCanvasElement reference is available.
     *                In that case url is used as a unique identifier to avoid image duplicates and the specified
     *                raw data is used for the rendering.
     * @param startLoading Optional. Pass `true` to start loading the image in the background or
     *  to start rendering the htmlElement if available.
     */
    addImage(name, url, startLoading = true, htmlElement) {
        const imageItem = this.registerImage(name, url, undefined, htmlElement);
        if (startLoading === true) {
            return ImageCache_1.ImageCache.instance.loadImage(imageItem);
        }
        return imageItem;
    }
    /**
     * Remove the image with this name from the cache.
     *
     * @param name - Name of the image.
     * @returns `true` if item has been removed.
     */
    removeImage(name) {
        return this.removeImageInternal(name);
    }
    /**
     * Remove images using the URL from the cache.
     *
     * @param url - URL of the image.
     * @returns `true` if image has been removed. If multiple images are referring to the same
     * image URL, they are all removed.
     */
    removeImageByUrl(url) {
        const names = this.m_url2Name.get(url);
        if (names !== undefined) {
            for (const name of [...names]) {
                this.removeImageInternal(name);
            }
            return true;
        }
        return false;
    }
    /**
     * Remove images from the cache.
     *
     * @param itemFilter - Filter to identify images to remove. Should return `true` if item
     * should be removed.
     * @returns Number of images removed.
     */
    removeImages(itemFilter) {
        let numImagesRemoved = 0;
        for (const [name, url] of [...this.m_name2Url]) {
            if (itemFilter(name, url)) {
                if (this.removeImage(name)) {
                    numImagesRemoved++;
                }
            }
        }
        return numImagesRemoved;
    }
    /**
     * Find {@link ImageItem} by its name.
     *
     * @param name - Name of image.
     */
    findImageByName(name) {
        const url = this.m_name2Url.get(name);
        if (url === undefined) {
            return undefined;
        }
        return ImageCache_1.ImageCache.instance.findImage(url);
    }
    /**
     * Find {@link ImageItem} by URL.
     *
     * @param url - Url of image.
     */
    findImageByUrl(url) {
        return ImageCache_1.ImageCache.instance.findImage(url);
    }
    /**
     * Load an {@link ImageItem}. Returns a promise or a loaded {@link ImageItem}.
     *
     * @param imageItem - ImageItem to load.
     */
    loadImage(imageItem) {
        return ImageCache_1.ImageCache.instance.loadImage(imageItem);
    }
    /**
     * Remove all {@link ImageItem}s from the cache.
     *
     * @remarks
     * Also removes all {@link ImageItem}s that belong to this
     * {@link MapView} from the global {@link ImageCache}.
     * @returns Number of images removed.
     */
    clear() {
        const oldSize = ImageCache_1.ImageCache.instance.size;
        ImageCache_1.ImageCache.instance.clear(this.mapView);
        this.m_name2Url = new Map();
        this.m_url2Name = new Map();
        return oldSize;
    }
    /**
     * Returns number of mappings from name to URL in the cache. Only items with a name can get
     * mapped to URL.
     */
    get numberOfNames() {
        return this.m_name2Url.size;
    }
    /**
     * Returns number of mappings from URL to name in the cache. Only items with a name can get
     * mapped from URL to name.
     */
    get numberOfUrls() {
        return this.m_url2Name.size;
    }
    /**
     * Return `true` if an image with the given name is known.
     *
     * @param name - Name of the image.
     */
    hasName(name) {
        return this.m_name2Url.get(name) !== undefined;
    }
    /**
     * Return `true` if an image with the given URL is known. Only items with a name can get
     * mapped from URL to name.
     *
     * @param url - URL of image.
     */
    hasUrl(url) {
        return this.m_url2Name.get(url) !== undefined;
    }
    /**
     * Return the names under which an image with the given URL is saved. Only items with a name
     * can get mapped from URL to name.
     */
    findNames(url) {
        return this.m_url2Name.get(url);
    }
    /**
     * Remove the image with this name from the cache.
     *
     * @param name - Name of the image.
     * @returns `true` if item has been removed.
     */
    removeImageInternal(name) {
        const url = this.m_name2Url.get(name);
        if (url !== undefined) {
            this.m_name2Url.delete(name);
            const names = this.m_url2Name.get(url);
            if (names !== undefined && names.length > 1) {
                // There is another name sharing this URL.
                this.m_url2Name.set(url, names.splice(names.indexOf(name), 1));
            }
            else {
                // URL was used by this image only, remove the image.
                this.m_url2Name.delete(url);
                ImageCache_1.ImageCache.instance.removeImage(url);
            }
            return true;
        }
        return false;
    }
}
exports.MapViewImageCache = MapViewImageCache;
//# sourceMappingURL=MapViewImageCache.js.map