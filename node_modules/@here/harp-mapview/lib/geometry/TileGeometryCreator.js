"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileGeometryCreator = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = require("@here/harp-datasource-protocol");
const EdgeLengthGeometrySubdivisionModifier_1 = require("@here/harp-geometry/lib/EdgeLengthGeometrySubdivisionModifier");
const SphericalGeometrySubdivisionModifier_1 = require("@here/harp-geometry/lib/SphericalGeometrySubdivisionModifier");
const harp_geoutils_1 = require("@here/harp-geoutils");
const harp_materials_1 = require("@here/harp-materials");
const harp_text_canvas_1 = require("@here/harp-text-canvas");
const harp_utils_1 = require("@here/harp-utils");
const THREE = require("three");
const DecodedTileHelpers_1 = require("../DecodedTileHelpers");
const DepthPrePass_1 = require("../DepthPrePass");
const MapMaterialAdapter_1 = require("../MapMaterialAdapter");
const MapObjectAdapter_1 = require("../MapObjectAdapter");
const PathBlockingElement_1 = require("../PathBlockingElement");
const TextElement_1 = require("../text/TextElement");
const TextElementsRenderer_1 = require("../text/TextElementsRenderer");
const TileObjectsRenderer_1 = require("../TileObjectsRenderer");
const LodMesh_1 = require("./LodMesh");
const logger = harp_utils_1.LoggerManager.instance.create("TileGeometryCreator");
const tmpVector3 = new THREE.Vector3();
const tmpVector2 = new THREE.Vector2();
class AttachmentCache {
    constructor() {
        this.bufferAttributes = new Map();
        this.interleavedAttributes = new Map();
    }
}
class MemoCallExpr extends harp_datasource_protocol_1.CallExpr {
    constructor(expr) {
        super("memo", [expr]);
        this.m_cachedProperties = [];
        this.m_deps = Array.from(expr.dependencies().properties);
        this.descriptor = this;
    }
    call(context) {
        let changed = false;
        this.m_deps.forEach((d, i) => {
            const newValue = context.env.lookup(d);
            if (!changed && newValue !== this.m_cachedProperties[i]) {
                changed = true;
            }
            if (changed) {
                this.m_cachedProperties[i] = newValue;
            }
        });
        if (changed || this.m_cachedValue === undefined) {
            this.m_cachedValue = context.evaluate(this.args[0]);
        }
        return this.m_cachedValue;
    }
}
class AttachmentInfo {
    constructor(geometry, info, cache) {
        this.geometry = geometry;
        this.info = info;
        this.cache = cache;
    }
    getBufferAttribute(description) {
        if (this.cache.bufferAttributes.has(description)) {
            return this.cache.bufferAttributes.get(description);
        }
        const attribute = DecodedTileHelpers_1.getBufferAttribute(description);
        this.cache.bufferAttributes.set(description, attribute);
        return attribute;
    }
    getInterleavedBufferAttributes(description) {
        const interleavedAttributes = this.cache.interleavedAttributes.get(description);
        if (interleavedAttributes) {
            return interleavedAttributes;
        }
        const ArrayCtor = harp_datasource_protocol_1.getArrayConstructor(description.type);
        const buffer = new ArrayCtor(description.buffer);
        const interleavedBuffer = new THREE.InterleavedBuffer(buffer, description.stride);
        const attrs = description.attributes.map(interleavedAttr => {
            const attribute = new THREE.InterleavedBufferAttribute(interleavedBuffer, interleavedAttr.itemSize, interleavedAttr.offset, false);
            const name = interleavedAttr.name;
            return { name, attribute };
        });
        this.cache.interleavedAttributes.set(description, attrs);
        return attrs;
    }
}
function addToExtrudedMaterials(material, extrudedMaterials) {
    if (Array.isArray(material)) {
        const materials = material;
        extrudedMaterials.push(...materials);
    }
    else {
        extrudedMaterials.push(material);
    }
}
/**
 * Support class to create geometry for a {@link Tile} from a {@link @here/harp-datasource-protocol#DecodedTile}.
 */
class TileGeometryCreator {
    /**
     *  Creates an instance of TileGeometryCreator. Access is allowed only through `instance`.
     */
    constructor() {
        //
    }
    /**
     * The `instance` of the `TileGeometryCreator`.
     *
     * @returns TileGeometryCreator
     */
    static get instance() {
        return this.m_instance || (this.m_instance = new TileGeometryCreator());
    }
    /**
     * Apply `enabledKinds` and `disabledKinds` to all techniques in the `decodedTile`. If a
     * technique is identified as disabled, its property `enabled` is set to `false`.
     *
     * @param decodedTile - The decodedTile containing the actual tile map data.
     * @param enabledKinds - Optional [[GeometryKindSet]] used to specify which object kinds should be
     *      created.
     * @param disabledKinds - Optional [[GeometryKindSet]] used to filter objects that should not be
     *      created.
     */
    initDecodedTile(decodedTile, enabledKinds, disabledKinds) {
        for (const technique of decodedTile.techniques) {
            const kind = technique.kind;
            // No info about kind, no way to filter it.
            if (kind === undefined || (kind instanceof Set && kind.size === 0)) {
                technique._kindState = true;
                continue;
            }
            // Technique is enabled only if enabledKinds is defined and technique belongs to that set or
            // if that's not the case, disabledKinds must be undefined or technique does not belong to it.
            technique._kindState =
                !(disabledKinds !== undefined && disabledKinds.hasOrIntersects(kind)) ||
                    (enabledKinds !== undefined && enabledKinds.hasOrIntersects(kind));
        }
        for (const srcGeometry of decodedTile.geometries) {
            for (const group of srcGeometry.groups) {
                group.createdOffsets = [];
            }
        }
    }
    /**
     * Called after the `Tile` has been decoded. It is required to call `initDecodedTile` before
     * calling this method.
     *
     * @see [[TileGeometryCreator#initDecodedTile]]
     *
     * @param tile - The {@link Tile} to process.
     * @param decodedTile - The decodedTile containing the actual tile map data.
     */
    createAllGeometries(tile, decodedTile) {
        const filter = (technique) => {
            return technique._kindState !== false;
        };
        this.createObjects(tile, decodedTile, filter);
        this.preparePois(tile, decodedTile);
        // TextElements do not get their geometry created by Tile, but are managed on a
        // higher level.
        const textFilter = (technique) => {
            if (!harp_datasource_protocol_1.isPoiTechnique(technique) &&
                !harp_datasource_protocol_1.isLineMarkerTechnique(technique) &&
                !harp_datasource_protocol_1.isTextTechnique(technique)) {
                return false;
            }
            return filter(technique);
        };
        this.createTextElements(tile, decodedTile, textFilter);
        this.createLabelRejectionElements(tile, decodedTile);
        // HARP-7899, disable ground plane for globe
        if (tile.dataSource.addGroundPlane && tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {
            // The ground plane is required for when we change the zoom back and we fall back to the
            // parent, in that case we reduce the renderOrder of the parent tile and this ground
            // place ensures that parent doesn't come through. This value must be above the
            // renderOrder of all objects in the fallback tile, otherwise there won't be a proper
            // covering of the parent tile by the children, hence dividing by 2. To put a bit more
            // concretely, we assume all objects are rendered with a renderOrder between 0 and
            // FALLBACK_RENDER_ORDER_OFFSET / 2, i.e. 10000. The ground plane is put at -10000, and
            // the fallback tiles have their renderOrder set between -20000 and -10000
            TileGeometryCreator.instance.addGroundPlane(tile, -TileObjectsRenderer_1.FALLBACK_RENDER_ORDER_OFFSET / 2);
        }
    }
    createLabelRejectionElements(tile, decodedTile) {
        if (decodedTile.pathGeometries === undefined) {
            return;
        }
        for (const path of decodedTile.pathGeometries) {
            tile.addBlockingElement(new PathBlockingElement_1.PathBlockingElement(path.path));
        }
    }
    /**
     * Processes the given tile and assign default values for geometry kinds,
     * render orders and label priorities.
     *
     * @param {Tile} tile
     * @param {(GeometryKindSet | undefined)} enabledKinds
     * @param {(GeometryKindSet | undefined)} disabledKinds
     */
    processTechniques(tile, enabledKinds, disabledKinds) {
        const decodedTile = tile.decodedTile;
        if (decodedTile === undefined) {
            return;
        }
        // Speedup and simplify following code: Test all techniques if they intersect with
        // enabledKinds and disabledKinds, in which case they are flagged. The disabledKinds can be
        // ignored hereafter.
        this.initDecodedTile(decodedTile, enabledKinds, disabledKinds);
        // compile the dynamic expressions.
        const exprPool = tile.dataSource.exprPool;
        decodedTile.techniques.forEach((technique) => {
            for (const propertyName in technique) {
                if (!technique.hasOwnProperty(propertyName)) {
                    continue;
                }
                const value = technique[propertyName];
                if (harp_datasource_protocol_1.isJsonExpr(value) && propertyName !== "kind") {
                    // "kind" is reserved.
                    try {
                        let expr = harp_datasource_protocol_1.Expr.fromJSON(value);
                        if (expr.dependencies().volatile !== true) {
                            expr = new MemoCallExpr(harp_datasource_protocol_1.Expr.fromJSON(value));
                        }
                        technique[propertyName] = expr.intern(exprPool);
                    }
                    catch (error) {
                        logger.error("Failed to compile expression:", error);
                    }
                }
            }
        });
    }
    /**
     * Adds a THREE object to the root of the tile and register [[MapObjectAdapter]].
     *
     * Sets the owning tiles datasource.name and the `tileKey` in the `userData` property of the
     * object, such that the tile it belongs to can be identified during picking.
     *
     * @param tile - The {@link Tile} to add the object to.
     * @param object - The object to add to the root of the tile.
     * @param geometryKind - The kind of object. Can be used for filtering.
     * @param mapAdapterParams - additional parameters for [[MapObjectAdapter]]
     */
    registerTileObject(tile, object, geometryKind, mapAdapterParams) {
        const kind = geometryKind instanceof Set
            ? Array.from(geometryKind.values())
            : Array.isArray(geometryKind)
                ? geometryKind
                : [geometryKind];
        MapObjectAdapter_1.MapObjectAdapter.create(object, Object.assign({ kind }, mapAdapterParams));
        // TODO legacy fields, encoded directly in `userData to be removed
        if (object.userData === undefined) {
            object.userData = {};
        }
        const userData = object.userData;
        userData.tileKey = tile.tileKey;
        userData.dataSource = tile.dataSource.name;
        userData.kind = kind;
        // Force a visibility check of all objects.
        tile.resetVisibilityCounter();
    }
    /**
     * Splits the text paths that contain sharp corners.
     *
     * @param tile - The {@link Tile} to process paths on.
     * @param textPathGeometries - The original path geometries that may have defects.
     * @param textFilter -: Optional filter. Should return true for any text technique that is
     *      applicable.
     */
    prepareTextPaths(textPathGeometries, decodedTile, textFilter) {
        const processedPaths = new Array();
        const newPaths = textPathGeometries.slice();
        while (newPaths.length > 0) {
            const textPath = newPaths.pop();
            if (textPath === undefined) {
                break;
            }
            const technique = decodedTile.techniques[textPath.technique];
            if (!harp_datasource_protocol_1.isTextTechnique(technique) ||
                (textFilter !== undefined && !textFilter(technique))) {
                continue;
            }
            processedPaths.push(textPath);
        }
        return processedPaths;
    }
    /**
     * Creates {@link TextElement} objects from the decoded tile and list of materials specified. The
     * priorities of the {@link TextElement}s are updated to simplify label placement.
     *
     * @param tile - The {@link Tile} to create the testElements on.
     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.
     * @param textFilter -: Optional filter. Should return true for any text technique that is
     *      applicable.
     */
    createTextElements(tile, decodedTile, textFilter) {
        var _a, _b;
        const mapView = tile.mapView;
        const textStyleCache = tile.textStyleCache;
        const worldOffsetX = tile.computeWorldOffsetX();
        const discreteZoomLevel = Math.floor(mapView.zoomLevel);
        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
        if (decodedTile.textPathGeometries !== undefined) {
            const textPathGeometries = this.prepareTextPaths(decodedTile.textPathGeometries, decodedTile, textFilter);
            for (const textPath of textPathGeometries) {
                const technique = decodedTile.techniques[textPath.technique];
                if (technique._kindState === false ||
                    !harp_datasource_protocol_1.isTextTechnique(technique) ||
                    (textFilter !== undefined && !textFilter(technique))) {
                    continue;
                }
                const path = [];
                for (let i = 0; i < textPath.path.length; i += 3) {
                    path.push(new THREE.Vector3(textPath.path[i] + worldOffsetX, textPath.path[i + 1], textPath.path[i + 2]));
                }
                // Make sorting stable.
                const priority = technique.priority !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.priority, discreteZoomEnv)
                    : 0;
                const fadeNear = technique.fadeNear !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, discreteZoomEnv)
                    : technique.fadeNear;
                const fadeFar = technique.fadeFar !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, discreteZoomEnv)
                    : technique.fadeFar;
                const userData = textPath.objInfos;
                const featureId = harp_datasource_protocol_1.getFeatureId(userData);
                const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(textPath.text), path, textStyleCache.getRenderStyle(technique), textStyleCache.getLayoutStyle(technique), priority, technique.xOffset !== undefined ? technique.xOffset : 0.0, technique.yOffset !== undefined ? technique.yOffset : 0.0, featureId, technique.style, fadeNear, fadeFar, tile.offset);
                textElement.pathLengthSqr = textPath.pathLengthSqr;
                textElement.minZoomLevel =
                    technique.minZoomLevel !== undefined
                        ? technique.minZoomLevel
                        : mapView.minZoomLevel;
                textElement.maxZoomLevel =
                    technique.maxZoomLevel !== undefined
                        ? technique.maxZoomLevel
                        : mapView.maxZoomLevel;
                textElement.distanceScale =
                    technique.distanceScale !== undefined
                        ? technique.distanceScale
                        : TextElementsRenderer_1.DEFAULT_TEXT_DISTANCE_SCALE;
                textElement.mayOverlap = technique.mayOverlap === true;
                textElement.reserveSpace = technique.reserveSpace !== false;
                textElement.kind = technique.kind;
                // Get the userData for text element picking.
                textElement.userData = textPath.objInfos;
                textElement.textFadeTime = technique.textFadeTime;
                tile.addTextElement(textElement);
            }
        }
        if (decodedTile.textGeometries !== undefined) {
            for (const text of decodedTile.textGeometries) {
                if (text.technique === undefined || text.stringCatalog === undefined) {
                    continue;
                }
                const technique = decodedTile.techniques[text.technique];
                if (technique._kindState === false ||
                    !harp_datasource_protocol_1.isTextTechnique(technique) ||
                    (textFilter !== undefined && !textFilter(technique))) {
                    continue;
                }
                const positions = new THREE.BufferAttribute(new Float32Array(text.positions.buffer), text.positions.itemCount);
                const numPositions = positions.count;
                if (numPositions < 1) {
                    continue;
                }
                const priority = technique.priority !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.priority, discreteZoomEnv)
                    : 0;
                const fadeNear = technique.fadeNear !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, discreteZoomEnv)
                    : technique.fadeNear;
                const fadeFar = technique.fadeFar !== undefined
                    ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, discreteZoomEnv)
                    : technique.fadeFar;
                for (let i = 0; i < numPositions; ++i) {
                    const x = positions.getX(i) + worldOffsetX;
                    const y = positions.getY(i);
                    const z = positions.getZ(i);
                    const label = text.stringCatalog[text.texts[i]];
                    if (label === undefined) {
                        // skip missing labels
                        continue;
                    }
                    const userData = text.objInfos !== undefined ? text.objInfos[i] : undefined;
                    const featureId = harp_datasource_protocol_1.getFeatureId(userData);
                    const textElement = new TextElement_1.TextElement(harp_text_canvas_1.ContextualArabicConverter.instance.convert(label), new THREE.Vector3(x, y, z), textStyleCache.getRenderStyle(technique), textStyleCache.getLayoutStyle(technique), priority, (_a = technique.xOffset) !== null && _a !== void 0 ? _a : 0.0, (_b = technique.yOffset) !== null && _b !== void 0 ? _b : 0.0, featureId, technique.style, undefined, undefined, tile.offset);
                    textElement.minZoomLevel =
                        technique.minZoomLevel !== undefined
                            ? technique.minZoomLevel
                            : mapView.minZoomLevel;
                    textElement.maxZoomLevel =
                        technique.maxZoomLevel !== undefined
                            ? technique.maxZoomLevel
                            : mapView.maxZoomLevel;
                    textElement.mayOverlap = technique.mayOverlap === true;
                    textElement.reserveSpace = technique.reserveSpace !== false;
                    textElement.kind = technique.kind;
                    textElement.fadeNear = fadeNear;
                    textElement.fadeFar = fadeFar;
                    textElement.textFadeTime = technique.textFadeTime;
                    // Get the userData for text element picking.
                    textElement.userData = userData;
                    tile.addTextElement(textElement);
                }
            }
        }
    }
    /**
     * Creates `Tile` objects from the decoded tile and list of materials specified.
     *
     * @param tile - The {@link Tile} to create the geometry on.
     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.
     * @param techniqueFilter -: Optional filter. Should return true for any technique that is
     *      applicable.
     */
    createObjects(tile, decodedTile, techniqueFilter) {
        var _a, _b, _c, _d, _e, _f;
        const mapView = tile.mapView;
        const materials = [];
        const extrudedMaterials = [];
        const animatedExtrusionHandler = mapView.animatedExtrusionHandler;
        const dataSource = tile.dataSource;
        const discreteZoomLevel = Math.floor(mapView.zoomLevel);
        const discreteZoomEnv = new harp_datasource_protocol_1.MapEnv({ $zoom: discreteZoomLevel }, mapView.env);
        const objects = tile.objects;
        const viewRanges = mapView.viewRanges;
        const elevationEnabled = mapView.elevationProvider !== undefined;
        for (const attachment of this.getAttachments(decodedTile)) {
            const srcGeometry = attachment.geometry;
            const groups = attachment.info.groups;
            const groupCount = groups.length;
            for (let groupIndex = 0; groupIndex < groupCount;) {
                const group = groups[groupIndex++];
                const start = group.start;
                const techniqueIndex = group.technique;
                const technique = decodedTile.techniques[techniqueIndex];
                if (group.createdOffsets === undefined) {
                    group.createdOffsets = [];
                }
                if (group.createdOffsets.includes(tile.offset) ||
                    technique._kindState === false ||
                    (techniqueFilter !== undefined && !techniqueFilter(technique))) {
                    continue;
                }
                let count = group.count;
                group.createdOffsets.push(tile.offset);
                // compress consecutive groups
                for (; groupIndex < groupCount && groups[groupIndex].technique === techniqueIndex; ++groupIndex) {
                    if (start + count !== groups[groupIndex].start) {
                        break;
                    }
                    count += groups[groupIndex].count;
                    // Mark this group as created, so it does not get processed again.
                    groups[groupIndex].createdOffsets.push(tile.offset);
                }
                if (!DecodedTileHelpers_1.usesObject3D(technique)) {
                    continue;
                }
                const extrusionAnimationEnabled = (_a = animatedExtrusionHandler === null || animatedExtrusionHandler === void 0 ? void 0 : animatedExtrusionHandler.setAnimationProperties(technique, discreteZoomEnv)) !== null && _a !== void 0 ? _a : false;
                let material = materials[techniqueIndex];
                if (material === undefined) {
                    const onMaterialUpdated = (texture) => {
                        dataSource.requestUpdate();
                        if (texture !== undefined) {
                            tile.addOwnedTexture(texture);
                        }
                    };
                    material = DecodedTileHelpers_1.createMaterial(mapView.renderer.capabilities, {
                        technique,
                        env: mapView.env,
                        fog: mapView.scene.fog !== null,
                        shadowsEnabled: mapView.shadowsEnabled
                    }, onMaterialUpdated);
                    if (material === undefined) {
                        continue;
                    }
                    if (extrusionAnimationEnabled && harp_materials_1.hasExtrusionFeature(material)) {
                        addToExtrudedMaterials(material, extrudedMaterials);
                    }
                    materials[techniqueIndex] = material;
                }
                const techniqueKind = technique.kind;
                // Modify the standard textured shader to support height-based coloring.
                if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {
                    this.setupTerrainMaterial(technique, material, tile.mapView.clearColor);
                }
                const bufferGeometry = new THREE.BufferGeometry();
                (_b = srcGeometry.vertexAttributes) === null || _b === void 0 ? void 0 : _b.forEach(vertexAttribute => {
                    const buffer = attachment.getBufferAttribute(vertexAttribute);
                    bufferGeometry.setAttribute(vertexAttribute.name, buffer);
                });
                (_c = srcGeometry.interleavedVertexAttributes) === null || _c === void 0 ? void 0 : _c.forEach(attr => {
                    attachment
                        .getInterleavedBufferAttributes(attr)
                        .forEach(({ name, attribute }) => bufferGeometry.setAttribute(name, attribute));
                });
                const index = (_d = attachment.info.index) !== null && _d !== void 0 ? _d : srcGeometry.index;
                if (index) {
                    bufferGeometry.setIndex(attachment.getBufferAttribute(index));
                }
                if (!bufferGeometry.getAttribute("normal") && harp_datasource_protocol_1.needsVertexNormals(technique)) {
                    bufferGeometry.computeVertexNormals();
                }
                bufferGeometry.addGroup(start, count);
                if (harp_datasource_protocol_1.isSolidLineTechnique(technique)) {
                    // TODO: Unify access to shader defines via SolidLineMaterial setters
                    harp_utils_1.assert(!harp_materials_1.isHighPrecisionLineMaterial(material));
                    const lineMaterial = material;
                    if (technique.clipping === true &&
                        tile.projection.type === harp_geoutils_1.ProjectionType.Planar) {
                        tile.boundingBox.getSize(tmpVector3);
                        tmpVector2.set(tmpVector3.x, tmpVector3.y);
                        lineMaterial.clipTileSize = tmpVector2;
                    }
                    if (bufferGeometry.getAttribute("color")) {
                        harp_materials_1.setShaderMaterialDefine(lineMaterial, "USE_COLOR", true);
                    }
                }
                // Add the solid line outlines as a separate object.
                const hasSolidLinesOutlines = harp_datasource_protocol_1.isSolidLineTechnique(technique) && technique.secondaryWidth !== undefined;
                // When the source geometry is split in groups, we
                // should create objects with an array of materials.
                const hasFeatureGroups = harp_datasource_protocol_1.Expr.isExpr(technique.enabled) &&
                    srcGeometry.featureStarts &&
                    srcGeometry.featureStarts.length > 0;
                const object = DecodedTileHelpers_1.buildObject(technique, bufferGeometry, hasFeatureGroups ? [material] : material, tile, elevationEnabled);
                object.renderOrder = harp_datasource_protocol_1.getPropertyValue(technique.renderOrder, mapView.env);
                if (attachment.info.uuid !== undefined) {
                    object.uuid = attachment.info.uuid;
                    object.userData.geometryId = attachment.info.uuid;
                }
                if ((harp_datasource_protocol_1.isCirclesTechnique(technique) || harp_datasource_protocol_1.isSquaresTechnique(technique)) &&
                    technique.enablePicking !== undefined) {
                    object.enableRayTesting = technique.enablePicking;
                }
                if (harp_datasource_protocol_1.isLineTechnique(technique) || harp_datasource_protocol_1.isSegmentsTechnique(technique)) {
                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);
                }
                if (harp_datasource_protocol_1.isSolidLineTechnique(technique)) {
                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);
                }
                if (harp_datasource_protocol_1.isExtrudedLineTechnique(technique)) {
                    // extruded lines are normal meshes, and need transparency only when fading or
                    // dynamic properties is defined.
                    if (technique.fadeFar !== undefined) {
                        const fadingParams = this.getFadingParams(mapView.env, technique);
                        harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true);
                    }
                }
                this.addUserData(tile, srcGeometry, technique, object);
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                    object.castShadow = mapView.shadowsEnabled;
                    object.receiveShadow = mapView.shadowsEnabled;
                }
                else if (harp_datasource_protocol_1.isStandardTechnique(technique) || harp_datasource_protocol_1.isFillTechnique(technique)) {
                    object.receiveShadow = mapView.shadowsEnabled;
                }
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) ||
                    harp_datasource_protocol_1.isStandardTechnique(technique) ||
                    harp_datasource_protocol_1.isFillTechnique(technique)) {
                    // filled polygons are normal meshes, and need transparency only when fading or
                    // dynamic properties is defined.
                    if (technique.fadeFar !== undefined) {
                        const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                        harp_materials_1.FadingFeature.addRenderHelper(object, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, true);
                    }
                }
                const renderDepthPrePass = harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&
                    DepthPrePass_1.isRenderDepthPrePassEnabled(technique, discreteZoomEnv);
                if (renderDepthPrePass) {
                    const depthPassMesh = DepthPrePass_1.createDepthPrePassMesh(object);
                    this.addUserData(tile, srcGeometry, technique, depthPassMesh);
                    // Set geometry kind for depth pass mesh so that it gets the displacement map
                    // for elevation overlay.
                    this.registerTileObject(tile, depthPassMesh, techniqueKind, {
                        technique,
                        pickable: false
                    });
                    objects.push(depthPassMesh);
                    if (extrusionAnimationEnabled) {
                        addToExtrudedMaterials(depthPassMesh.material, extrudedMaterials);
                    }
                    DepthPrePass_1.setDepthPrePassStencil(depthPassMesh, object);
                }
                // register all objects as pickable except solid lines with outlines, in that case
                // it's enough to make outlines pickable.
                this.registerTileObject(tile, object, techniqueKind, {
                    technique,
                    pickable: !hasSolidLinesOutlines
                });
                objects.push(object);
                // Add the extruded polygon edges as a separate geometry.
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) &&
                    attachment.info.edgeIndex !== undefined) {
                    // When the source geometry is split in groups, we
                    // should create objects with an array of materials.
                    const hasEdgeFeatureGroups = harp_datasource_protocol_1.Expr.isExpr(technique.enabled) &&
                        srcGeometry.edgeFeatureStarts &&
                        srcGeometry.edgeFeatureStarts.length > 0;
                    const buildingTechnique = technique;
                    const edgeGeometry = new THREE.BufferGeometry();
                    edgeGeometry.setAttribute("position", bufferGeometry.getAttribute("position"));
                    const colorAttribute = bufferGeometry.getAttribute("color");
                    if (colorAttribute !== undefined) {
                        edgeGeometry.setAttribute("color", colorAttribute);
                    }
                    const extrusionAttribute = bufferGeometry.getAttribute("extrusionAxis");
                    if (extrusionAttribute !== undefined) {
                        edgeGeometry.setAttribute("extrusionAxis", extrusionAttribute);
                    }
                    const normalAttribute = bufferGeometry.getAttribute("normal");
                    if (normalAttribute !== undefined) {
                        edgeGeometry.setAttribute("normal", normalAttribute);
                    }
                    const uvAttribute = bufferGeometry.getAttribute("uv");
                    if (uvAttribute !== undefined) {
                        edgeGeometry.setAttribute("uv", uvAttribute);
                    }
                    edgeGeometry.setIndex(attachment.getBufferAttribute(attachment.info.edgeIndex));
                    // Read the uniforms from the technique values (and apply the default values).
                    const extrudedPolygonTechnique = technique;
                    const fadingParams = this.getPolygonFadingParams(discreteZoomEnv, extrudedPolygonTechnique);
                    // Configure the edge material based on the theme values.
                    const materialParams = {
                        color: fadingParams.color,
                        colorMix: fadingParams.colorMix,
                        fadeNear: fadingParams.lineFadeNear,
                        fadeFar: fadingParams.lineFadeFar,
                        extrusionRatio: extrusionAnimationEnabled ? 0 : undefined,
                        vertexColors: bufferGeometry.getAttribute("color") ? true : false,
                        rendererCapabilities: mapView.renderer.capabilities
                    };
                    const edgeMaterial = new harp_materials_1.EdgeMaterial(materialParams);
                    const edgeObj = new THREE.LineSegments(edgeGeometry, hasEdgeFeatureGroups ? [edgeMaterial] : edgeMaterial);
                    this.addUserData(tile, srcGeometry, technique, edgeObj);
                    // Set the correct render order.
                    edgeObj.renderOrder = object.renderOrder + 0.1;
                    harp_materials_1.FadingFeature.addRenderHelper(edgeObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false);
                    if (extrusionAnimationEnabled) {
                        addToExtrudedMaterials(edgeObj.material, extrudedMaterials);
                    }
                    this.registerTileObject(tile, edgeObj, techniqueKind, {
                        technique,
                        pickable: false
                    });
                    MapMaterialAdapter_1.MapMaterialAdapter.create(edgeMaterial, {
                        color: buildingTechnique.lineColor,
                        objectColor: buildingTechnique.color,
                        opacity: buildingTechnique.opacity,
                        lineWidth: (frameMapView) => {
                            // lineWidth for ExtrudedPolygonEdges only supports 0 or 1
                            const value = harp_datasource_protocol_1.getPropertyValue(buildingTechnique.lineWidth, frameMapView.env);
                            if (typeof value === "number") {
                                return THREE.MathUtils.clamp(value, 0, 1);
                            }
                            else {
                                return 0;
                            }
                        }
                    });
                    objects.push(edgeObj);
                }
                // animate the extrusion of buildings
                if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) && extrusionAnimationEnabled) {
                    object.customDepthMaterial = new harp_materials_1.MapMeshDepthMaterial({
                        depthPacking: THREE.RGBADepthPacking
                    });
                    addToExtrudedMaterials(object.customDepthMaterial, extrudedMaterials);
                }
                // Add the fill area edges as a separate geometry.
                if (harp_datasource_protocol_1.isFillTechnique(technique) && attachment.info.edgeIndex) {
                    const hasEdgeFeatureGroups = harp_datasource_protocol_1.Expr.isExpr(technique.enabled) &&
                        srcGeometry.edgeFeatureStarts &&
                        srcGeometry.edgeFeatureStarts.length > 0;
                    const outlineGeometry = new THREE.BufferGeometry();
                    outlineGeometry.setAttribute("position", bufferGeometry.getAttribute("position"));
                    outlineGeometry.setIndex(attachment.getBufferAttribute(attachment.info.edgeIndex));
                    const fillTechnique = technique;
                    const fadingParams = this.getPolygonFadingParams(mapView.env, fillTechnique);
                    // Configure the edge material based on the theme values.
                    const materialParams = {
                        color: fadingParams.color,
                        colorMix: fadingParams.colorMix,
                        fadeNear: fadingParams.lineFadeNear,
                        fadeFar: fadingParams.lineFadeFar,
                        vertexColors: bufferGeometry.getAttribute("color") ? true : false,
                        rendererCapabilities: mapView.renderer.capabilities
                    };
                    const outlineMaterial = new harp_materials_1.EdgeMaterial(materialParams);
                    const outlineObj = new THREE.LineSegments(outlineGeometry, hasEdgeFeatureGroups ? [outlineMaterial] : outlineMaterial);
                    outlineObj.renderOrder = object.renderOrder + 0.1;
                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.lineFadeNear, fadingParams.lineFadeFar, false);
                    this.addUserData(tile, srcGeometry, technique, outlineObj);
                    this.registerTileObject(tile, outlineObj, techniqueKind, {
                        technique,
                        pickable: false
                    });
                    MapMaterialAdapter_1.MapMaterialAdapter.create(outlineMaterial, {
                        color: fillTechnique.lineColor,
                        objectColor: fillTechnique.color,
                        opacity: fillTechnique.opacity
                    });
                    objects.push(outlineObj);
                }
                // Add the fill area edges as a separate geometry.
                if (hasSolidLinesOutlines) {
                    const outlineTechnique = technique;
                    const outlineMaterial = material.clone();
                    DecodedTileHelpers_1.applyBaseColorToMaterial(outlineMaterial, outlineMaterial.color, outlineTechnique, (_e = outlineTechnique.secondaryColor) !== null && _e !== void 0 ? _e : 0x000000, discreteZoomEnv);
                    if (outlineTechnique.secondaryCaps !== undefined) {
                        outlineMaterial.caps = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryCaps, mapView.env);
                    }
                    const outlineObj = DecodedTileHelpers_1.buildObject(technique, bufferGeometry, outlineMaterial, tile, elevationEnabled);
                    outlineObj.renderOrder =
                        ((_f = harp_datasource_protocol_1.getPropertyValue(outlineTechnique.secondaryRenderOrder, mapView.env)) !== null && _f !== void 0 ? _f : 0) - 0.0000001;
                    this.addUserData(tile, srcGeometry, technique, outlineObj);
                    const fadingParams = this.getFadingParams(discreteZoomEnv, technique);
                    harp_materials_1.FadingFeature.addRenderHelper(outlineObj, viewRanges, fadingParams.fadeNear, fadingParams.fadeFar, false);
                    const secondaryWidth = DecodedTileHelpers_1.buildMetricValueEvaluator(outlineTechnique.secondaryWidth, outlineTechnique.metricUnit);
                    this.registerTileObject(tile, outlineObj, techniqueKind, { technique });
                    const mainMaterialAdapter = MapMaterialAdapter_1.MapMaterialAdapter.get(material);
                    const outlineMaterialAdapter = MapMaterialAdapter_1.MapMaterialAdapter.create(outlineMaterial, {
                        color: outlineTechnique.secondaryColor,
                        opacity: outlineTechnique.opacity,
                        caps: outlineTechnique.secondaryCaps,
                        // Still handled above
                        lineWidth: (frameMapView) => {
                            if (!mainMaterialAdapter) {
                                return;
                            }
                            mainMaterialAdapter.ensureUpdated(frameMapView);
                            const mainLineWidth = mainMaterialAdapter.currentStyledProperties.lineWidth;
                            const secondaryLineWidth = harp_datasource_protocol_1.getPropertyValue(secondaryWidth, mapView.env);
                            const opacity = outlineMaterialAdapter.currentStyledProperties
                                .opacity;
                            if (typeof mainLineWidth === "number" &&
                                typeof secondaryLineWidth === "number") {
                                if (secondaryLineWidth <= mainLineWidth &&
                                    (opacity === null || opacity === undefined || opacity === 1)) {
                                    // We could mark object as invisible somehow, not sure how
                                    // objectAdapter.markInvisible();
                                    return 0;
                                }
                                else {
                                    return secondaryLineWidth;
                                }
                            }
                            else {
                                return 0;
                            }
                        }
                    });
                    objects.push(outlineObj);
                }
            }
        }
        if (extrudedMaterials.length > 0) {
            mapView.animatedExtrusionHandler.add(tile, extrudedMaterials);
        }
    }
    /**
     * Prepare the {@link Tile}s pois. Uses the {@link PoiManager} in {@link MapView}.
     */
    preparePois(tile, decodedTile) {
        if (decodedTile.poiGeometries !== undefined) {
            tile.mapView.poiManager.addPois(tile, decodedTile);
        }
    }
    /**
     * Create a ground plane mesh for a tile
     * @param tile - Tile
     * @param material - Material
     * @param createTexCoords - Enable creation of texture coordinates
     */
    createGroundPlane(tile, material, createTexCoords, shadowsEnabled) {
        var _a;
        const { dataSource, projection, mapView } = tile;
        const sourceProjection = dataSource.getTilingScheme().projection;
        const shouldSubdivide = projection.type === harp_geoutils_1.ProjectionType.Spherical;
        const tmpV = new THREE.Vector3();
        function moveTileCenter(geom) {
            const attr = geom.getAttribute("position");
            const posArray = attr.array;
            for (let i = 0; i < posArray.length; i += 3) {
                tmpV.set(posArray[i], posArray[i + 1], posArray[i + 2]);
                projection.reprojectPoint(sourceProjection, tmpV, tmpV);
                tmpV.sub(tile.center);
                posArray[i] = tmpV.x;
                posArray[i + 1] = tmpV.y;
                posArray[i + 2] = tmpV.z;
            }
            attr.needsUpdate = true;
        }
        const geometry = new THREE.BufferGeometry();
        // Create plane
        const tileCorners = this.generateTilePlaneCorners(tile.geoBox, sourceProjection);
        const posAttr = new THREE.BufferAttribute(new Float32Array([
            ...tileCorners.sw.toArray(),
            ...tileCorners.se.toArray(),
            ...tileCorners.nw.toArray(),
            ...tileCorners.ne.toArray()
        ]), 3);
        geometry.setAttribute("position", posAttr);
        if (shadowsEnabled === true) {
            sourceProjection.surfaceNormal(tileCorners.sw, tmpV);
            // Webmercator needs to have it negated to work correctly.
            tmpV.negate();
            const normAttr = new THREE.BufferAttribute(new Float32Array([
                ...tmpV.toArray(),
                ...tmpV.toArray(),
                ...tmpV.toArray(),
                ...tmpV.toArray()
            ]), 3);
            geometry.setAttribute("normal", normAttr);
        }
        geometry.setIndex(new THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 1, 3]), 1));
        if (createTexCoords) {
            const uvAttr = new THREE.BufferAttribute(new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), 2);
            geometry.setAttribute("uv", uvAttr);
        }
        if (shouldSubdivide) {
            const geometries = [];
            const sphericalModifier = new SphericalGeometrySubdivisionModifier_1.SphericalGeometrySubdivisionModifier(THREE.MathUtils.degToRad(10), sourceProjection);
            const enableMixedLod = (_a = mapView.enableMixedLod) !== null && _a !== void 0 ? _a : mapView.enableMixedLod === undefined;
            if (enableMixedLod) {
                // Use a [[LodMesh]] to adapt tesselation of tile depending on zoom level
                for (let zoomLevelOffset = 0; zoomLevelOffset < 4; ++zoomLevelOffset) {
                    const subdivision = Math.pow(2, zoomLevelOffset);
                    const zoomLevelGeometry = geometry.clone();
                    if (subdivision > 1) {
                        const edgeModifier = new EdgeLengthGeometrySubdivisionModifier_1.EdgeLengthGeometrySubdivisionModifier(subdivision, tile.geoBox, EdgeLengthGeometrySubdivisionModifier_1.SubdivisionMode.All, sourceProjection);
                        edgeModifier.modify(zoomLevelGeometry);
                    }
                    sphericalModifier.modify(zoomLevelGeometry);
                    moveTileCenter(zoomLevelGeometry);
                    geometries.push(zoomLevelGeometry);
                }
                return new LodMesh_1.LodMesh(geometries, material);
            }
            else {
                // Use static mesh if mixed LOD is disabled
                sphericalModifier.modify(geometry);
                moveTileCenter(geometry);
                return new THREE.Mesh(geometry, material);
            }
        }
        else {
            // Use static mesh for planar projection
            moveTileCenter(geometry);
            return new THREE.Mesh(geometry, material);
        }
    }
    generateTilePlaneCorners(geoBox, sourceProjection) {
        const { east, west, north, south } = geoBox;
        const sw = sourceProjection.projectPoint(new harp_geoutils_1.GeoCoordinates(south, west), new THREE.Vector3());
        const se = sourceProjection.projectPoint(new harp_geoutils_1.GeoCoordinates(south, east), new THREE.Vector3());
        const nw = sourceProjection.projectPoint(new harp_geoutils_1.GeoCoordinates(north, west), new THREE.Vector3());
        const ne = sourceProjection.projectPoint(new harp_geoutils_1.GeoCoordinates(north, east), new THREE.Vector3());
        return { sw, se, nw, ne };
    }
    /**
     * Creates and add a background plane for the tile.
     * @param tile - Tile
     * @param renderOrder - Render order of the tile
     */
    addGroundPlane(tile, renderOrder) {
        const shadowsEnabled = tile.mapView.shadowsEnabled;
        const material = this.createGroundPlaneMaterial(new THREE.Color(tile.mapView.clearColor), tile.mapView.shadowsEnabled, tile.mapView.projection.type === harp_geoutils_1.ProjectionType.Spherical);
        const mesh = this.createGroundPlane(tile, material, false, shadowsEnabled);
        mesh.receiveShadow = shadowsEnabled;
        mesh.renderOrder = renderOrder;
        this.registerTileObject(tile, mesh, harp_datasource_protocol_1.GeometryKind.Background, { pickable: false });
        tile.objects.push(mesh);
    }
    createGroundPlaneMaterial(color, shadowsEnabled, depthWrite) {
        if (shadowsEnabled) {
            return new harp_materials_1.MapMeshStandardMaterial({
                color,
                visible: true,
                depthWrite,
                removeDiffuseLight: true
            });
        }
        else {
            return new harp_materials_1.MapMeshBasicMaterial({
                color,
                visible: true,
                depthWrite
            });
        }
    }
    /**
     * Gets the attachments of the given {@link @here/harp-datasource-protocol#DecodedTile}.
     *
     * @param decodedTile - The {@link @here/harp-datasource-protocol#DecodedTile}.
     */
    *getAttachments(decodedTile) {
        const cache = new AttachmentCache();
        for (const geometry of decodedTile.geometries) {
            // the main attachment
            const mainAttachment = {
                index: geometry.index,
                edgeIndex: geometry.edgeIndex,
                uuid: geometry.uuid,
                groups: geometry.groups
            };
            yield new AttachmentInfo(geometry, mainAttachment, cache);
            if (geometry.attachments) {
                // the additional attachments
                for (const info of geometry.attachments) {
                    yield new AttachmentInfo(geometry, info, cache);
                }
            }
        }
    }
    setupTerrainMaterial(technique, material, terrainColor) {
        if (!technique.map || !technique.displacementMap) {
            // Render terrain using the given color.
            const stdMaterial = material;
            stdMaterial.color.set(terrainColor);
            // Remove displacement map, otherwise it would elevate terrain geometry and make it
            // twice as high as it should be.
            stdMaterial.displacementMap = null;
            return;
        }
        // Render terrain using height-based colors.
        material.onBeforeCompile = (shader) => {
            shader.fragmentShader = shader.fragmentShader.replace("#include <map_pars_fragment>", `#include <map_pars_fragment>
    uniform sampler2D displacementMap;
    uniform float displacementScale;
    uniform float displacementBias;`);
            shader.fragmentShader = shader.fragmentShader.replace("#include <map_fragment>", `#ifdef USE_MAP
    float minElevation = ${harp_geoutils_1.EarthConstants.MIN_ELEVATION.toFixed(1)};
    float maxElevation = ${harp_geoutils_1.EarthConstants.MAX_ELEVATION.toFixed(1)};
    float elevationRange = maxElevation - minElevation;

    float disp = texture2D( displacementMap, vUv ).x * displacementScale + displacementBias;
    vec4 texelColor = texture2D( map, vec2((disp - minElevation) / elevationRange, 0.0) );
    texelColor = mapTexelToLinear( texelColor );
    diffuseColor *= texelColor;
#endif`);
            // We remove the displacement map from manipulating the vertices, it is
            // however still required for the pixel shader, so it can't be directly
            // removed.
            shader.vertexShader = shader.vertexShader.replace("#include <displacementmap_vertex>", "");
        };
        material.displacementMap.needsUpdate = true;
    }
    addUserData(tile, srcGeometry, technique, object) {
        if (harp_datasource_protocol_1.isTerrainTechnique(technique)) {
            harp_utils_1.assert(Object.keys(object.userData).length === 0, "Unexpected user data in terrain object");
            harp_utils_1.assert(typeof srcGeometry.objInfos[0] === "object", "Wrong attribute map type for terrain geometry");
            const displacementMap = srcGeometry.objInfos[0];
            const tileDisplacementMap = {
                tileKey: tile.tileKey,
                texture: new THREE.DataTexture(displacementMap.buffer, displacementMap.xCountVertices, displacementMap.yCountVertices, THREE.LuminanceFormat, THREE.FloatType),
                displacementMap,
                geoBox: tile.geoBox
            };
            object.userData = tileDisplacementMap;
        }
        else {
            // Set the feature data for picking with `MapView.intersectMapObjects()` except for
            // solid-line which uses tile-based picking.
            const isOutline = object.type === "LineSegments" &&
                (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique) || harp_datasource_protocol_1.isFillTechnique(technique));
            const featureData = {
                geometryType: srcGeometry.type,
                starts: isOutline ? srcGeometry.edgeFeatureStarts : srcGeometry.featureStarts,
                objInfos: srcGeometry.objInfos
            };
            object.userData.feature = featureData;
            object.userData.technique = technique;
        }
    }
    /**
     * Gets the fading parameters for several kinds of objects.
     */
    getFadingParams(env, technique) {
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;
        return {
            fadeNear,
            fadeFar
        };
    }
    /**
     * Gets the fading parameters for several kinds of objects.
     */
    getPolygonFadingParams(env, technique) {
        let color;
        let colorMix = harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;
        if (technique.lineColor !== undefined) {
            color = harp_datasource_protocol_1.getPropertyValue(technique.lineColor, env);
            if (harp_datasource_protocol_1.isExtrudedPolygonTechnique(technique)) {
                const extrudedPolygonTechnique = technique;
                colorMix =
                    extrudedPolygonTechnique.lineColorMix !== undefined
                        ? extrudedPolygonTechnique.lineColorMix
                        : harp_materials_1.EdgeMaterial.DEFAULT_COLOR_MIX;
            }
        }
        const fadeNear = technique.fadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeNear, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_NEAR;
        const fadeFar = technique.fadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.fadeFar, env)
            : harp_materials_1.FadingFeature.DEFAULT_FADE_FAR;
        const lineFadeNear = technique.lineFadeNear !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeNear, env)
            : fadeNear;
        const lineFadeFar = technique.lineFadeFar !== undefined
            ? harp_datasource_protocol_1.getPropertyValue(technique.lineFadeFar, env)
            : fadeFar;
        if (color === undefined) {
            color = harp_materials_1.EdgeMaterial.DEFAULT_COLOR;
        }
        return {
            color,
            colorMix,
            fadeNear,
            fadeFar,
            lineFadeNear,
            lineFadeFar
        };
    }
}
exports.TileGeometryCreator = TileGeometryCreator;
//# sourceMappingURL=TileGeometryCreator.js.map