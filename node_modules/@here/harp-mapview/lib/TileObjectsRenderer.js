"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileObjectRenderer = exports.FALLBACK_RENDER_ORDER_OFFSET = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = require("@here/harp-datasource-protocol");
const SolidLineMesh_1 = require("./geometry/SolidLineMesh");
const MapObjectAdapter_1 = require("./MapObjectAdapter");
/**
 * All objects in fallback tiles are reduced by this amount.
 *
 * @internal
 */
exports.FALLBACK_RENDER_ORDER_OFFSET = 20000;
const DEFAULT_STENCIL_VALUE = 1;
class TileObjectRenderer {
    constructor(m_env) {
        this.m_env = m_env;
        this.m_renderOrderStencilValues = new Map();
        // Valid values start at 1, because the screen is cleared to zero
        this.m_stencilValue = DEFAULT_STENCIL_VALUE;
    }
    render(tile, zoomLevel, cameraPosition, rootNode) {
        const worldOffsetX = tile.computeWorldOffsetX();
        if (tile.willRender(zoomLevel)) {
            for (const object of tile.objects) {
                const mapObjectAdapter = MapObjectAdapter_1.MapObjectAdapter.get(object);
                if (!this.processTileObject(tile, object, mapObjectAdapter)) {
                    continue;
                }
                this.updateStencilRef(object);
                object.position.copy(tile.center);
                if (object.displacement !== undefined) {
                    object.position.add(object.displacement);
                }
                object.position.x += worldOffsetX;
                object.position.sub(cameraPosition);
                if (tile.localTangentSpace) {
                    object.setRotationFromMatrix(tile.boundingBox.getRotationMatrix());
                }
                object.frustumCulled = false;
                this.adjustRenderOrderForFallback(object, mapObjectAdapter, tile);
                rootNode.add(object);
            }
            tile.didRender();
        }
    }
    prepareRender() {
        this.m_stencilValue = DEFAULT_STENCIL_VALUE;
        this.m_renderOrderStencilValues.clear();
    }
    updateStencilRef(object) {
        // TODO: acquire a new style value of if transparent
        if (object.renderOrder !== undefined && object instanceof SolidLineMesh_1.SolidLineMesh) {
            const material = object.material;
            if (Array.isArray(material)) {
                material.forEach(mat => (mat.stencilRef = this.getStencilValue(object.renderOrder)));
            }
            else {
                material.stencilRef = this.getStencilValue(object.renderOrder);
            }
        }
    }
    allocateStencilValue(renderOrder) {
        const stencilValue = this.m_stencilValue++;
        this.m_renderOrderStencilValues.set(renderOrder, stencilValue);
        return stencilValue;
    }
    getStencilValue(renderOrder) {
        var _a;
        return ((_a = this.m_renderOrderStencilValues.get(renderOrder)) !== null && _a !== void 0 ? _a : this.allocateStencilValue(renderOrder));
    }
    adjustRenderOrderForFallback(object, mapObjectAdapter, tile) {
        // When falling back to a parent tile (i.e. tile.levelOffset < 0) there will
        // be overlaps with the already loaded tiles. Therefore all (flat) objects
        // in a fallback tile must be shifted, such that their renderOrder is less
        // than the groundPlane that each neighbouring Tile has (it has a renderOrder
        // of -10000, see addGroundPlane in TileGeometryCreator), only then can we be
        // sure that nothing of the parent will be rendered on top of the children,
        // as such, we shift using the FALLBACK_RENDER_ORDER_OFFSET.
        // This does not apply to buildings b/c they are 3d and the overlaps
        // are resolved with a depth prepass. Note we set this always to ensure that if
        // the Tile is used as a fallback, and then used normally, that we have the correct
        // renderOrder.
        var _a, _b;
        if (tile.levelOffset >= 0) {
            if (object._backupRenderOrder !== undefined) {
                // We messed up the render order when this tile was used as fallback.
                // Now we render normally, so restore the original renderOrder.
                object.renderOrder = object._backupRenderOrder;
            }
            return;
        }
        let offset = exports.FALLBACK_RENDER_ORDER_OFFSET;
        const technique = mapObjectAdapter === null || mapObjectAdapter === void 0 ? void 0 : mapObjectAdapter.technique;
        if ((technique === null || technique === void 0 ? void 0 : technique.name) === "extruded-polygon") {
            // Don't adjust render order for extruded-polygon b/c it's not flat.
            return;
        }
        if (((_b = (_a = technique) === null || _a === void 0 ? void 0 : _a._category) === null || _b === void 0 ? void 0 : _b.startsWith("road")) === true) {
            // Don't adjust render order for roads b/c the outline of the child tile
            // would overlap the outline of the fallback parent.
            // Road geometry would be duplicated but since it's rendered with two passes
            // it would just appear a bit wider. That artefact is not as disturbing
            // as seeing the cap outlines.
            // NOTE: Since our tests do pixel perfect image comparison we also need to add a
            // tiny offset in this case so that the order is well defined.
            offset = 1e-6;
        }
        if (object._backupRenderOrder === undefined) {
            object._backupRenderOrder = object.renderOrder;
        }
        object.renderOrder = object._backupRenderOrder + offset * tile.levelOffset;
    }
    /**
     * Process dynamic updates of [[TileObject]]'s style.
     *
     * @returns `true` if object shall be used in scene, `false` otherwise
     */
    processTileObject(tile, object, mapObjectAdapter) {
        if (!object.visible) {
            return false;
        }
        if (!this.processTileObjectFeatures(tile, object)) {
            return false;
        }
        if (mapObjectAdapter) {
            mapObjectAdapter.ensureUpdated(tile.mapView);
            if (!mapObjectAdapter.isVisible()) {
                return false;
            }
        }
        return true;
    }
    /**
     * Process the features owned by the given [[TileObject]].
     *
     * @param tile - The {@link Tile} owning the [[TileObject]]'s features.
     * @param object - The [[TileObject]] to process.
     * @returns `false` if the given [[TileObject]] should not be added to the scene.
     */
    processTileObjectFeatures(tile, object) {
        var _a, _b;
        const technique = object.userData.technique;
        if (!technique || technique.enabled === undefined) {
            // Nothing to do, there's no technique.
            return true;
        }
        const feature = object.userData.feature;
        if (!feature || !harp_datasource_protocol_1.Expr.isExpr(technique.enabled)) {
            return Boolean(harp_datasource_protocol_1.getPropertyValue(technique.enabled, this.m_env));
        }
        const { starts, objInfos } = feature;
        if (!Array.isArray(objInfos) || !Array.isArray(starts)) {
            // Nothing to do, the object is missing feature ids and their position
            // in the index buffer.
            return true;
        }
        const geometry = object.geometry;
        if (!geometry || !geometry.isBufferGeometry) {
            // Nothing to do, the geometry is not a [[THREE.BufferGeometry]]
            // and we can't generate groups.
            return true;
        }
        // ExtrudeBufferGeometry for example doesn't have an index, hence we get the final index
        // from the number of vertices.
        const finalIndex = (_b = (_a = geometry.getIndex()) === null || _a === void 0 ? void 0 : _a.count) !== null && _b !== void 0 ? _b : geometry.attributes.position.count;
        // clear the groups.
        geometry.clearGroups();
        // The offset in the index buffer of the end of the last
        // pushed group.
        let endOfLastGroup;
        objInfos.forEach((properties, featureIndex) => {
            var _a, _b;
            // the id of the current feature.
            const featureId = harp_datasource_protocol_1.getFeatureId(properties);
            let enabled = true;
            if (harp_datasource_protocol_1.Expr.isExpr(technique.enabled)) {
                // the state of current feature.
                const featureState = tile.dataSource.getFeatureState(featureId);
                // create a new {@link @here/harp-datasource-protocol#Env} that can be used
                // to evaluate expressions that access the feature state.
                const $state = featureState ? new harp_datasource_protocol_1.MapEnv(featureState) : null;
                const parentEnv = typeof properties === "object"
                    ? new harp_datasource_protocol_1.MapEnv(properties, this.m_env)
                    : this.m_env;
                const env = new harp_datasource_protocol_1.MapEnv({ $state }, parentEnv);
                enabled = Boolean(harp_datasource_protocol_1.getPropertyValue(technique.enabled, env));
            }
            if (!enabled) {
                // skip this feature, it was disabled.
                return;
            }
            // HARP-12247, geometry with no featureStarts would set start to `undefined`, in this
            // case, `endOfLastGroup` is also undefined (first execution in this loop), so it would
            // try to change the count of a group which hasn't yet been added, `addGroup` wasn't yet
            // called, hence we use the `??` operator and fall back to 0. Because featureStarts are
            // optional, we need to have a fallback.
            const start = (_a = starts[featureIndex]) !== null && _a !== void 0 ? _a : 0;
            const end = (_b = starts[featureIndex + 1]) !== null && _b !== void 0 ? _b : finalIndex;
            const count = end - start;
            if (start === endOfLastGroup) {
                // extend the last group
                geometry.groups[geometry.groups.length - 1].count += count;
            }
            else {
                geometry.addGroup(start, count);
            }
            endOfLastGroup = start + count;
        });
        return geometry.groups.length > 0;
    }
}
exports.TileObjectRenderer = TileObjectRenderer;
//# sourceMappingURL=TileObjectsRenderer.js.map