"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.FontCatalogLoader = exports.DEFAULT_FONT_CATALOG_NAME = void 0;
const harp_text_canvas_1 = require("@here/harp-text-canvas");
const harp_utils_1 = require("@here/harp-utils");
exports.DEFAULT_FONT_CATALOG_NAME = "default";
const logger = harp_utils_1.LoggerManager.instance.create("FontCatalogLoader");
class FontCatalogLoader {
    constructor(m_theme) {
        this.m_theme = m_theme;
        this.m_catalogsLoading = 0;
    }
    /**
     * Initializes font catalog loader.
     * @param defaultFontCatalogUrl - Url of the font catalog that will be used by default if the
     * theme doesn't define any font catalog.
     * @returns Name of the default font catalog.
     */
    initialize(defaultFontCatalogUrl) {
        if (this.m_theme.fontCatalogs === undefined || this.m_theme.fontCatalogs.length === 0) {
            this.m_theme.fontCatalogs = [
                {
                    name: exports.DEFAULT_FONT_CATALOG_NAME,
                    url: defaultFontCatalogUrl
                }
            ];
            return exports.DEFAULT_FONT_CATALOG_NAME;
        }
        const defaultFontCatalogName = this.m_theme.fontCatalogs[0].name;
        return defaultFontCatalogName;
    }
    async loadCatalogs(catalogCallback) {
        harp_utils_1.assert(this.m_theme.fontCatalogs !== undefined);
        harp_utils_1.assert(this.m_theme.fontCatalogs.length > 0);
        const promises = [];
        this.m_theme.fontCatalogs.forEach(fontCatalogConfig => {
            this.m_catalogsLoading += 1;
            const fontCatalogPromise = harp_text_canvas_1.FontCatalog.load(fontCatalogConfig.url, 1024)
                .then(catalogCallback.bind(undefined, fontCatalogConfig.name))
                .catch((error) => {
                logger.error("Failed to load FontCatalog: ", error);
            })
                .finally(() => {
                this.m_catalogsLoading -= 1;
            });
            promises.push(fontCatalogPromise);
        });
        return Promise.all(promises);
    }
    get loading() {
        return this.m_catalogsLoading > 0;
    }
}
exports.FontCatalogLoader = FontCatalogLoader;
//# sourceMappingURL=FontCatalogLoader.js.map