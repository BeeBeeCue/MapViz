import * as THREE from "three";
import { PickListener } from "../PickListener";
import { PoiManager } from "../poi/PoiManager";
import { PoiRendererFactory } from "../poi/PoiRendererFactory";
import { ScreenCollisions } from "../ScreenCollisions";
import { ScreenProjector } from "../ScreenProjector";
import { MapViewUtils } from "../Utils";
import { DataSourceTileList } from "../VisibleTileSet";
import { FontCatalogLoader } from "./FontCatalogLoader";
import { TextCanvasFactory } from "./TextCanvasFactory";
import { TextElement } from "./TextElement";
import { TextElementsRendererOptions } from "./TextElementsRendererOptions";
import { TextStyleCache } from "./TextStyleCache";
import { ViewState } from "./ViewState";
/**
 * Default distance scale. Will be applied if distanceScale is not defined in the technique.
 * Defines the scale that will be applied to labeled icons (icon and text) in the distance.
 * @internal
 */
export declare const DEFAULT_TEXT_DISTANCE_SCALE = 0.5;
export declare type ViewUpdateCallback = () => void;
/**
 *
 * Internal class to manage all text rendering.
 */
export declare class TextElementsRenderer {
    private readonly m_viewState;
    private readonly m_viewCamera;
    private readonly m_viewUpdateCallback;
    private readonly m_screenCollisions;
    private readonly m_screenProjector;
    private readonly m_textCanvasFactory;
    private readonly m_poiManager;
    private readonly m_poiRendererFactory;
    private readonly m_fontCatalogLoader;
    private readonly m_textStyleCache;
    private m_initialized;
    private m_initPromise;
    private m_glyphLoadingCount;
    private m_loadPromise;
    private readonly m_options;
    private readonly m_textRenderers;
    private m_overlayTextElements?;
    private m_debugGlyphTextureCacheMesh?;
    private m_debugGlyphTextureCacheWireMesh?;
    private readonly m_tmpVector;
    private readonly m_tmpVector3;
    private readonly m_cameraLookAt;
    private m_overloaded;
    private m_cacheInvalidated;
    private m_forceNewLabelsPass;
    private m_addNewLabels;
    private readonly m_textElementStateCache;
    /**
     * Create the `TextElementsRenderer` which selects which labels should be placed on screen as
     * a preprocessing step, which is not done every frame, and also renders the placed
     * {@link TextElement}s every frame.
     *
     * @param m_viewState - State of the view for which this renderer will draw text.
     * @param m_viewCamera - Camera used by the view for which this renderer will draw text.
     * @param m_viewUpdateCallback - To be called whenever the view needs to be updated.
     * @param m_screenCollisions - General 2D screen occlusion management, may be shared between
     *     instances.
     * @param m_screenProjector - Projects 3D coordinates into screen space.
     * @param m_textCanvasFactory - To create TextCanvas instances.
     * @param m_poiRendererFactory - To create PoiRenderer instances.
     * @param m_poiManager - To prepare pois for rendering.
     * @param m_fontCatalogLoader - To load font catalogs.
     * @param m_textStyleCache - Cache defining  text styles.
     * @param options - Configuration options for the text renderer. See
     * [[TextElementsRendererOptions]].
     */
    constructor(m_viewState: ViewState, m_viewCamera: THREE.Camera, m_viewUpdateCallback: ViewUpdateCallback, m_screenCollisions: ScreenCollisions, m_screenProjector: ScreenProjector, m_textCanvasFactory: TextCanvasFactory, m_poiManager: PoiManager, m_poiRendererFactory: PoiRendererFactory, m_fontCatalogLoader: FontCatalogLoader, m_textStyleCache: TextStyleCache, options: TextElementsRendererOptions);
    /**
     * Disable all fading animations (for debugging and performance measurement). Defaults to
     * `false`.
     */
    set disableFading(disable: boolean);
    get disableFading(): boolean;
    get styleCache(): TextStyleCache;
    get delayLabelsUntilMovementFinished(): boolean;
    set delayLabelsUntilMovementFinished(delay: boolean);
    /**
     * If `true`, a replacement glyph ("?") is rendered for every missing glyph.
     */
    get showReplacementGlyphs(): boolean;
    /**
     * If `true`, a replacement glyph ("?") is rendered for every missing glyph.
     */
    set showReplacementGlyphs(value: boolean);
    /**
     * Render the text using the specified camera into the current canvas.
     *
     * @param camera - Orthographic camera to use.
     */
    renderText(camera: THREE.OrthographicCamera): void;
    /**
     * Forces update of text elements in the next call to [[placeText]].
     */
    invalidateCache(): void;
    /**
     * Notify `TextElementsRenderer` that the camera has started a movement.
     */
    movementStarted(): void;
    /**
     * Notify `TextElementsRenderer` that the camera has finished its movement.
     */
    movementFinished(): void;
    /**
     * Is `true` if number of {@link TextElement}s in visible tiles is larger than the recommended
     * number `OVERLOAD_LABEL_LIMIT`.
     */
    get overloaded(): boolean;
    /**
     * Places text elements for the current frame.
     * @param dataSourceTileList - List of tiles to be rendered for each data source.
     * @param time - Current frame time.
     */
    placeText(dataSourceTileList: DataSourceTileList[], time: number): void;
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements - Array of {@link TextElement} to be added.
     */
    addOverlayText(textElements: TextElement[]): void;
    /**
     * Adds new overlay text elements to this `MapView`.
     *
     * @param textElements - Array of {@link TextElement} to be added.
     */
    clearOverlayText(): void;
    /**
     * @returns Whether there's overlay text to be rendered.
     */
    hasOverlayText(): boolean;
    get overlayText(): TextElement[] | undefined;
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * {@link TextElement}s are found, the order of the results is unspecified.
     *
     * Note: {@link TextElement}s with identical `featureId` or
     * identical `userData` will only appear
     * once in the list `pickResults`.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickResults - Array filled with pick results.
     */
    pickTextElements(screenPosition: THREE.Vector2, pickListener: PickListener): void;
    /**
     * `true` if any resource used by any `FontCatalog` is still loading.
     */
    get loading(): boolean;
    /**
     * Waits till all pending resources from any `FontCatalog` are loaded.
     */
    waitLoaded(): Promise<boolean>;
    /**
     * Reset the current text render states of all visible tiles.
     *
     * @remarks
     * All {@link TextElement}s will fade in
     * after that as if they have just been added.
     */
    clearRenderStates(): void;
    /**
     * Return memory used by all objects managed by `TextElementsRenderer`.
     *
     * @returns `MemoryUsage` Heap and GPU memory used by this `TextElementsRenderer`.
     */
    getMemoryUsage(): MapViewUtils.MemoryUsage;
    get initialized(): boolean;
    get initializing(): boolean;
    /**
     * Waits until initialization is done.
     * @returns Promise resolved to true if initialization was done, false otherwise.
     */
    waitInitialized(): Promise<boolean>;
    /**
     * Initializes the text renderer once there's any text element available for rendering.
     * @param textElementsAvailable - Indicates whether there's any text element to be rendered.
     * @returns Whether the text renderer is initialized.
     */
    private initialize;
    /**
     * Reset internal state at the beginning of a frame.
     */
    private reset;
    /**
     * Update state at the end of a frame.
     */
    private updateTextRenderers;
    /**
     * Fills the screen with lines projected from world space, see [[Tile.blockingElements]].
     * @note These boxes have highest priority, so will block all other labels.
     * @param dataSourceTileList - List of tiles to be rendered for each data source.
     */
    private prepopulateScreenWithBlockingElements;
    /**
     * @returns True if whole group was processed for placement,
     * false otherwise (e.g. placement limit reached).
     */
    private placeTextElementGroup;
    private initializeGlyphs;
    private initializeDefaultAssets;
    private initializeTextCanvases;
    private updateGlyphDebugMesh;
    private initializeGlyphDebugMesh;
    /**
     * Visit all visible tiles and add/ their text elements to cache.
     *
     * @remarks
     * The update of {@link TextElement}s is a time consuming process,
     * and cannot be done every frame, but should only
     * be done when the camera moved (a lot) of whenever the set of visible tiles change.
     *
     * The actually rendered {@link TextElement}s are stored internally
     * until the next update is done
     * to speed up rendering when no camera movement was detected.
     * @param dataSourceTileList - List of tiles to be rendered for each data source.
     */
    private updateTextElements;
    private updateTextElementsFromSource;
    private prepareTextElementGroup;
    private createSortedGroupsForSorting;
    private selectTextElementsToUpdateByDistance;
    private placeTextElements;
    private placeNewTextElements;
    private placeOverlayTextElements;
    private getDistanceScalingFactor;
    private getDistanceFadingFactor;
    private addPointLabel;
    private addPoiLabel;
    private addLineMarkerLabel;
    private addPathLabel;
    private checkIfOverloaded;
}
//# sourceMappingURL=TextElementsRenderer.d.ts.map