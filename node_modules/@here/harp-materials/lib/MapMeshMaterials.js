"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapMeshStandardMaterial = exports.MapMeshDepthMaterial = exports.MapMeshBasicMaterial = exports.ExtrusionFeatureMixin = exports.ExtrusionFeature = exports.FadingFeatureMixin = exports.FadingFeature = exports.DisplacementFeatureMixin = exports.hasExtrusionFeature = void 0;
const harp_utils_1 = require("@here/harp-utils");
const THREE = require("three");
const MapMeshMaterialsDefs_1 = require("./MapMeshMaterialsDefs");
const ExtrusionChunks_1 = require("./ShaderChunks/ExtrusionChunks");
const FadingChunks_1 = require("./ShaderChunks/FadingChunks");
const ShadowChunks_1 = require("./ShaderChunks/ShadowChunks");
const Utils_1 = require("./Utils");
const emptyTexture = new THREE.Texture();
/**
 * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into
 * [0..maxVisibilityRange].
 *
 * Copy from MapViewUtils, since it cannot be accessed here because of circular dependencies.
 *
 * @param distance - Distance from the camera (range: [0, 1]).
 * @param visibilityRange - object describing maximum and minimum visibility range - distances
 * from camera at which objects won't be rendered anymore.
 */
function cameraToWorldDistance(distance, visibilityRange) {
    return distance * visibilityRange.maximum;
}
/**
 * Provides common interface from mixin to internal material defines and shader uniforms.
 *
 * Call this function just after [THREE.Material] is constructed, so in derived classes after
 * super c-tor call.
 * @param mixin - The mixin that will add features to [[THREE.Material]].
 * @param material - The material that mixin feature is being applied.
 */
function linkMixinWithMaterial(mixin, material) {
    // Some materials (MeshBasicMaterial) have no defines property created in c-tor.
    // In such case create it manually, such defines will be also injected to the shader
    // via generic THREE.js code - see THREE/WebGLProgram.js.
    if (material.defines === undefined) {
        material.defines = {};
    }
    // Link internal THREE.js material defines with mixin reference.
    // Those defines are usually created in Material c-tor, if not we have fallback above.
    mixin.shaderDefines = material.defines;
    // Prepare map for holding uniforms references from the actual shader, but check if
    // it was not already created with other mixin feature.
    if (mixin.shaderUniforms === undefined) {
        mixin.shaderUniforms = {};
    }
    // Shader uniforms may not be linked at this stage, they are injected available via Shader
    // object in onBeforeCompile callback, see: linkMixinWithShader().
}
/**
 * Links mixin [[MixinShaderProperties.shaderUniforms]] with actual material shader uniforms.
 *
 * Function injects features (mixin) specific shader uniforms to material's shader, it also
 * updates uniforms references so [[MixinShaderProperties.shaderUniforms]] will contain full
 * uniforms map (both feature specific and internal ones).
 * This function should be called before material's shader is pre-compiled, so the new uniforms
 * from the mixin feature are known to shader processor. The best place to use is
 * [[Material.onBeforeCompile]].
 * @param mixin - The mixin feature being applied to the material.
 * @param shader - The actual shader linked to the [[THREE.Material]].
 */
function linkMixinWithShader(mixin, shader) {
    Object.assign(shader.uniforms, mixin.shaderUniforms);
    mixin.shaderUniforms = shader.uniforms;
}
/**
 * Determines whether a given material supports extrusion.
 * @param material The material to check.
 * @returns Whether the given material supports extrusion.
 */
function hasExtrusionFeature(material) {
    return "extrusionRatio" in material;
}
exports.hasExtrusionFeature = hasExtrusionFeature;
var DisplacementFeature;
(function (DisplacementFeature) {
    /**
     * Checks if feature is enabled (displacement map defined).
     *
     * @param displacementMaterial -
     */
    function isEnabled(displacementMaterial) {
        return displacementMaterial.displacementMap !== null;
    }
    DisplacementFeature.isEnabled = isEnabled;
    /**
     * Update the internals of the `DisplacementFeature` depending on the value of
     * [[displacementMap]].
     *
     * @param displacementMaterial - DisplacementFeature
     */
    function updateDisplacementFeature(displacementMaterial) {
        harp_utils_1.assert(displacementMaterial.shaderDefines !== undefined);
        harp_utils_1.assert(displacementMaterial.shaderUniforms !== undefined);
        const useDisplacementMap = isEnabled(displacementMaterial);
        // Whenever displacement feature state changes (between enabled/disabled) material will be
        // re-compiled, forcing new shader chunks to be added (or removed).
        const needsUpdate = Utils_1.setShaderDefine(displacementMaterial.shaderDefines, "USE_DISPLACEMENTMAP", useDisplacementMap);
        displacementMaterial.needsUpdate = needsUpdate;
        // Update texture after change.
        if (useDisplacementMap) {
            const texture = displacementMaterial.displacementMap;
            texture.needsUpdate = true;
            displacementMaterial.shaderUniforms.displacementMap.value = texture;
        }
        else if (needsUpdate) {
            displacementMaterial.shaderUniforms.displacementMap.value = emptyTexture;
        }
    }
    DisplacementFeature.updateDisplacementFeature = updateDisplacementFeature;
    /**
     * This function should be called on implementors of DisplacementFeature in the
     * `onBeforeCompile` callback of that material. It adds the required code to the shaders to
     * apply displacement maps.
     *
     * @param displacementMaterial - Material to add uniforms to.
     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(displacementMaterial, shader) {
        if (!isEnabled(displacementMaterial)) {
            return;
        }
        harp_utils_1.assert(displacementMaterial.shaderUniforms !== undefined);
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them.
        //
        // The object "defines" are required for this material, we use one define working as a flag,
        // which enables/disables some chunks of shader code.
        linkMixinWithShader(displacementMaterial, shader);
        // Append the displacement map chunk to the vertex shader.
        shader.vertexShader = shader.vertexShader.replace("#include <skinbase_vertex>", `#include <skinbase_vertex>
#ifndef USE_ENVMAP
    vec3 objectNormal = vec3( normal );
#endif`);
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "uv2_pars_vertex", "displacementmap_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "skinning_vertex", "displacementmap_vertex", true);
    }
    DisplacementFeature.onBeforeCompile = onBeforeCompile;
})(DisplacementFeature || (DisplacementFeature = {}));
class DisplacementFeatureMixin {
    constructor() {
        this.m_displacementMap = null;
    }
    // This is here to keep tslint from reporting a missing property, the getter that's actually
    // used by materials is added in [[addDisplacementProperties]].
    get displacementMap() {
        return this.m_displacementMap;
    }
    // This is here to keep tslint from reporting a missing property, the setter that's actually
    // used by materials is added in [[addDisplacementProperties]].
    set displacementMap(map) {
        this.setDisplacementMap(map);
    }
    getDisplacementMap() {
        return this.m_displacementMap;
    }
    setDisplacementMap(map) {
        if (map !== this.m_displacementMap) {
            this.m_displacementMap = map;
            DisplacementFeature.updateDisplacementFeature(this);
        }
    }
    /**
     * The mixin class should call this method to register the property [[displacementMap]]
     */
    addDisplacementProperties() {
        Object.defineProperty(this, "displacementMap", {
            get: () => {
                return this.getDisplacementMap();
            },
            set: val => {
                this.setDisplacementMap(val);
            }
        });
    }
    /**
     * Apply the displacementMap value from the parameters to the respective properties.
     */
    applyDisplacementParameters(params) {
        linkMixinWithMaterial(this, this);
        harp_utils_1.assert(this.shaderDefines !== undefined);
        harp_utils_1.assert(this.shaderUniforms !== undefined);
        // Create uniforms with default values, this ensures they are always set created,
        // so no need for checks in setters.
        const uniforms = this.shaderUniforms;
        uniforms.displacementMap = new THREE.Uniform(emptyTexture);
        uniforms.displacementScale = new THREE.Uniform(1);
        uniforms.displacementBias = new THREE.Uniform(0);
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.displacementMap !== undefined) {
                this.setDisplacementMap(params.displacementMap);
            }
        }
        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {
            DisplacementFeature.onBeforeCompile(this, shader);
        });
        // Require material update at least once, because of new shader chunks added.
        this.needsUpdate = DisplacementFeature.isEnabled(this);
    }
    /**
     * Copy displacementMap from other DisplacementFeature.
     *
     * @param source - The material to copy property values from.
     */
    copyDisplacementParameters(source) {
        this.setDisplacementMap(source.displacementMap);
        return this;
    }
}
exports.DisplacementFeatureMixin = DisplacementFeatureMixin;
/**
 * Namespace with support functions for implementors of `FadingFeature`.
 */
var FadingFeature;
(function (FadingFeature) {
    FadingFeature.DEFAULT_FADE_NEAR = -1.0;
    FadingFeature.DEFAULT_FADE_FAR = -1.0;
    /**
     * Checks if feature is enabled based on feature params.
     *
     * Fading feature will be disabled if fadeFar is undefined or fadeFar <= 0.0.
     * This function is crucial for shader switching (chunks injection), whenever feature state
     * changes between enabled/disabled. Current approach is to keep feature on (once enabled)
     * whenever fading params are reasonable, even if it causes full fade in, no transparency.
     *
     * @param fadingMaterial - FadingFeature.
     */
    function isEnabled(fadingMaterial) {
        // NOTE: We could also check if full fade is not achieved, then feature could be
        // disabled, but causing material re-compile.
        return (fadingMaterial.fadeNear !== undefined &&
            fadingMaterial.fadeFar !== undefined &&
            fadingMaterial.fadeFar > 0);
    }
    FadingFeature.isEnabled = isEnabled;
    /**
     * Checks if feature is defined based on feature params.
     *
     * Fading feature will be defined if fadeNear and fadeFar are defined, their values
     * are not checked for reasonable values.
     *
     * @param fadingMaterial FadingFeature.
     */
    function isDefined(fadingMaterial) {
        return fadingMaterial.fadeNear !== undefined && fadingMaterial.fadeFar !== undefined;
    }
    FadingFeature.isDefined = isDefined;
    /**
     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.
     */
    function patchGlobalShaderChunks() {
        if (THREE.ShaderChunk.fading_pars_vertex === undefined) {
            Object.assign(THREE.ShaderChunk, FadingChunks_1.default);
        }
    }
    FadingFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;
    /**
     * Update the internals of the `FadingFeature` depending on the value of [[fadeNear]]. The
     * fading feature will be disabled if fadeFar <= 0.0.
     *
     * @param fadingMaterial - FadingFeature
     */
    function updateFadingFeature(fadingMaterial) {
        harp_utils_1.assert(fadingMaterial.shaderDefines !== undefined);
        harp_utils_1.assert(fadingMaterial.shaderUniforms !== undefined);
        // Update entire material to add/remove shader fading chunks, this happens when we
        // enable/disable fading after material creation. Feature is marked via dummy define, which
        // informs about fading feature state, even if such define is not required to control
        // feature state, it makes it easy to check for shader changes.
        const useFading = isEnabled(fadingMaterial);
        const needsUpdate = Utils_1.setShaderDefine(fadingMaterial.shaderDefines, "FADING_MATERIAL", useFading);
        // Enable/disable entire feature with material re-compile, this will also cause
        // new uniforms injection.
        fadingMaterial.needsUpdate = needsUpdate;
        // Check if shader uniforms references are already set in onBeforeCompile callback.
        harp_utils_1.assert(fadingMaterial.shaderUniforms.fadeNear !== undefined &&
            fadingMaterial.shaderUniforms.fadeFar !== undefined);
        // Update shader internal uniforms only if fading is enabled.
        if (useFading) {
            fadingMaterial.shaderUniforms.fadeNear.value = fadingMaterial.fadeNear;
            fadingMaterial.shaderUniforms.fadeFar.value = fadingMaterial.fadeFar;
            if (needsUpdate) {
                Utils_1.enableBlending(fadingMaterial);
            }
        }
        // Perform one time update of uniforms to defaults when feature disabled (for clarity).
        else if (needsUpdate) {
            fadingMaterial.shaderUniforms.fadeNear.value = FadingFeature.DEFAULT_FADE_NEAR;
            fadingMaterial.shaderUniforms.fadeFar.value = FadingFeature.DEFAULT_FADE_FAR;
            Utils_1.disableBlending(fadingMaterial);
        }
    }
    FadingFeature.updateFadingFeature = updateFadingFeature;
    /**
     * This function should be called on implementors of FadingFeature in the `onBeforeCompile`
     * callback of that material. It adds the required code to the shaders and declares the new
     * uniforms that control fading based on view distance.
     *
     * @param fadingMaterial - Material to add uniforms to.
     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(fadingMaterial, shader) {
        if (!isEnabled(fadingMaterial)) {
            return;
        }
        harp_utils_1.assert(fadingMaterial.shaderUniforms !== undefined);
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them.
        //
        // The object "defines" are not required for this material, so the fading shader chunks
        // have no #ifdef preprocessed chunks. Feature utilized one define just to denote feature
        // attached and easy control its state, but this define may be stripped out if needed.
        linkMixinWithShader(fadingMaterial, shader);
        // Append the new fading shader cod directly after the fog code. This is done by adding an
        // include directive for the fading code.
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "fog_pars_vertex", "fading_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "fog_vertex", "fading_vertex", true);
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "fading_pars_fragment");
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_fragment", "fading_fragment", true);
    }
    FadingFeature.onBeforeCompile = onBeforeCompile;
    /**
     * As three.js is rendering the transparent objects last (internally), regardless of their
     * renderOrder value, we set the transparent value to false in the [[onAfterRenderCall]]. In
     * [[onBeforeRender]], the function [[calculateDepthFromCameraDistance]] sets it to true if the
     * fade distance value is less than 1.
     *
     * @param object - [[THREE.Object3D]] to prepare for rendering.
     * @param viewRanges - The visibility ranges (clip planes and maximum visible distance) for
     * actual camera setup.
     * @param fadeNear - The fadeNear value to set in the material.
     * @param fadeFar - The fadeFar value to set in the material.
     * @param updateUniforms - If `true`, the fading uniforms are set. Not required if material is
     *          handling the uniforms already, like in a [[THREE.ShaderMaterial]].
     * @param additionalCallback - If defined, this function will be called before the function will
     *          return.
     */
    function addRenderHelper(object, viewRanges, fadeNear, fadeFar, updateUniforms, additionalCallback) {
        object.onBeforeRender = harp_utils_1.chainCallbacks(object.onBeforeRender, (renderer, scene, camera, geometry, material, group) => {
            const fadingMaterial = material;
            fadingMaterial.fadeNear =
                fadeNear === undefined || fadeNear === FadingFeature.DEFAULT_FADE_NEAR
                    ? FadingFeature.DEFAULT_FADE_NEAR
                    : cameraToWorldDistance(fadeNear, viewRanges);
            fadingMaterial.fadeFar =
                fadeFar === undefined || fadeFar === FadingFeature.DEFAULT_FADE_FAR
                    ? FadingFeature.DEFAULT_FADE_FAR
                    : cameraToWorldDistance(fadeFar, viewRanges);
            if (additionalCallback !== undefined) {
                additionalCallback(renderer, material);
            }
        });
    }
    FadingFeature.addRenderHelper = addRenderHelper;
})(FadingFeature = exports.FadingFeature || (exports.FadingFeature = {}));
/**
 * Mixin class for extended THREE materials. Adds new properties required for `fadeNear` and
 * `fadeFar`. There is some special handling for the fadeNear/fadeFar properties, which get some
 * setters and getters in a way that works well with the mixin.
 *
 * @see [[Tile#addRenderHelper]]
 */
class FadingFeatureMixin {
    constructor() {
        this.m_fadeNear = FadingFeature.DEFAULT_FADE_NEAR;
        this.m_fadeFar = FadingFeature.DEFAULT_FADE_FAR;
    }
    /**
     * @see [[FadingFeature#fadeNear]]
     */
    getFadeNear() {
        return this.m_fadeNear;
    }
    /**
     * @see [[FadingFeature#fadeNear]]
     */
    setFadeNear(value) {
        const needsUpdate = value !== this.m_fadeNear;
        if (needsUpdate) {
            this.m_fadeNear = value;
            FadingFeature.updateFadingFeature(this);
        }
    }
    /**
     * @see [[FadingFeature#fadeFar]]
     */
    getFadeFar() {
        return this.m_fadeFar;
    }
    /**
     * @see [[FadingFeature#fadeFar]]
     */
    setFadeFar(value) {
        const needsUpdate = value !== this.m_fadeFar;
        if (needsUpdate) {
            this.m_fadeFar = value;
            FadingFeature.updateFadingFeature(this);
        }
    }
    /**
     * The mixin classes should call this method to register the properties [[fadeNear]] and
     * [[fadeFar]].
     */
    addFadingProperties() {
        Object.defineProperty(this, "fadeNear", {
            get: () => {
                return this.getFadeNear();
            },
            set: val => {
                this.setFadeNear(val);
            }
        });
        Object.defineProperty(this, "fadeFar", {
            get: () => {
                return this.getFadeFar();
            },
            set: val => {
                this.setFadeFar(val);
            }
        });
    }
    /**
     * Apply the fadeNear/fadeFar values from the parameters to the respective properties.
     *
     * @param params - `FadingMeshBasicMaterial` parameters.
     */
    applyFadingParameters(params) {
        // Prepare maps for holding uniforms and defines references from the actual material.
        linkMixinWithMaterial(this, this);
        harp_utils_1.assert(this.shaderDefines !== undefined);
        harp_utils_1.assert(this.shaderUniforms !== undefined);
        // Create uniforms with default values, this ensures they are always set created,
        // so no need for checks in setters.
        this.shaderUniforms.fadeNear = new THREE.Uniform(FadingFeature.DEFAULT_FADE_NEAR);
        this.shaderUniforms.fadeFar = new THREE.Uniform(FadingFeature.DEFAULT_FADE_FAR);
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.fadeNear !== undefined) {
                this.setFadeNear(params.fadeNear);
            }
            if (params.fadeFar !== undefined) {
                this.setFadeFar(params.fadeFar);
            }
        }
        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {
            FadingFeature.onBeforeCompile(this, shader);
        });
        // Update (re-compile) shader code to include new shader chunks only if feature is enabled.
        this.needsUpdate = FadingFeature.isEnabled(this);
    }
    /**
     * Copy fadeNear/fadeFar values from other FadingFeature.
     *
     * @param source - The material to copy property values from.
     */
    copyFadingParameters(source) {
        this.setFadeNear(source.fadeNear === undefined ? FadingFeature.DEFAULT_FADE_NEAR : source.fadeNear);
        this.setFadeFar(source.fadeFar === undefined ? FadingFeature.DEFAULT_FADE_FAR : source.fadeFar);
        return this;
    }
}
exports.FadingFeatureMixin = FadingFeatureMixin;
var ExtrusionFeature;
(function (ExtrusionFeature) {
    /**
     * Checks if feature is enabled based on {@link ExtrusionFeature} properties.
     *
     * @param extrusionMaterial -
     */
    function isEnabled(extrusionMaterial) {
        return (extrusionMaterial.extrusionRatio !== undefined &&
            extrusionMaterial.extrusionRatio >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN);
    }
    ExtrusionFeature.isEnabled = isEnabled;
    /**
     * Patch the THREE.ShaderChunk on first call with some extra shader chunks.
     */
    function patchGlobalShaderChunks() {
        if (THREE.ShaderChunk.extrusion_pars_vertex === undefined) {
            Object.assign(THREE.ShaderChunk, ExtrusionChunks_1.default);
        }
    }
    ExtrusionFeature.patchGlobalShaderChunks = patchGlobalShaderChunks;
    /**
     * Update the internals of the `ExtrusionFeature` depending on the value of [[extrusionRatio]].
     *
     * @param ExtrusionMaterial - ExtrusionFeature
     */
    function updateExtrusionFeature(extrusionMaterial) {
        harp_utils_1.assert(extrusionMaterial.shaderDefines !== undefined);
        harp_utils_1.assert(extrusionMaterial.shaderUniforms !== undefined);
        // Setup shader define that when changed will force material re-compile.
        const useExtrusion = isEnabled(extrusionMaterial);
        // Use shader define as marker if feature is enabled/disabled, this is not necessary
        // required, but material requires update (re-compile) anyway to add/remove shader chunks.
        const needsUpdate = Utils_1.setShaderDefine(extrusionMaterial.shaderDefines, "EXTRUSION_MATERIAL", useExtrusion);
        // Enable/disable entire feature with material re-compile.
        extrusionMaterial.needsUpdate = needsUpdate;
        // Update uniform with new value
        if (useExtrusion) {
            extrusionMaterial.shaderUniforms.extrusionRatio.value =
                extrusionMaterial.extrusionRatio;
        }
        // Reset uniform to default, one time only, when feature is disabled (just for clarity).
        else if (needsUpdate) {
            extrusionMaterial.shaderUniforms.extrusionRatio.value =
                MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
        }
    }
    ExtrusionFeature.updateExtrusionFeature = updateExtrusionFeature;
    /**
     * This function should be called on implementors of ExtrusionFeature in the `onBeforeCompile`
     * callback of that material. It adds the required code to the shaders and declares the new
     * uniforms that control extrusion.
     *
     * @param extrusionMaterial - Material to add uniforms to.
     * @param shader - [[THREE.WebGLShader]] containing the vertex and fragment shaders to add the
     *                  special includes to.
     */
    function onBeforeCompile(extrusionMaterial, shader) {
        if (!isEnabled(extrusionMaterial)) {
            return;
        }
        harp_utils_1.assert(extrusionMaterial.shaderUniforms !== undefined);
        // The vertex and fragment shaders have been constructed dynamically. The uniforms and
        // the shader includes are now appended to them. No defines are required to preprocess
        // shader chunks, but we utilize one just to note the feature is enabled/disabled
        // (easier debugging), this define may be easily stripped out or replaced with simple
        // boolean flag.
        linkMixinWithShader(extrusionMaterial, shader);
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "common", "extrusion_pars_vertex");
        shader.vertexShader = Utils_1.insertShaderInclude(shader.vertexShader, "begin_vertex", "extrusion_vertex", true);
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_pars_fragment", "extrusion_pars_fragment");
        shader.fragmentShader = shader.fragmentShader.replace("#include <normal_fragment_begin>", "#include <extrusion_normal_fragment_begin>");
        shader.fragmentShader = Utils_1.insertShaderInclude(shader.fragmentShader, "fog_fragment", "extrusion_fragment", true);
    }
    ExtrusionFeature.onBeforeCompile = onBeforeCompile;
})(ExtrusionFeature = exports.ExtrusionFeature || (exports.ExtrusionFeature = {}));
/**
 * Mixin class for extended THREE materials. Adds new properties required for `extrusionRatio`.
 *
 * @remarks
 * There is some special handling for the extrusionRatio property, which is animated via
 * {@link @here/harp-mapview#AnimatedExtrusionHandler} that is
 * using [[extrusionRatio]] setter and getter to update
 * extrusion in a way that works well with the mixin and EdgeMaterial.
 */
class ExtrusionFeatureMixin {
    constructor() {
        this.m_extrusion = MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    /**
     * @see [[ExtrusionFeature#extrusion]]
     */
    getExtrusionRatio() {
        return this.m_extrusion;
    }
    /**
     * @see [[ExtrusionFeature#extrusion]]
     */
    setExtrusionRatio(value) {
        const needsUpdate = value !== this.m_extrusion;
        if (needsUpdate) {
            this.m_extrusion = value;
            ExtrusionFeature.updateExtrusionFeature(this);
        }
    }
    /**
     * The mixin class should call this method to register the property [[extrusionRatio]]
     */
    addExtrusionProperties() {
        Object.defineProperty(this, "extrusionRatio", {
            get: () => {
                return this.getExtrusionRatio();
            },
            set: val => {
                this.setExtrusionRatio(val);
            }
        });
    }
    /**
     * Apply the extrusionRatio value from the parameters to the respective properties.
     */
    applyExtrusionParameters(params) {
        // Prepare maps for holding uniforms and defines references from the actual material.
        linkMixinWithMaterial(this, this);
        harp_utils_1.assert(this.shaderDefines !== undefined);
        harp_utils_1.assert(this.shaderUniforms !== undefined);
        if (params && params.zFightingWorkaround === true) {
            this.shaderDefines.ZFIGHTING_WORKAROUND = "";
        }
        // Create uniform with default value, this ensures that it is always created,
        // so no need for checks in setters.
        this.shaderUniforms.extrusionRatio = new THREE.Uniform(MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX);
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.extrusionRatio !== undefined) {
                this.setExtrusionRatio(params.extrusionRatio);
            }
        }
        this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, (shader) => {
            ExtrusionFeature.onBeforeCompile(this, shader);
        });
        this.needsUpdate = ExtrusionFeature.isEnabled(this);
    }
    /**
     * Copy extrusionRatio values from other ExtrusionFeature.
     *
     * @param source - The material to copy property values from.
     */
    copyExtrusionParameters(source) {
        if (source.extrusionRatio !== undefined) {
            this.setExtrusionRatio(source.extrusionRatio);
        }
        return this;
    }
}
exports.ExtrusionFeatureMixin = ExtrusionFeatureMixin;
/**
 * Subclass of [[THREE.MeshBasicMaterial]]. Adds new properties required for [[fadeNear]] and
 * [[fadeFar]]. In addition to the new properties (which update their respective uniforms), it is
 * also required to update the material in their objects [[onBeforeRender]] and [[OnAfterRender]]
 * calls, where their flag [[transparent]] is set and the internal fadeNear/fadeFar values are
 * updated to world space distances.
 *
 * @see [[Tile#addRenderHelper]]
 */
class MapMeshBasicMaterial extends THREE.MeshBasicMaterial {
    /**
     * Constructs a new `FadingMeshBasicMaterial`.
     *
     * @param params - `FadingMeshBasicMaterial` parameters.
     */
    constructor(params) {
        super(params);
        FadingFeature.patchGlobalShaderChunks();
        this.addFadingProperties();
        this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: true }));
        this.addDisplacementProperties();
        this.applyDisplacementParameters(params);
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    clone() {
        return new MapMeshBasicMaterial().copy(this);
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    copy(source) {
        super.copy(source);
        this.copyFadingParameters(source);
        this.copyExtrusionParameters(source);
        this.copyDisplacementParameters(source);
        return this;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in FadingFeatureMixin and ExtrusionFeatureMixin, see below:
    //
    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);
    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);
    //
    // Mixin declarations start ---------------------------------------------------------
    get fadeNear() {
        return FadingFeature.DEFAULT_FADE_NEAR;
    }
    set fadeNear(value) {
        // to be overridden
    }
    get fadeFar() {
        return FadingFeature.DEFAULT_FADE_FAR;
    }
    set fadeFar(value) {
        // to be overridden
    }
    get extrusionRatio() {
        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    set extrusionRatio(value) {
        // to be overridden
    }
    get displacementMap() {
        return null;
    }
    set displacementMap(value) {
        // to be overridden
    }
    setDisplacementMap(value) {
        // to be overridden
    }
    addFadingProperties() {
        // to be overridden
    }
    applyFadingParameters(params) {
        // to be overridden
    }
    copyFadingParameters(source) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    applyExtrusionParameters(params) {
        // to be overridden
    }
    copyExtrusionParameters(source) {
        // to be overridden
    }
    addDisplacementProperties() {
        // to be overridden
    }
    applyDisplacementParameters(params) {
        // to be overridden
    }
    copyDisplacementParameters(source) {
        // to be overridden
    }
}
exports.MapMeshBasicMaterial = MapMeshBasicMaterial;
class MapMeshDepthMaterial extends THREE.MeshDepthMaterial {
    constructor(params) {
        super(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        // We need to set these to false, because otherwise three.js complains that there are
        // outputs of the vertex shader not used in the pixel shader, the properties in question
        // are `vExtrusionRatio` and `vExtrusionAxis`.
        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: false }));
        this.flatShading = false;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in{@link ExtrusionFeatureMixin}, see below:
    //
    // applyMixinsWithoutProperties(...);
    //
    // Mixin declarations start ---------------------------------------------------------
    get extrusionRatio() {
        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    set extrusionRatio(value) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    applyExtrusionParameters(params) {
        // to be overridden
    }
    copyExtrusionParameters(source) {
        // to be overridden
    }
}
exports.MapMeshDepthMaterial = MapMeshDepthMaterial;
/**
 * Subclass of THREE.MeshStandardMaterial. Adds new properties required for `fadeNear` and
 * `fadeFar`. In addition to the new properties (which fill respective uniforms), it is also
 * required to update the material in their objects `onBeforeRender` and `OnAfterRender` calls,
 * where their flag `transparent` is set and the internal fadeNear/fadeFar values are updated to
 * world space distances.
 *
 * @see [[Tile#addRenderHelper]]
 */
class MapMeshStandardMaterial extends THREE.MeshStandardMaterial {
    /**
     * Constructs a new `FadingMeshStandardMaterial`.
     *
     * @param params - `FadingMeshStandardMaterial` parameters.
     */
    constructor(params) {
        super(params);
        FadingFeature.patchGlobalShaderChunks();
        this.addFadingProperties();
        this.applyFadingParameters(params);
        ExtrusionFeature.patchGlobalShaderChunks();
        this.addExtrusionProperties();
        this.applyExtrusionParameters(Object.assign(Object.assign({}, params), { zFightingWorkaround: true }));
        if ((params === null || params === void 0 ? void 0 : params.removeDiffuseLight) === true) {
            this.onBeforeCompile = harp_utils_1.chainCallbacks(this.onBeforeCompile, shaderParameters => {
                const shader = shaderParameters;
                shader.fragmentShader = THREE.ShaderChunk.meshphysical_frag.replace("#include <lights_physical_pars_fragment>", ShadowChunks_1.simpleLightingShadowChunk);
            });
        }
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    clone() {
        return new MapMeshStandardMaterial().copy(this);
    }
    // overrides with THREE.js base classes are not recognized by tslint.
    copy(source) {
        super.copy(source);
        this.copyFadingParameters(source);
        this.copyExtrusionParameters(source);
        return this;
    }
    /** @override */
    get displacementMap() {
        return super.displacementMap === undefined ? null : super.displacementMap;
    }
    /** @override */
    set displacementMap(map) {
        if (map === this.displacementMap) {
            return;
        }
        if (!map || !this.displacementMap) {
            this.needsUpdate = true;
        }
        if (map) {
            map.needsUpdate = true;
        }
        super.displacementMap = map;
    }
    // Only here to make the compiler happy, these methods will be overriden: The actual
    // implementations are those in FadingFeatureMixin and ExtrusionFeatureMixin, see below:
    //
    // applyMixinsWithoutProperties(FadingMeshBasicMaterial, [FadingFeatureMixin]);
    // applyMixinsWithoutProperties(ExtrudionMeshBasicMaterial, [ExtrusionFeatureMixin]);
    //
    // Mixin declarations start ---------------------------------------------------------
    get fadeNear() {
        return FadingFeature.DEFAULT_FADE_NEAR;
    }
    set fadeNear(value) {
        // to be overridden
    }
    get fadeFar() {
        return FadingFeature.DEFAULT_FADE_FAR;
    }
    set fadeFar(value) {
        // to be overridden
    }
    get extrusionRatio() {
        return MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
    }
    set extrusionRatio(value) {
        // to be overridden
    }
    /**
     * This is needed to simplify the lighting calculation, currently there is no support for
     * switching this at runtime. It is required here to be a property because the parameters
     * are applied to this material, and if this isn't here, three.js will complain that the
     * property is missing.
     * @internal
     */
    get removeDiffuseLight() {
        return false;
    }
    /** @internal */
    set removeDiffuseLight(val) {
        // Stays empty.
    }
    addFadingProperties() {
        // to be overridden
    }
    applyFadingParameters(params) {
        // to be overridden
    }
    copyFadingParameters(source) {
        // to be overridden
    }
    addExtrusionProperties() {
        // to be overridden
    }
    applyExtrusionParameters(params) {
        // to be overridden
    }
    copyExtrusionParameters(source) {
        // to be overridden
    }
}
exports.MapMeshStandardMaterial = MapMeshStandardMaterial;
/**
 * Finish the classes MapMeshBasicMaterial and MapMeshStandardMaterial by assigning them the actual
 * implementations of the mixed in functions.
 */
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [FadingFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [FadingFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshStandardMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshDepthMaterial, [ExtrusionFeatureMixin]);
harp_utils_1.applyMixinsWithoutProperties(MapMeshBasicMaterial, [DisplacementFeatureMixin]);
//# sourceMappingURL=MapMeshMaterials.js.map