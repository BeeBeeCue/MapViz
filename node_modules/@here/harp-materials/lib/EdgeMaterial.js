"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.EdgeMaterial = void 0;
const THREE = require("three");
const MapMeshMaterials_1 = require("./MapMeshMaterials");
const MapMeshMaterialsDefs_1 = require("./MapMeshMaterialsDefs");
const RawShaderMaterial_1 = require("./RawShaderMaterial");
const Utils_1 = require("./Utils");
const vertexSource = `
#define EDGE_DEPTH_OFFSET 0.0001

#ifdef USE_COLOR
attribute vec4 color;
#else
uniform vec3 color;
#endif

// SHADER_NAME may be defined by THREE.JS own shaders in which case these attributes & uniforms are
// already defined
#ifndef SHADER_NAME
attribute vec3 position;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat3 normalMatrix;
#endif

uniform vec3 edgeColor;
uniform float edgeColorMix;

#ifdef USE_DISPLACEMENTMAP
attribute vec3 normal;
attribute vec2 uv;
uniform sampler2D displacementMap;
#endif

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_vertex>
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

void main() {

    vColor = mix(edgeColor.rgb, color.rgb, edgeColorMix);

    vec3 transformed = vec3( position );

    #ifdef USE_EXTRUSION
    #include <extrusion_vertex>
    #endif

    #ifdef USE_DISPLACEMENTMAP
    transformed += normalize( normal ) * texture2D( displacementMap, uv ).x;
    #endif

    vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );

    gl_Position = projectionMatrix * mvPosition;
    // After projection gl_Position contains clip space coordinates of each vertex
    // before perspective division (1 / w), thus only vertexes with -w < z < w should
    // be displayed and offset. We offset only those edges which z coordinate in NDC
    // space is between: -inf < z < 1
    float depthOffset = step(-1.0, -gl_Position.z / gl_Position.w) * EDGE_DEPTH_OFFSET;
    gl_Position.z -= depthOffset;

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif
}`;
const fragmentSource = `
precision highp float;
precision highp int;

varying vec3 vColor;

#ifdef USE_EXTRUSION
#include <extrusion_pars_fragment>
#endif

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

void main() {
    float alphaValue = 1.0;
    gl_FragColor = vec4(vColor, alphaValue);

    #ifdef USE_EXTRUSION
    #include <extrusion_fragment>
    #endif

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif
}`;
/**
 * Material designed to render the edges of extruded buildings using GL_LINES. It supports solid
 * colors, vertex colors, color mixing and distance fading.
 */
class EdgeMaterial extends RawShaderMaterial_1.RawShaderMaterial {
    /**
     * Constructs a new `EdgeMaterial`.
     *
     * @param params - `EdgeMaterial` parameters. Always required except when cloning another
     * material.
     */
    constructor(params) {
        var _a;
        let shaderParams;
        if (params) {
            const defines = {};
            const hasExtrusion = params.extrusionRatio !== undefined &&
                params.extrusionRatio >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN &&
                params.extrusionRatio < MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX;
            if (params.displacementMap) {
                Utils_1.setShaderDefine(defines, "USE_DISPLACEMENTMAP", true);
            }
            if (hasExtrusion) {
                Utils_1.setShaderDefine(defines, "USE_EXTRUSION", true);
            }
            if (params.vertexColors === true) {
                Utils_1.setShaderDefine(defines, "USE_COLOR", true);
            }
            shaderParams = {
                name: "EdgeMaterial",
                vertexShader: vertexSource,
                fragmentShader: fragmentSource,
                uniforms: {
                    color: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),
                    edgeColor: new THREE.Uniform(new THREE.Color(EdgeMaterial.DEFAULT_COLOR)),
                    edgeColorMix: new THREE.Uniform(EdgeMaterial.DEFAULT_COLOR_MIX),
                    fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),
                    fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),
                    extrusionRatio: new THREE.Uniform(MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MAX),
                    displacementMap: new THREE.Uniform((_a = params.displacementMap) !== null && _a !== void 0 ? _a : new THREE.Texture())
                },
                depthWrite: false,
                defines,
                rendererCapabilities: params.rendererCapabilities
            };
        }
        super(shaderParams);
        Utils_1.enforceBlending(this);
        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();
        MapMeshMaterials_1.ExtrusionFeature.patchGlobalShaderChunks();
        // Apply initial parameter values.
        if (params !== undefined) {
            if (params.color !== undefined) {
                // Color may be set directly on object (omitting class setter), because we already
                // know that is does no require any special handling nor material update
                // (see: set color()).
                this.color.set(params.color);
            }
            if (params.colorMix !== undefined) {
                this.colorMix = params.colorMix;
            }
            if (params.fadeNear !== undefined) {
                this.fadeNear = params.fadeNear;
            }
            if (params.fadeFar !== undefined) {
                this.fadeFar = params.fadeFar;
            }
            if (params.displacementMap !== undefined) {
                this.displacementMap = params.displacementMap;
            }
            if (params.extrusionRatio !== undefined) {
                this.extrusionRatio = params.extrusionRatio;
            }
        }
    }
    /**
     * The color of the object that is rendered
     * together with this edge.
     *
     * @remarks
     * The final color of the edge is computed by
     * interpolating the {@link edgeColor} with this color
     * using the {@link colorMix} factor.
     *
     * Note that {@link objectColor} is used only
     * when the geometry associated with this material
     * does not have a vertex color buffer.
     *
     */
    get objectColor() {
        return this.uniforms.color.value;
    }
    set objectColor(value) {
        this.uniforms.color.value.copy(value);
    }
    /**
     * Edge color.
     */
    get color() {
        return this.uniforms.edgeColor.value;
    }
    set color(value) {
        this.uniforms.edgeColor.value.copy(value);
    }
    get lineWidth() {
        return this.linewidth;
    }
    /**
     * Only lineWidth of 0 and 1 is supported.
     * lineWidth <= 0 will result in not visible lines, everything else into lines
     * visible with lineWidth 1
     */
    set lineWidth(value) {
        this.linewidth = value;
        if (this.linewidth <= 0) {
            this.visible = false;
        }
        else {
            this.visible = true;
        }
    }
    /**
     * Color mix value. Mixes between vertexColors and edgeColor.
     */
    get colorMix() {
        return this.uniforms.edgeColorMix.value;
    }
    set colorMix(value) {
        if (this.uniforms.edgeColorMix.value === value) {
            return;
        }
        this.uniforms.edgeColorMix.value = value;
    }
    get fadeNear() {
        return this.uniforms.fadeNear.value;
    }
    set fadeNear(value) {
        this.uniforms.fadeNear.value = value;
    }
    get fadeFar() {
        return this.uniforms.fadeFar.value;
    }
    set fadeFar(value) {
        if (this.uniforms.fadeFar.value === value) {
            return;
        }
        this.uniforms.fadeFar.value = value;
        Utils_1.setShaderMaterialDefine(this, "USE_FADING", value > 0.0);
    }
    get extrusionRatio() {
        return this.uniforms.extrusionRatio.value;
    }
    set extrusionRatio(value) {
        if (this.uniforms.extrusionRatio.value === value) {
            return;
        }
        this.uniforms.extrusionRatio.value = value;
        // NOTE: We could also disable shader extrusion chunks when it hits
        // ExtrusionFeatureDefs.DEFAULT_RATIO_MAX value, but this would cause shader re-compile.
        const useExtrusion = value >= MapMeshMaterialsDefs_1.ExtrusionFeatureDefs.DEFAULT_RATIO_MIN;
        Utils_1.setShaderMaterialDefine(this, "USE_EXTRUSION", useExtrusion);
    }
    get displacementMap() {
        return this.uniforms.displacementMap.value;
    }
    set displacementMap(map) {
        if (this.uniforms.displacementMap.value === map) {
            return;
        }
        this.uniforms.displacementMap.value = map;
        const useDisplacementMap = map !== null;
        if (useDisplacementMap) {
            this.uniforms.displacementMap.value.needsUpdate = true;
        }
        Utils_1.setShaderMaterialDefine(this, "USE_DISPLACEMENTMAP", useDisplacementMap);
    }
}
exports.EdgeMaterial = EdgeMaterial;
EdgeMaterial.DEFAULT_COLOR = 0x000000;
EdgeMaterial.DEFAULT_COLOR_MIX = 0.0;
//# sourceMappingURL=EdgeMaterial.js.map