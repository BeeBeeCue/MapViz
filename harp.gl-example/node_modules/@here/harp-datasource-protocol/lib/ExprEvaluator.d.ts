import { BooleanLiteralExpr, CallExpr, CaseExpr, Env, Expr, ExprScope, ExprVisitor, HasAttributeExpr, InterpolateExpr, MatchExpr, NullLiteralExpr, NumberLiteralExpr, ObjectLiteralExpr, StepExpr, StringLiteralExpr, Value, VarExpr } from "./Expr";
export interface OperatorDescriptor {
    /**
     * Returns `true` if this operator requires a dynamic execution context (e.g. ["zoom"]).
     */
    isDynamicOperator?: (call: CallExpr) => boolean;
    /**
     * Evaluates the given expression.
     */
    call: (context: ExprEvaluatorContext, call: CallExpr) => Value;
    /**
     * Partial evaluate the `call` expression using the given `context`.
     */
    partialEvaluate?: (context: ExprEvaluatorContext, call: CallExpr) => Value;
}
export interface OperatorDescriptorMap {
    [name: string]: OperatorDescriptor;
}
export declare class ExprEvaluatorContext {
    readonly evaluator: ExprEvaluator;
    readonly env: Env;
    readonly scope: ExprScope;
    readonly cache?: Map<Expr, Value> | undefined;
    constructor(evaluator: ExprEvaluator, env: Env, scope: ExprScope, cache?: Map<Expr, Value> | undefined);
    /**
     * Evaluate the given expression.
     *
     * @param expr - The {@link Expr} to evaluate.
     */
    evaluate(expr: Expr | undefined): Value;
    /**
     * Wraps the given value in an {@link Expr} if needed.
     *
     * @param value -
     */
    wrapValue(value: Value | Expr): Expr;
}
/**
 * [[ExprEvaluator]] is used to evaluate {@link Expr} in a given environment.
 *
 * @hidden
 */
export declare class ExprEvaluator implements ExprVisitor<Value, ExprEvaluatorContext> {
    static defineOperator(op: string, builtin: OperatorDescriptor): void;
    static defineOperators(builtins: OperatorDescriptorMap): void;
    /**
     * Returns the [[OperatorDescriptor]] for the given operator name.
     * @hidden
     */
    static getOperator(op: string): OperatorDescriptor | undefined;
    visitVarExpr(expr: VarExpr, context: ExprEvaluatorContext): Value;
    visitNullLiteralExpr(expr: NullLiteralExpr, context: ExprEvaluatorContext): Value;
    visitBooleanLiteralExpr(expr: BooleanLiteralExpr, context: ExprEvaluatorContext): Value;
    visitNumberLiteralExpr(expr: NumberLiteralExpr, context: ExprEvaluatorContext): Value;
    visitStringLiteralExpr(expr: StringLiteralExpr, context: ExprEvaluatorContext): Value;
    visitObjectLiteralExpr(expr: ObjectLiteralExpr, context: ExprEvaluatorContext): Value;
    visitHasAttributeExpr(expr: HasAttributeExpr, context: ExprEvaluatorContext): Value;
    visitMatchExpr(match: MatchExpr, context: ExprEvaluatorContext): Value;
    visitCaseExpr(match: CaseExpr, context: ExprEvaluatorContext): Value;
    visitCallExpr(expr: CallExpr, context: ExprEvaluatorContext): Value;
    visitStepExpr(expr: StepExpr, context: ExprEvaluatorContext): Value;
    visitInterpolateExpr(expr: InterpolateExpr, context: ExprEvaluatorContext): Value;
}
//# sourceMappingURL=ExprEvaluator.d.ts.map