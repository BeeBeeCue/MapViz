"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTechniqueAutomaticAttrs = exports.getTechniqueAttributeDescriptor = exports.getTechniqueDescriptor = exports.AttrScope = void 0;
var AttrScope;
(function (AttrScope) {
    /**
     * Attributes that affect generation of feature geometry and thus must be resolved at decoding
     * time.
     *
     * @remarks
     * They may have huge variancy as they are implemented as vertex attributes or embedded in
     * generated meshes.
     *
     * These attributes are available only in decoding scope.
     */
    AttrScope[AttrScope["FeatureGeometry"] = 0] = "FeatureGeometry";
    /**
     * Attributes that are common to whole group of features drawn with this technique.
     * These attributes affect generated geometry and  thus must be resolved at decoding time.
     *
     * @remarks
     * They shouldn't have big variancy and evaluate to at least dozens of values as each
     * combination of these attributes consitute new technique and material.
     *
     * These attributes are available in decoding and rendering scope.
     */
    AttrScope[AttrScope["TechniqueGeometry"] = 1] = "TechniqueGeometry";
    /**
     * Attributes that are common to whole group of features drawn with this technique.
     *
     * @remarks
     * Attributes that can be changed in resulting object/material from frame to frame. They are
     * usually implemented as uniforms.
     *
     * These attributes may be available only at rendering scope.
     */
    AttrScope[AttrScope["TechniqueRendering"] = 2] = "TechniqueRendering";
})(AttrScope = exports.AttrScope || (exports.AttrScope = {}));
/**
 * @internal
 */
function mergeTechniqueDescriptor(...descriptors) {
    const result = {
        attrDescriptors: {}
    };
    for (const descriptor of descriptors) {
        if (descriptor.attrTransparencyColor !== undefined) {
            result.attrTransparencyColor = descriptor.attrTransparencyColor;
        }
        if (descriptor.attrDescriptors !== undefined) {
            result.attrDescriptors = Object.assign(Object.assign({}, result.attrDescriptors), descriptor.attrDescriptors);
        }
    }
    return result;
}
const baseTechniqueParamsDescriptor = {
    // TODO: Choose which techniques should support color with transparency.
    // For now we chosen all, but it maybe not suitable for text or line marker techniques.
    attrTransparencyColor: "color",
    attrDescriptors: {
        enabled: AttrScope.FeatureGeometry,
        fadeFar: AttrScope.TechniqueRendering,
        fadeNear: AttrScope.TechniqueRendering,
        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },
        side: { scope: AttrScope.TechniqueRendering, automatic: true }
    }
};
const pointTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        color: { scope: AttrScope.TechniqueRendering, automatic: true },
        size: { scope: AttrScope.TechniqueRendering, automatic: true },
        opacity: { scope: AttrScope.TechniqueRendering, automatic: true }
    }
});
const squaresTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, pointTechniquePropTypes);
const circlesTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, pointTechniquePropTypes);
const lineMarkerTechniquePropTypes = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        text: AttrScope.FeatureGeometry,
        label: AttrScope.FeatureGeometry,
        useAbbreviation: AttrScope.FeatureGeometry,
        useIsoCode: AttrScope.FeatureGeometry,
        poiName: AttrScope.FeatureGeometry,
        imageTexture: AttrScope.FeatureGeometry,
        iconColor: AttrScope.TechniqueRendering,
        iconBrightness: AttrScope.TechniqueRendering,
        backgroundColor: AttrScope.TechniqueRendering,
        backgroundSize: AttrScope.TechniqueRendering,
        backgroundOpacity: AttrScope.TechniqueRendering,
        color: AttrScope.TechniqueRendering,
        opacity: AttrScope.TechniqueRendering,
        size: AttrScope.TechniqueRendering
    }
});
const polygonalTechniqueDescriptor = {
    attrDescriptors: {
        polygonOffset: { scope: AttrScope.TechniqueRendering, automatic: true },
        polygonOffsetFactor: { scope: AttrScope.TechniqueRendering, automatic: true },
        polygonOffsetUnits: { scope: AttrScope.TechniqueRendering, automatic: true },
        depthTest: { scope: AttrScope.TechniqueRendering, automatic: true },
        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },
        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },
        color: { scope: AttrScope.TechniqueRendering, automatic: true },
        lineColor: AttrScope.TechniqueRendering,
        lineFadeFar: AttrScope.TechniqueRendering,
        lineFadeNear: AttrScope.TechniqueRendering
    }
};
const solidLineTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {
    attrDescriptors: {
        lineWidth: AttrScope.TechniqueRendering,
        secondaryWidth: AttrScope.TechniqueRendering,
        secondaryColor: AttrScope.TechniqueRendering,
        dashSize: AttrScope.TechniqueRendering,
        gapSize: AttrScope.TechniqueRendering,
        outlineColor: { scope: AttrScope.TechniqueRendering, automatic: true },
        caps: { scope: AttrScope.TechniqueRendering, automatic: true },
        drawRangeStart: { scope: AttrScope.TechniqueRendering, automatic: true },
        drawRangeEnd: { scope: AttrScope.TechniqueRendering, automatic: true },
        dashes: { scope: AttrScope.TechniqueRendering, automatic: true },
        dashColor: { scope: AttrScope.TechniqueRendering, automatic: true }
    }
});
const lineTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        // TODO, check, which are really dynamic !
        color: { scope: AttrScope.TechniqueRendering, automatic: true },
        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },
        lineWidth: AttrScope.FeatureGeometry
    }
});
const fillTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, polygonalTechniqueDescriptor, {
    attrDescriptors: {
        wireframe: { scope: AttrScope.TechniqueRendering, automatic: true },
        color: { scope: AttrScope.TechniqueRendering, automatic: true },
        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },
        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },
        lineWidth: AttrScope.TechniqueRendering
    }
});
const standardTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        color: AttrScope.FeatureGeometry,
        vertexColors: { scope: AttrScope.TechniqueRendering, automatic: true },
        wireframe: { scope: AttrScope.TechniqueRendering, automatic: true },
        roughness: { scope: AttrScope.TechniqueRendering, automatic: true },
        metalness: { scope: AttrScope.TechniqueRendering, automatic: true },
        alphaTest: { scope: AttrScope.TechniqueRendering, automatic: true },
        depthTest: { scope: AttrScope.TechniqueRendering, automatic: true },
        transparent: { scope: AttrScope.TechniqueRendering, automatic: true },
        opacity: { scope: AttrScope.TechniqueRendering, automatic: true },
        emissive: { scope: AttrScope.TechniqueRendering, automatic: true },
        emissiveIntensity: { scope: AttrScope.TechniqueRendering, automatic: true },
        refractionRatio: { scope: AttrScope.TechniqueRendering, automatic: true },
        normalMapType: { scope: AttrScope.TechniqueRendering, automatic: true }
    }
});
const extrudedPolygonTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, standardTechniqueDescriptor, {
    attrDescriptors: {
        height: AttrScope.FeatureGeometry,
        floorHeight: AttrScope.FeatureGeometry,
        color: AttrScope.FeatureGeometry,
        defaultColor: AttrScope.FeatureGeometry,
        defaultHeight: AttrScope.FeatureGeometry,
        constantHeight: AttrScope.FeatureGeometry,
        boundaryWalls: AttrScope.FeatureGeometry,
        footprint: AttrScope.FeatureGeometry,
        maxSlope: AttrScope.FeatureGeometry,
        animateExtrusion: AttrScope.TechniqueRendering,
        lineWidth: AttrScope.TechniqueRendering,
        lineFadeNear: AttrScope.TechniqueRendering,
        lineFadeFar: AttrScope.TechniqueRendering,
        lineColor: AttrScope.TechniqueRendering
    }
});
const textTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        text: AttrScope.FeatureGeometry,
        label: AttrScope.FeatureGeometry,
        useAbbreviation: AttrScope.FeatureGeometry,
        useIsoCode: AttrScope.FeatureGeometry,
        backgroundColor: AttrScope.TechniqueRendering,
        backgroundSize: AttrScope.TechniqueRendering,
        backgroundOpacity: AttrScope.TechniqueRendering,
        color: AttrScope.TechniqueRendering,
        opacity: AttrScope.TechniqueRendering,
        priority: AttrScope.TechniqueRendering,
        size: AttrScope.TechniqueRendering
    }
});
const shaderTechniqueDescriptor = mergeTechniqueDescriptor(baseTechniqueParamsDescriptor, {
    attrDescriptors: {
        params: AttrScope.TechniqueRendering
    }
});
const techniqueDescriptors = {
    "extruded-polygon": extrudedPolygonTechniqueDescriptor,
    "line-marker": lineMarkerTechniquePropTypes,
    "labeled-icon": lineMarkerTechniquePropTypes,
    "solid-line": solidLineTechniqueDescriptor,
    "dashed-line": solidLineTechniqueDescriptor,
    terrain: standardTechniqueDescriptor,
    standard: standardTechniqueDescriptor,
    squares: squaresTechniquePropTypes,
    circles: circlesTechniquePropTypes,
    line: lineTechniqueDescriptor,
    segments: lineTechniqueDescriptor,
    fill: fillTechniqueDescriptor,
    text: textTechniqueDescriptor,
    shader: shaderTechniqueDescriptor
};
function getTechniqueDescriptor(technique) {
    if (typeof technique !== "string") {
        technique = technique.name;
    }
    return techniqueDescriptors[technique];
}
exports.getTechniqueDescriptor = getTechniqueDescriptor;
function getTechniqueAttributeDescriptor(technique, attrName) {
    const techniqueDescriptor = getTechniqueDescriptor(technique);
    const attrDescriptors = techniqueDescriptor === null || techniqueDescriptor === void 0 ? void 0 : techniqueDescriptor.attrDescriptors;
    const descriptor = attrDescriptors === null || attrDescriptors === void 0 ? void 0 : attrDescriptors[attrName];
    if (typeof descriptor === undefined) {
        return undefined;
    }
    else if (typeof descriptor === "object") {
        return descriptor;
    }
    return { scope: descriptor };
}
exports.getTechniqueAttributeDescriptor = getTechniqueAttributeDescriptor;
const automaticAttributeCache = new Map();
function getTechniqueAutomaticAttrs(technique) {
    var _a;
    if (typeof technique !== "string") {
        technique = technique.name;
    }
    if (automaticAttributeCache.has(technique)) {
        return automaticAttributeCache.get(technique);
    }
    const descriptors = [];
    const attrDescriptors = (_a = getTechniqueDescriptor(technique)) === null || _a === void 0 ? void 0 : _a.attrDescriptors;
    if (attrDescriptors === undefined) {
        return descriptors;
    }
    for (const attrName in attrDescriptors) {
        if (!attrDescriptors.hasOwnProperty(attrName)) {
            continue;
        }
        const descr = attrDescriptors[attrName];
        if (descr === undefined || typeof descr === "number") {
            continue;
        }
        if (descr.automatic === true) {
            descriptors.push(attrName);
        }
    }
    automaticAttributeCache.set(technique, descriptors);
    return descriptors;
}
exports.getTechniqueAutomaticAttrs = getTechniqueAutomaticAttrs;
//# sourceMappingURL=TechniqueDescriptors.js.map