import { IndexedTechnique, Technique } from "./Techniques";
export declare enum AttrScope {
    /**
     * Attributes that affect generation of feature geometry and thus must be resolved at decoding
     * time.
     *
     * @remarks
     * They may have huge variancy as they are implemented as vertex attributes or embedded in
     * generated meshes.
     *
     * These attributes are available only in decoding scope.
     */
    FeatureGeometry = 0,
    /**
     * Attributes that are common to whole group of features drawn with this technique.
     * These attributes affect generated geometry and  thus must be resolved at decoding time.
     *
     * @remarks
     * They shouldn't have big variancy and evaluate to at least dozens of values as each
     * combination of these attributes consitute new technique and material.
     *
     * These attributes are available in decoding and rendering scope.
     */
    TechniqueGeometry = 1,
    /**
     * Attributes that are common to whole group of features drawn with this technique.
     *
     * @remarks
     * Attributes that can be changed in resulting object/material from frame to frame. They are
     * usually implemented as uniforms.
     *
     * These attributes may be available only at rendering scope.
     */
    TechniqueRendering = 2
}
/**
 * Extract  property names from `Technique`-like interface (excluding `name`) as union of string
 * literals.
 *
 * TechniquePropName<Base
 *
 */
declare type TechniquePropNames<T> = T extends {
    name: any;
} ? keyof Omit<T, "name"> : keyof T;
interface AttrDescriptor {
    /**
     * The evaluation scope of this attribute.
     */
    scope?: AttrScope;
    /**
     * Mark this attribute as automatic.
     *
     * @remarks
     * When set to `true`, the underlying material property
     * associated with this attribute is automatically kept in sync
     * with the value of the technique attribute.
     */
    automatic?: boolean;
}
declare type TechniqueAttrDescriptors<T> = {
    [P in TechniquePropNames<T>]?: AttrScope | AttrDescriptor;
};
export interface TechniqueDescriptor<T = Technique> {
    attrTransparencyColor?: string;
    attrDescriptors: TechniqueAttrDescriptors<T>;
}
export declare function getTechniqueDescriptor(technique: string | IndexedTechnique | Technique): TechniqueDescriptor | undefined;
export declare function getTechniqueAttributeDescriptor(technique: string | IndexedTechnique | Technique, attrName: string): AttrDescriptor | undefined;
export declare function getTechniqueAutomaticAttrs(technique: string | IndexedTechnique | Technique): string[];
export {};
//# sourceMappingURL=TechniqueDescriptors.d.ts.map