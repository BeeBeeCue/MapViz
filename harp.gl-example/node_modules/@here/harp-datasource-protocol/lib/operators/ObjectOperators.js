"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectOperators = void 0;
const Env_1 = require("../Env");
const Expr_1 = require("../Expr");
const hasOwnProperty = Object.prototype.hasOwnProperty;
var LookupMode;
(function (LookupMode) {
    LookupMode[LookupMode["get"] = 0] = "get";
    LookupMode[LookupMode["has"] = 1] = "has";
})(LookupMode || (LookupMode = {}));
function lookupMember(context, args, lookupMode) {
    var _a;
    const memberName = context.evaluate(args[0]);
    if (typeof memberName !== "string") {
        throw new Error(`expected the name of an attribute`);
    }
    const object = context.evaluate(args[1]);
    if (object && typeof object === "object") {
        if (Env_1.Env.isEnv(object)) {
            const value = (_a = object.lookup(memberName)) !== null && _a !== void 0 ? _a : null;
            return lookupMode === LookupMode.get ? value : value !== null;
        }
        if (hasOwnProperty.call(object, memberName)) {
            return lookupMode === LookupMode.get ? object[memberName] : true;
        }
    }
    return lookupMode === LookupMode.get ? null : false;
}
const operators = {
    in: {
        call: (context, call) => {
            const value = context.evaluate(call.args[0]);
            const object = context.evaluate(call.args[1]);
            if (typeof value === "string" && typeof object === "string") {
                return object.includes(value);
            }
            else if (Array.isArray(object)) {
                return object.includes(value);
            }
            return false;
        }
    },
    get: {
        call: (context, call) => lookupMember(context, call.args, LookupMode.get)
    },
    has: {
        call: (context, call) => lookupMember(context, call.args, LookupMode.has)
    },
    "dynamic-properties": {
        isDynamicOperator: () => true,
        call: (context, call) => {
            if (context.scope === Expr_1.ExprScope.Dynamic) {
                return context.env;
            }
            return call;
        }
    }
};
exports.ObjectOperators = operators;
//# sourceMappingURL=ObjectOperators.js.map