"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ColorOperators = void 0;
const THREE = require("three");
const ColorUtils_1 = require("../ColorUtils");
const StringEncodedNumeral_1 = require("../StringEncodedNumeral");
const operators = {
    alpha: {
        call: (context, call) => {
            let color = context.evaluate(call.args[0]);
            if (typeof color === "string") {
                color = StringEncodedNumeral_1.parseStringEncodedColor(color);
            }
            const alpha = typeof color === "number" ? ColorUtils_1.ColorUtils.getAlphaFromHex(color) : 1;
            return alpha;
        }
    },
    rgba: {
        call: (context, call) => {
            const r = context.evaluate(call.args[0]);
            const g = context.evaluate(call.args[1]);
            const b = context.evaluate(call.args[2]);
            const a = context.evaluate(call.args[3]);
            if (typeof r === "number" &&
                typeof g === "number" &&
                typeof b === "number" &&
                typeof a === "number" &&
                r >= 0 &&
                g >= 0 &&
                b >= 0 &&
                a >= 0 &&
                a <= 1) {
                return rgbaToHex(r, g, b, a);
            }
            throw new Error(`unknown color 'rgba(${r},${g},${b},${a})'`);
        }
    },
    rgb: {
        call: (context, call) => {
            const r = context.evaluate(call.args[0]);
            const g = context.evaluate(call.args[1]);
            const b = context.evaluate(call.args[2]);
            if (typeof r === "number" &&
                typeof g === "number" &&
                typeof b === "number" &&
                r >= 0 &&
                g >= 0 &&
                b >= 0) {
                return rgbToHex(r, g, b);
            }
            throw new Error(`unknown color 'rgb(${r},${g},${b})'`);
        }
    },
    // Hsl operator contains angle modulated to <0, 360> range, percent of
    // saturation and lightness in <0, 100> range, i.e. hsl(360, 100, 100)
    hsl: {
        call: (context, call) => {
            const h = context.evaluate(call.args[0]);
            const s = context.evaluate(call.args[1]);
            const l = context.evaluate(call.args[2]);
            if (typeof h === "number" &&
                typeof s === "number" &&
                typeof l === "number" &&
                h >= 0 &&
                s >= 0 &&
                l >= 0) {
                return hslToHex(h, s, l);
            }
            throw new Error(`unknown color 'hsl(${h},${s}%,${l}%)'`);
        }
    }
};
function rgbaToHex(r, g, b, a) {
    // We decode rgba color channels using custom hex format with transparency.
    return ColorUtils_1.ColorUtils.getHexFromRgba(THREE.MathUtils.clamp(r, 0, 255) / 255, THREE.MathUtils.clamp(g, 0, 255) / 255, THREE.MathUtils.clamp(b, 0, 255) / 255, THREE.MathUtils.clamp(a, 0, 1));
}
function rgbToHex(r, g, b) {
    return ColorUtils_1.ColorUtils.getHexFromRgb(THREE.MathUtils.clamp(r, 0, 255) / 255, THREE.MathUtils.clamp(g, 0, 255) / 255, THREE.MathUtils.clamp(b, 0, 255) / 255);
}
function hslToHex(h, s, l) {
    return ColorUtils_1.ColorUtils.getHexFromHsl(THREE.MathUtils.euclideanModulo(h, 360) / 360, THREE.MathUtils.clamp(s, 0, 100) / 100, THREE.MathUtils.clamp(l, 0, 100) / 100);
}
exports.ColorOperators = operators;
//# sourceMappingURL=ColorOperators.js.map