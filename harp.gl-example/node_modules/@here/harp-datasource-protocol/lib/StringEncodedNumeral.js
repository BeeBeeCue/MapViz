"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseStringEncodedColor = exports.parseStringEncodedNumeral = exports.StringEncodedNumeralFormatMaxSize = exports.StringEncodedNumeralFormats = exports.StringEncodedColorFormats = exports.StringEncodedMetricFormats = exports.StringEncodedNumeralType = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = require("@here/harp-utils");
//@ts-ignore
const csscolorparser_1 = require("csscolorparser");
const ColorUtils_1 = require("./ColorUtils");
/**
 * Enumeration of supported string encoded numerals.
 * @internal
 */
var StringEncodedNumeralType;
(function (StringEncodedNumeralType) {
    StringEncodedNumeralType[StringEncodedNumeralType["Meters"] = 0] = "Meters";
    StringEncodedNumeralType[StringEncodedNumeralType["Pixels"] = 1] = "Pixels";
    StringEncodedNumeralType[StringEncodedNumeralType["Hex"] = 2] = "Hex";
})(StringEncodedNumeralType = exports.StringEncodedNumeralType || (exports.StringEncodedNumeralType = {}));
const StringEncodedMeters = {
    type: StringEncodedNumeralType.Meters,
    size: 1,
    regExp: /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))m$/,
    decoder: (encodedValue, target) => {
        const match = StringEncodedMeters.regExp.exec(encodedValue);
        return match ? (target[0] = Number(match[1])) !== undefined : false;
    }
};
const StringEncodedPixels = {
    type: StringEncodedNumeralType.Pixels,
    size: 1,
    mask: 1.0,
    regExp: /^((?=\.\d|\d)(?:\d+)?(?:\.?\d*))px$/,
    decoder: (encodedValue, target) => {
        const match = StringEncodedPixels.regExp.exec(encodedValue);
        if (match === null) {
            return false;
        }
        target[0] = Number(match[1]);
        return true;
    }
};
const StringEncodedHex = {
    type: StringEncodedNumeralType.Hex,
    size: 4,
    regExp: /^\#((?:[0-9A-Fa-f][0-9A-Fa-f]){4}|[0-9A-Fa-f]{4})$/,
    decoder: (encodedValue, target) => {
        const match = StringEncodedHex.regExp.exec(encodedValue);
        if (match === null) {
            return false;
        }
        const hex = match[1];
        const size = hex.length;
        // Only few sizes are possible for given reg-exp.
        harp_utils_1.assert(size === 4 || size === 8, `Matched incorrect hex color format`);
        // Note that we simply ignore alpha channel value.
        // TODO: To be resolved with HARP-7517
        if (size === 4) {
            // #RGB or #RGBA
            target[0] = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255;
            target[1] = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255;
            target[2] = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255;
            target[3] = size === 4 ? parseInt(hex.charAt(3) + hex.charAt(3), 16) / 255 : 1;
        }
        else if (size === 8) {
            // #RRGGBB or #RRGGBBAA
            target[0] = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255;
            target[1] = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255;
            target[2] = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255;
            target[3] = size === 8 ? parseInt(hex.charAt(6) + hex.charAt(7), 16) / 255 : 1;
        }
        return true;
    }
};
/**
 * Array of all supported [[StringEncodedNumeralFormat]]s describing sizes, lengths and distances.
 * @internal
 */
exports.StringEncodedMetricFormats = [
    StringEncodedMeters,
    StringEncodedPixels
];
const StringEncodedMetricFormatMaxSize = exports.StringEncodedMetricFormats.reduce((a, b) => Math.max(a, b.size), 0);
/**
 * Array of all supported [[StringEncodedNumeralFormat]]s describing color data.
 * @internal
 */
exports.StringEncodedColorFormats = [StringEncodedHex];
const StringEncodedColorFormatMaxSize = exports.StringEncodedColorFormats.reduce((a, b) => Math.max(a, b.size), 0);
/**
 * Array of supported [[StringEncodedNumeralFormat]]s (intended to be indexed with
 * [[StringEncodedNumeralType]] enum).
 * @internal
 */
exports.StringEncodedNumeralFormats = [
    ...exports.StringEncodedMetricFormats,
    ...exports.StringEncodedColorFormats
];
/**
 * @internal
 */
exports.StringEncodedNumeralFormatMaxSize = Math.max(StringEncodedColorFormatMaxSize, StringEncodedMetricFormatMaxSize);
const tmpBuffer = new Array(exports.StringEncodedNumeralFormatMaxSize);
/**
 * Parse string encoded numeral values using all known [[StringEncodedNumeralFormats]].
 *
 * @param numeral - The string representing numeric value.
 * @param pixelToMeters - The ratio used to convert from meters to pixels (default 1.0).
 * @returns Number parsed or __undefined__ if non of the numeral patterns matches the expression
 * provided in [[numeral]].
 */
function parseStringEncodedNumeral(numeral, pixelToMeters = 1.0) {
    return parseStringLiteral(numeral, exports.StringEncodedNumeralFormats, pixelToMeters);
}
exports.parseStringEncodedNumeral = parseStringEncodedNumeral;
/**
 * Parse string encoded color value using all known [[StringEncodedColorFormats]].
 *
 * @param color - The string encoded color expression (i.e. '#FFF', 'rgb(255, 0, 0)', etc.).
 * @returns The color parsed or __undefined__ if non of the known representations matches
 * the expression provided in [[color]].
 */
function parseStringEncodedColor(color) {
    return parseStringLiteral(color, exports.StringEncodedColorFormats);
}
exports.parseStringEncodedColor = parseStringEncodedColor;
function parseStringLiteral(text, formats, pixelToMeters = 1.0) {
    const matchedFormat = formats.find(format => {
        return format.decoder(text, tmpBuffer) ? true : false;
    });
    if (matchedFormat === undefined) {
        const components = csscolorparser_1.parseCSSColor(text);
        return Array.isArray(components) && !components.some(c => isNaN(c))
            ? ColorUtils_1.ColorUtils.getHexFromRgba(components[0] / 255, components[1] / 255, components[2] / 255, components[3])
            : undefined;
    }
    switch (matchedFormat === null || matchedFormat === void 0 ? void 0 : matchedFormat.type) {
        case StringEncodedNumeralType.Pixels:
            return tmpBuffer[0] * pixelToMeters;
        case StringEncodedNumeralType.Hex:
            return ColorUtils_1.ColorUtils.getHexFromRgba(tmpBuffer[0], tmpBuffer[1], tmpBuffer[2], tmpBuffer[3]);
        default:
            return tmpBuffer[0];
    }
}
//# sourceMappingURL=StringEncodedNumeral.js.map