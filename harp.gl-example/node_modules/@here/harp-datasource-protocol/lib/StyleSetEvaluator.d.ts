import { Env, Expr, Value } from "./Expr";
import { DecoderOptions } from "./ITileDecoder";
import { IndexedTechnique } from "./Techniques";
import { Style, StyleSet } from "./Theme";
interface StyleInternalParams {
    /**
     * Optimization: Lazy creation and storage of expression in a style object.
     */
    _whenExpr?: Expr;
    _minZoomLevelExpr?: Expr;
    _maxZoomLevelExpr?: Expr;
    _staticAttributes?: Array<[string, Value]>;
    /**
     * These attributes are used to instantiate Technique variants.
     *
     * @see [[TechiqueDescriptor.techniquePropNames]]
     */
    _dynamicTechniqueAttributes?: Array<[string, Expr]>;
    /**
     * These attributes must be evaluated basing with feature env.
     *
     * They are not propagated to rendering scope.
     *
     * @see [[TechniqueAttrScope.Feature]]
     */
    _dynamicFeatureAttributes?: Array<[string, Expr]>;
    /**
     * These attributes are forwarded as serialized by decoder to main thread, so they are resolved
     * directly in render loop.
     *
     * Will contain attributes from these lists
     *  - interpolants from [[TechiqueDescriptor.techniquePropNames]]
     *  - expressions [[TechniqueDescriptor.dynamicPropNames]] (Future)
     */
    _dynamicForwardedAttributes?: Array<[string, Expr]>;
    _dynamicTechniques?: Map<string, IndexedTechnique>;
    /**
     * Optimization: Index into table in StyleSetEvaluator.
     * @hidden
     */
    _staticTechnique?: IndexedTechnique;
    /**
     * Optimization: StyleSet index.
     * @hidden
     */
    _styleSetIndex?: number;
    /**
     * Optimization: Requested $geometryType.
     * @hidden
     */
    _geometryType?: string;
    /**
     * `true` if any of the properties of this technique
     * requires access to the feature's state.
     */
    _usesFeatureState?: boolean;
}
declare type InternalStyle = Style & StyleInternalParams;
/**
 * Options to be passed to the StyleSetEvaluator
 *
 * Basically identical as the DecoderOptions but requires styleSet to be set.
 */
export declare type StyleSetOptions = DecoderOptions & {
    styleSet: StyleSet;
};
/**
 * Combine data from datasource and apply the rules from a specified theme to show it on the map.
 */
export declare class StyleSetEvaluator {
    private readonly m_options;
    readonly styleSet: InternalStyle[];
    private readonly m_techniques;
    private readonly m_exprPool;
    private readonly m_cachedResults;
    private readonly m_styleConditionClassifier;
    private readonly m_subStyleSetCache;
    private readonly m_definitions?;
    private readonly m_definitionExprCache;
    private readonly m_tmpOptimizedSubSetKey;
    private readonly m_emptyEnv;
    private m_featureDependencies;
    private m_layer;
    private m_geometryType;
    private m_zoomLevel;
    private m_previousResult;
    private m_previousEnv;
    constructor(m_options: StyleSetOptions);
    /**
     * Find all techniques that fit the current objects' environment.
     * *The techniques in the resulting array may not be modified* since they are being reused for
     * identical objects.
     *
     * @param env - The objects environment, i.e. the attributes that are relevant for its
     * representation.
     * @param layer - The optional layer name used to filter techniques.
     * @param geometryType - The optional geometryType used to filter techniques.
     */
    getMatchingTechniques(env: Env, layer?: string | undefined, geometryType?: string | undefined): IndexedTechnique[];
    /**
     * Check if `styleSet` contains any rule related to `layer`.
     *
     * @param layer - name of layer
     */
    wantsLayer(layer: string): boolean;
    /**
     * Check if `styleSet` contains any rule related to particular `[layer, geometryType]` pair.
     *
     * @param layer - name of layer
     * @param geometryType - type of layer - `point`, `line` or `polygon`
     */
    wantsFeature(layer: string, geometryType?: string): boolean;
    /**
     * Get the expression evaluation cache, for further feature processing.
     *
     * This object is valid until next `getMatchingTechniques` call.
     */
    get expressionEvaluatorCache(): Map<Expr, Value>;
    /**
     * Reset array of techniques.
     *
     * Cleans technique array and indices, so it doesn't accumulate accross several decoding runs.
     */
    resetTechniques(): void;
    /**
     * Get the (current) array of techniques that have been created during decoding.
     */
    get techniques(): IndexedTechnique[];
    /**
     * Get the (current) array of techniques that have been created during decoding.
     */
    get decodedTechniques(): IndexedTechnique[];
    private getOptimizedStyleSet;
    private createPreFilteredStyleSet;
    /**
     * Compile the `when` conditions found when traversting the styling rules.
     */
    private compileStyleSet;
    /**
     * Compile the `when` conditions reachable from the given `style`.
     *
     * @param style - The current style.
     */
    private compileStyle;
    /**
     * Process a style (and its sub-styles) hierarchically to look for the technique that fits the
     * current objects' environment. The attributes of the styles are assembled to create a unique
     * technique for every object.
     *
     * @param env - The objects environment, i.e. the attributes that are relevant for its
     *            representation.
     * @param style - Current style (could also be top of stack).
     * @param result - The array of resulting techniques. There may be more than one technique per
     *               object, resulting in multiple graphical objects for representation.
     * @returns `true` if style has been found and processing is finished. `false` if not found, or
     *          more than one technique should be applied.
     */
    private processStyle;
    private checkZoomLevel;
    private getTechniqueForStyleMatch;
    private getDynamicTechniqueKey;
    private checkStyleDynamicAttributes;
    private evaluateTechniqueProperties;
    private createTechnique;
}
/**
 * Create transferable representation of dynamic technique.
 *
 * Converts  non-transferable {@link Expr}instances back to JSON form.
 */
export declare function makeDecodedTechnique(technique: IndexedTechnique): IndexedTechnique;
export {};
//# sourceMappingURL=StyleSetEvaluator.d.ts.map