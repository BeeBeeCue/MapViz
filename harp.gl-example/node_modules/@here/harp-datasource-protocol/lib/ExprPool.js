"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExprPool = void 0;
const Expr_1 = require("./Expr");
/**
 * [[ExprPool]] maintains a set of unique interned {@link Expr} objects.
 *
 * @hidden
 */
class ExprPool {
    constructor() {
        this.m_booleanLiterals = new Map();
        this.m_numberLiterals = new Map();
        this.m_stringLiterals = new Map();
        this.m_objectLiterals = new Map();
        this.m_arrayLiterals = [];
        this.m_varExprs = new Map();
        this.m_hasAttributeExprs = new Map();
        this.m_matchExprs = [];
        this.m_caseExprs = [];
        this.m_interpolateExprs = [];
        this.m_stepExprs = [];
        this.m_callExprs = new Map();
    }
    /**
     * Add `expr` to this [[ExprPool]] and return a unique {@link Expr}
     * object that is structurally equivalent to `expr`.
     *
     * @param expr - The {@link Expr} to add to this [[ExprPool]].
     * @returns A unique {@link Expr} that is structurally equivalent to `expr`.
     */
    add(expr) {
        return expr.accept(this, undefined);
    }
    visitNullLiteralExpr(expr, context) {
        return Expr_1.NullLiteralExpr.instance;
    }
    visitBooleanLiteralExpr(expr, context) {
        const e = this.m_booleanLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_booleanLiterals.set(expr.value, expr);
        return expr;
    }
    visitNumberLiteralExpr(expr, context) {
        const e = this.m_numberLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_numberLiterals.set(expr.value, expr);
        return expr;
    }
    visitStringLiteralExpr(expr, context) {
        const e = this.m_stringLiterals.get(expr.value);
        if (e) {
            return e;
        }
        this.m_stringLiterals.set(expr.value, expr);
        return expr;
    }
    visitObjectLiteralExpr(expr, context) {
        const e = this.m_objectLiterals.get(expr.value);
        if (e) {
            return e;
        }
        if (Array.isArray(expr.value)) {
            const array = expr.value;
            const r = this.m_arrayLiterals.find(literal => {
                const elements = literal.value;
                if (elements.length !== array.length) {
                    return false;
                }
                return array.every((x, i) => x === elements[i]);
            });
            if (r !== undefined) {
                return r;
            }
            this.m_arrayLiterals.push(expr);
        }
        this.m_objectLiterals.set(expr.value, expr);
        return expr;
    }
    visitVarExpr(expr, context) {
        const e = this.m_varExprs.get(expr.name);
        if (e) {
            return e;
        }
        this.m_varExprs.set(expr.name, expr);
        return expr;
    }
    visitHasAttributeExpr(expr, context) {
        const e = this.m_hasAttributeExprs.get(expr.name);
        if (e) {
            return e;
        }
        this.m_hasAttributeExprs.set(expr.name, expr);
        return expr;
    }
    visitMatchExpr(expr, context) {
        const value = expr.value.accept(this, context);
        const branches = expr.branches.map(([label, body]) => [
            label,
            body.accept(this, context)
        ]);
        const fallback = expr.fallback.accept(this, context);
        for (const candidate of this.m_matchExprs) {
            if (candidate.value !== value) {
                continue;
            }
            if (candidate.fallback !== fallback) {
                continue;
            }
            if (candidate.branches.length !== branches.length) {
                continue;
            }
            let branchesMatching = true;
            for (let i = 0; i < branches.length; i++) {
                if (branches[i][0] !== candidate.branches[i][0] ||
                    branches[i][1] !== candidate.branches[i][1]) {
                    branchesMatching = false;
                    break;
                }
            }
            if (branchesMatching) {
                return candidate;
            }
        }
        const r = new Expr_1.MatchExpr(value, branches, fallback);
        this.m_matchExprs.push(r);
        return r;
    }
    visitCaseExpr(expr, context) {
        const branches = expr.branches.map(([condition, body]) => [
            condition.accept(this, context),
            body.accept(this, context)
        ]);
        const fallback = expr.fallback.accept(this, context);
        for (const candidate of this.m_caseExprs) {
            if (candidate.fallback !== fallback) {
                continue;
            }
            if (candidate.branches.length !== branches.length) {
                continue;
            }
            let branchesMatching = true;
            for (let i = 0; i < branches.length; i++) {
                if (branches[i][0] !== candidate.branches[i][0] ||
                    branches[i][1] !== candidate.branches[i][1]) {
                    branchesMatching = false;
                    break;
                }
            }
            if (branchesMatching) {
                return candidate;
            }
        }
        const r = new Expr_1.CaseExpr(branches, fallback);
        this.m_caseExprs.push(r);
        return r;
    }
    visitCallExpr(expr, context) {
        // rewrite the actual arguments
        const expressions = expr.args.map(childExpr => childExpr.accept(this, context));
        // ensure we have a valid set of interned expressions for the calls
        if (!this.m_callExprs.has(expr.op)) {
            this.m_callExprs.set(expr.op, []);
        }
        // get the calls for the given operator.
        const calls = this.m_callExprs.get(expr.op);
        for (const call of calls) {
            // check the number of arguments
            if (call.args.length !== expressions.length) {
                continue;
            }
            // find the index of the first mismatch.
            let index = 0;
            for (; index < call.args.length; ++index) {
                if (call.args[index] !== expressions[index]) {
                    break;
                }
            }
            if (index === call.args.length) {
                // no mismatch found, return the 'interned' call.
                return call;
            }
        }
        const e = new Expr_1.CallExpr(expr.op, expressions);
        e.descriptor = expr.descriptor;
        calls.push(e);
        return e;
    }
    visitStepExpr(expr, context) {
        if (this.m_stepExprs.includes(expr)) {
            return expr;
        }
        const input = expr.input.accept(this, context);
        const defaultValue = expr.defaultValue.accept(this, context);
        const stops = expr.stops.map(stop => {
            const key = stop[0];
            const value = stop[1].accept(this, context);
            return value === stop[1] ? stop : [key, value];
        });
        for (const step of this.m_stepExprs) {
            if (step.input === input &&
                step.defaultValue === defaultValue &&
                stops.length === step.stops.length &&
                stops.every(([key, value], i) => key === step.stops[i][0] && value === step.stops[i][1])) {
                return step;
            }
        }
        const e = new Expr_1.StepExpr(input, defaultValue, stops);
        this.m_stepExprs.push(e);
        return e;
    }
    visitInterpolateExpr(expr, context) {
        if (this.m_interpolateExprs.includes(expr)) {
            return expr;
        }
        const input = expr.input.accept(this, context);
        const stops = expr.stops.map(stop => {
            const key = stop[0];
            const value = stop[1].accept(this, context);
            return value === stop[1] ? stop : [key, value];
        });
        for (const interp of this.m_interpolateExprs) {
            if (interp.input === input &&
                interp.mode[0] === expr.mode[0] &&
                interp.mode[1] === expr.mode[1] &&
                stops.length === interp.stops.length &&
                stops.every(([key, value], i) => key === interp.stops[i][0] && value === interp.stops[i][1])) {
                return interp;
            }
        }
        const e = new Expr_1.InterpolateExpr(expr.mode, input, stops);
        this.m_interpolateExprs.push(e);
        return e;
    }
}
exports.ExprPool = ExprPool;
//# sourceMappingURL=ExprPool.js.map