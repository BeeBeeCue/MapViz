"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HighPrecisionPoints = void 0;
const harp_materials_1 = require("@here/harp-materials");
const THREE = require("three");
const HighPrecisionUtils_1 = require("./HighPrecisionUtils");
/**
 * Class used to render high-precision points.
 */
class HighPrecisionPoints extends THREE.Points {
    /**
     * Creates a `HighPrecisionPoints` object.
     *
     * @param geometry - [[BufferGeometry]] used to render this object.
     * @param material - [[HighPrecisionLineMaterial]] used to render this object.
     *     instances.
     * @param positions - Array of 2D/3D positions.
     * @param color - Color of the rendered point.
     * @param opacity - Opacity of the rendered point.
     */
    constructor(geometry, material, positions, color, opacity) {
        if (material === undefined) {
            material = new harp_materials_1.HighPrecisionPointMaterial({
                color: color ? color : harp_materials_1.HighPrecisionPointMaterial.DEFAULT_COLOR,
                opacity: opacity !== undefined ? opacity : 1
            });
        }
        super(geometry === undefined ? new THREE.BufferGeometry() : geometry, material);
        this.matrixWorldInverse = new THREE.Matrix4();
        if (positions) {
            this.setPositions(positions);
        }
    }
    get bufferGeometry() {
        return this.geometry;
    }
    /**
     * Clears the [[BufferGeometry]] used to render this point.
     */
    clearGeometry() {
        return (this.geometry = new THREE.BufferGeometry());
    }
    get shaderMaterial() {
        return this.material;
    }
    setPositions(positions) {
        HighPrecisionUtils_1.HighPrecisionUtils.setPositions(this, positions);
    }
    setupForRendering() {
        if (this.material.isHighPrecisionPointsMaterial &&
            this.dimensionality !== undefined) {
            this.material.setDimensionality(this.dimensionality);
        }
        this.onBeforeRender = (_renderer, _scene, camera, _geometry, _material, _group) => {
            HighPrecisionUtils_1.HighPrecisionUtils.updateHpUniforms(this, camera, this.shaderMaterial);
        };
    }
    updateMatrixWorld(force) {
        const doUpdateMatrixWorldInverse = this.matrixWorldNeedsUpdate || force;
        super.updateMatrixWorld(force);
        if (doUpdateMatrixWorldInverse) {
            this.matrixWorldInverse.getInverse(this.matrixWorld);
        }
    }
}
exports.HighPrecisionPoints = HighPrecisionPoints;
//# sourceMappingURL=HighPrecisionPoints.js.map