"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SolidLineMaterial = exports.LineDashesModes = void 0;
const THREE = require("three");
const MapMeshMaterials_1 = require("./MapMeshMaterials");
const RawShaderMaterial_1 = require("./RawShaderMaterial");
const LinesChunks_1 = require("./ShaderChunks/LinesChunks");
const Utils_1 = require("./Utils");
const LineCapsDefinesMapping = {
    None: LinesChunks_1.LineCapsModes.CAPS_NONE,
    Square: LinesChunks_1.LineCapsModes.CAPS_SQUARE,
    Round: LinesChunks_1.LineCapsModes.CAPS_ROUND,
    TriangleIn: LinesChunks_1.LineCapsModes.CAPS_TRIANGLE_IN,
    TriangleOut: LinesChunks_1.LineCapsModes.CAPS_TRIANGLE_OUT
};
const DefinesLineCapsMapping = Object.keys(LineCapsDefinesMapping).reduce((r, lineCapsName) => {
    const defineKey = lineCapsName;
    const defineValue = LineCapsDefinesMapping[defineKey];
    r[defineValue] = defineKey;
    return r;
}, {});
var LineDashesModes;
(function (LineDashesModes) {
    LineDashesModes[LineDashesModes["DASHES_SQUARE"] = 0] = "DASHES_SQUARE";
    LineDashesModes[LineDashesModes["DASHES_ROUND"] = 1] = "DASHES_ROUND";
    LineDashesModes[LineDashesModes["DASHES_DIAMOND"] = 2] = "DASHES_DIAMOND";
})(LineDashesModes = exports.LineDashesModes || (exports.LineDashesModes = {}));
const LineDashesDefinesMapping = {
    Square: LineDashesModes.DASHES_SQUARE,
    Round: LineDashesModes.DASHES_ROUND,
    Diamond: LineDashesModes.DASHES_DIAMOND
};
const DefinesLineDashesMapping = Object.keys(LineDashesDefinesMapping).reduce((r, lineDashesName) => {
    const defineKey = lineDashesName;
    const defineValue = LineDashesDefinesMapping[defineKey];
    r[defineValue] = defineKey;
    return r;
}, {});
/**
 * The vLength contains the actual line length, it's needed for the creation of line caps by
 * detecting line ends. `vLength == vExtrusionCoord.x + lineWidth * 2`
 */
/**
 * The vExtrusionStrength relies on the edges of the lines. Represents how far the current point was
 * extruded on the edges because of the current angle. Needed for preventing line caps artifacts on
 * sharp line edges. For example, on sharp edges, some vertices can be extruded much further than
 * the full line length.
 */
const tmpColor = new THREE.Color();
const vertexSource = `
#define SEGMENT_OFFSET 0.1

attribute vec3 extrusionCoord;
attribute vec3 position;
attribute vec4 bitangent;
attribute vec3 tangent;
attribute vec2 uv;
attribute vec3 normal;

uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform float extrusionWidth;
uniform float outlineWidth;
uniform float offset;
uniform vec2 drawRange;

#ifdef USE_DISPLACEMENTMAP
uniform sampler2D displacementMap;
#endif

#ifdef USE_TILE_CLIP
varying vec3 vPosition;
#endif
varying vec3 vRange;
varying vec4 vCoords;
#ifdef USE_COLOR
attribute vec3 color;
varying vec3 vColor;
#endif

#ifdef USE_FADING
#include <fading_pars_vertex>
#endif

#include <fog_pars_vertex>

#include <extrude_line_vert_func>

void main() {
    // Calculate the segment.
    vec2 segment = abs(extrusionCoord.xy) - SEGMENT_OFFSET;
    float segmentPos = sign(extrusionCoord.x) / 2.0 + 0.5;

    // Calculate the vertex position inside the line (segment) and extrusion direction and factor.
    float linePos = mix(segment.x, segment.y, segmentPos);
    vec2 extrusionDir = sign(extrusionCoord.xy);
    // Precompute to avoid computing multiple times
    float tanHalfAngle = tan(bitangent.w / 2.0);
    float extrusionFactor = extrusionDir.y * tanHalfAngle;

    // Calculate the extruded vertex position (and scale the extrusion direction).
    vec3 pos = extrudeLine(
        position, linePos, extrusionWidth + outlineWidth, bitangent, tangent, tanHalfAngle,
        extrusionDir);

    // Store the normalized extrusion coordinates in vCoords (with their ranges in vRange).
    vRange = vec3(extrusionCoord.z, extrusionWidth, extrusionFactor);
    vCoords = vec4(extrusionDir / vRange.xy, segment / vRange.x);

    // Adjust the segment to fit the drawRange.
    float capDist = (extrusionWidth + outlineWidth) / extrusionCoord.z;
    if ((vCoords.w + capDist) < drawRange.x || (vCoords.z - capDist) > drawRange.y) {
        vCoords.zw += 1.0;
    }
    if (vCoords.z < drawRange.x) {
        vCoords.zw += vec2(drawRange.x - vCoords.z, 0.0);
    }
    if (vCoords.w > drawRange.y) {
        vCoords.zw -= vec2(0.0, vCoords.w - drawRange.y);
    }

    // Transform position.
    #ifdef USE_DISPLACEMENTMAP
    pos += normalize( normal ) * texture2D( displacementMap, uv ).x;
    #endif

    // Shift the line based on the offset, where the bitangent is the cross product of the average
    // of the two direction vectors (the previous and next segment directions) and the normal of
    // the line (facing into the sky). The w component is the angle between the two segments.
    // Note, we need to take the angle into consideration, so we use trigonometry to calculate how
    // much we need to extend the offset. Note, orthough this looks complicated we are doing this
    // in the vertex shader, so it should not cause a performance issue.
    pos += bitangent.xyz * offset * sqrt(1.0 + pow(abs(tanHalfAngle), 2.0));

    vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projectionMatrix * mvPosition;

    // Pass extruded position to fragment shader.
    #ifdef USE_TILE_CLIP
    vPosition = pos;
    #endif

    #ifdef USE_COLOR
    // Pass vertex color to fragment shader.
    vColor = color;
    #endif

    #ifdef USE_FADING
    #include <fading_vertex>
    #endif

    #include <fog_vertex>
}`;
const fragmentSource = `
precision highp float;
precision highp int;

uniform vec3 diffuse;
uniform vec3 outlineColor;
uniform float opacity;
uniform float extrusionWidth;
uniform float outlineWidth;
uniform vec2 tileSize;
uniform vec2 drawRange;

#ifdef USE_DASHED_LINE
uniform float dashSize;
uniform float gapSize;
uniform vec3 dashColor;

#define DASHES_SQUARE ${LineDashesModes.DASHES_SQUARE}
#define DASHES_ROUND ${LineDashesModes.DASHES_ROUND}
#define DASHES_DIAMOND ${LineDashesModes.DASHES_DIAMOND}
#endif

#ifdef USE_TILE_CLIP
varying vec3 vPosition;
#endif

varying vec3 vRange;
varying vec4 vCoords;
#ifdef USE_COLOR
varying vec3 vColor;
#endif

#include <round_edges_and_add_caps>
#include <tile_clip_func>

#ifdef USE_FADING
#include <fading_pars_fragment>
#endif

#include <fog_pars_fragment>

void main() {
    float alpha = opacity;
    vec3 outputDiffuse = diffuse;

    #ifdef USE_TILE_CLIP
    tileClip(vPosition.xy, tileSize);
    #endif

    // Calculate distance to center (0.0: lineCenter, 1.0: lineEdge).
    float distToCenter = roundEdgesAndAddCaps(vCoords, vRange);
    // Calculate distance to edge (-1.0: lineCenter, 0.0: lineEdge).
    float distToEdge = distToCenter - (extrusionWidth + outlineWidth) / extrusionWidth;

    // Decrease the line opacity by the distToEdge, making the transition steeper when the slope
    // of distToChange increases (i.e. the line is further away).
    float width = fwidth(distToEdge);

    float s = opacity < 0.98
        ? clamp((distToEdge + width) / (2.0 * width), 0.0, 1.0) // prefer a boxstep
        : smoothstep(-width, width, distToEdge);

    if (opacity < 0.98 && 1.0 - s < opacity) {
        // drop the fragment when the line is using opacity.
        discard;
    }

    alpha *= 1.0 - s;

    #ifdef USE_DASHED_LINE
    // Compute the distance to the dash origin (0.0: dashOrigin, 1.0: dashEnd, (d+g)/d: gapEnd).
    float d = dashSize / vRange.x;
    float g = gapSize / vRange.x;
    float distToDashOrigin = mod(vCoords.x, d + g) / d;

    // Compute distance to dash edge (0.5: dashCenter, 0.0: dashEdge) and compute the
    // dashBlendFactor similarly on how we did it for the line opacity.
    float distToDashEdge = 0.5 - distance(distToDashOrigin, (d + g) / d * 0.5);
    #if DASHES_MODE == DASHES_ROUND
    distToDashEdge = 0.5 - distance(vec2(distToCenter * 0.5, distToDashEdge), vec2(0.0, 0.5));
    #elif DASHES_MODE == DASHES_DIAMOND
    distToDashEdge -= distToCenter * 0.5;
    #endif
    float dashWidth = fwidth(distToDashEdge);
    float dashBlendFactor = 1.0 - smoothstep(-dashWidth, dashWidth, distToDashEdge);

    #ifdef USE_DASH_COLOR
    outputDiffuse = mix(diffuse, dashColor, dashBlendFactor);
    #endif
    #endif

    #ifdef USE_OUTLINE
    // Calculate distance to outline (0.0: lineEdge, outlineWidth/lineWidth: outlineEdge) and
    // compute the outlineBlendFactor (used to mix line and outline colors).
    float distToOutline = distToCenter - 1.0;
    float outlineWidth = fwidth(distToOutline);
    float outlineBlendFactor = smoothstep(-outlineWidth, outlineWidth, distToOutline);

    // Mix the colors using the different computed factors.
    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)
    float colorBlendFactor = smoothstep(-1.0, 1.0, dashBlendFactor - outlineBlendFactor);
    outputDiffuse = mix(
      mix(
        mix(outlineColor, diffuse, colorBlendFactor),
        outputDiffuse,
        dashBlendFactor
      ),
      outlineColor,
      outlineBlendFactor
    );
    #else
    outputDiffuse = mix(outputDiffuse, outlineColor, outlineBlendFactor);
    #endif
    #endif

    #if defined(USE_DASHED_LINE) && !defined(USE_DASH_COLOR)
    // Multiply the alpha by the dashBlendFactor.
    #if defined(USE_OUTLINE)
    alpha *= clamp(dashBlendFactor + outlineBlendFactor, 0.0, 1.0);
    #else
    alpha *= 1.0 - dashBlendFactor;
    #endif
    #endif

    #ifdef USE_COLOR
    gl_FragColor = vec4( outputDiffuse * vColor, alpha );
    #else
    gl_FragColor = vec4( outputDiffuse, alpha );
    #endif

    #include <fog_fragment>

    #ifdef USE_FADING
    #include <fading_fragment>
    #endif
}`;
/**
 * Material designed to render solid variable-width lines.
 */
class SolidLineMaterial extends RawShaderMaterial_1.RawShaderMaterial {
    /**
     * Constructs a new `SolidLineMaterial`.
     *
     * @param params - `SolidLineMaterial` parameters. Always required except when cloning another
     * material.
     */
    constructor(params) {
        var _a;
        Object.assign(THREE.ShaderChunk, LinesChunks_1.default);
        MapMeshMaterials_1.FadingFeature.patchGlobalShaderChunks();
        // Setup default defines.
        const defines = {
            CAPS_MODE: LinesChunks_1.LineCapsModes.CAPS_ROUND,
            DASHES_MODE: LineDashesModes.DASHES_SQUARE
        };
        // Prepare defines based on params passed in, before super class c-tor, this ensures
        // proper set for shader compilation, without need to re-compile.
        let fogParam = true;
        let opacityParam = 1.0;
        let displacementMap;
        let shaderParams;
        if (params) {
            fogParam = params.fog === true;
            if (fogParam) {
                Utils_1.setShaderDefine(defines, "USE_FOG", true);
            }
            opacityParam = params.opacity !== undefined ? params.opacity : opacityParam;
            displacementMap = params.displacementMap;
            if (displacementMap !== undefined) {
                Utils_1.setShaderDefine(defines, "USE_DISPLACEMENTMAP", true);
            }
            const hasOutline = params.outlineWidth !== undefined && params.outlineWidth > 0;
            if (hasOutline) {
                Utils_1.setShaderDefine(defines, "USE_OUTLINE", true);
            }
            shaderParams = {
                name: "SolidLineMaterial",
                vertexShader: vertexSource,
                fragmentShader: fragmentSource,
                uniforms: THREE.UniformsUtils.merge([
                    {
                        diffuse: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                        dashColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                        outlineColor: new THREE.Uniform(new THREE.Color(SolidLineMaterial.DEFAULT_COLOR)),
                        extrusionWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_WIDTH),
                        outlineWidth: new THREE.Uniform(SolidLineMaterial.DEFAULT_OUTLINE_WIDTH),
                        offset: new THREE.Uniform(SolidLineMaterial.DEFAULT_OFFSET),
                        opacity: new THREE.Uniform(SolidLineMaterial.DEFAULT_OPACITY),
                        tileSize: new THREE.Uniform(new THREE.Vector2()),
                        fadeNear: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_NEAR),
                        fadeFar: new THREE.Uniform(MapMeshMaterials_1.FadingFeature.DEFAULT_FADE_FAR),
                        displacementMap: new THREE.Uniform(displacementMap !== undefined ? displacementMap : new THREE.Texture()),
                        drawRange: new THREE.Uniform(new THREE.Vector2(SolidLineMaterial.DEFAULT_DRAW_RANGE_START, SolidLineMaterial.DEFAULT_DRAW_RANGE_END)),
                        dashSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_DASH_SIZE),
                        gapSize: new THREE.Uniform(SolidLineMaterial.DEFAULT_GAP_SIZE)
                    },
                    // We need the fog uniforms available when we use `fog` setter as the internal
                    // recompilation cannot add or remove uniforms.
                    THREE.UniformsLib.fog
                ]),
                defines,
                // No need to pass overridden `fog` and `opacity` params they will be set
                // after super c-tor call.
                fog: fogParam,
                opacity: opacityParam,
                rendererCapabilities: params.rendererCapabilities
            };
        }
        super(shaderParams);
        // Required to satisfy compiler error if fields has no initializer or are not definitely
        // assigned in the constructor, this also mimics ShaderMaterial set of defaults
        // for overridden props.
        this.m_fog = fogParam;
        this.m_opacity = opacityParam;
        // initialize the stencil pass
        this.stencilFunc = THREE.NotEqualStencilFunc;
        this.stencilZPass = THREE.ReplaceStencilOp;
        this.stencilRef = 1;
        this.stencilWrite = false;
        Utils_1.enforceBlending(this);
        this.extensions.derivatives = true;
        // Apply initial parameter values.
        if (params) {
            if (params.color !== undefined) {
                tmpColor.set(params.color);
                this.color = tmpColor;
            }
            if (params.outlineColor !== undefined) {
                tmpColor.set(params.outlineColor);
                this.outlineColor = tmpColor;
            }
            if (params.lineWidth !== undefined) {
                this.lineWidth = params.lineWidth;
            }
            if (params.outlineWidth !== undefined) {
                this.outlineWidth = params.outlineWidth;
            }
            if (params.opacity !== undefined) {
                this.opacity = params.opacity;
            }
            if (params.depthTest !== undefined) {
                this.depthTest = params.depthTest;
            }
            if (params.depthWrite !== undefined) {
                this.depthWrite = params.depthWrite;
            }
            if (params.fadeNear !== undefined) {
                this.fadeNear = params.fadeNear;
            }
            if (params.fadeFar !== undefined) {
                this.fadeFar = params.fadeFar;
            }
            if (params.displacementMap !== undefined) {
                this.displacementMap = params.displacementMap;
            }
            if (params.caps !== undefined) {
                this.caps = params.caps;
            }
            if (params.drawRangeStart !== undefined) {
                this.drawRangeStart = params.drawRangeStart;
            }
            if (params.drawRangeEnd !== undefined) {
                this.drawRangeEnd = params.drawRangeEnd;
            }
            if (params.dashes !== undefined) {
                this.dashes = params.dashes;
            }
            if (params.dashColor !== undefined) {
                tmpColor.set(params.dashColor);
                this.dashColor = tmpColor;
            }
            if (params.dashSize !== undefined) {
                this.dashSize = params.dashSize;
            }
            if (params.gapSize !== undefined) {
                this.gapSize = params.gapSize;
            }
            if (params.fog !== undefined) {
                this.fog = params.fog;
            }
            this.offset = (_a = params.offset) !== null && _a !== void 0 ? _a : 0;
            // ShaderMaterial overrides requires invalidation cause super c-tor may set this
            // properties before related `defines` and `uniforms` were created.
            this.invalidateFog();
            this.invalidateOpacity();
        }
    }
    /**
     * Overrides THREE.Material.fog flag to add support for custom shader.
     *
     * @param enable - Whether we want to enable the fog.
     */
    set fog(enable) {
        this.m_fog = enable;
        // Function may be called from THREE.js cause we override setter,
        // in this case defines are not yet initialized and require late invalidation in
        // SolidLineMaterial c-tor.
        if (this.defines !== undefined) {
            Utils_1.setShaderMaterialDefine(this, "USE_FOG", enable);
        }
    }
    /**
     * Checks if fog is enabled.
     */
    get fog() {
        return this.m_fog && Utils_1.getShaderMaterialDefine(this, "USE_FOG") === true;
    }
    /**
     * Sets the offset used to shift the line in world space perpendicular to the direction.
     */
    set offset(offset) {
        this.uniforms.offset.value = offset;
    }
    /**
     * @return The offset to shift the line in world space perpendicular to the direction.
     */
    get offset() {
        return this.uniforms.offset.value;
    }
    /**
     * The method to call to recompile a material to enable/disable outline effect
     *
     * @param enable - Whether we want to use outline.
     */
    set outline(enable) {
        Utils_1.setShaderMaterialDefine(this, "USE_OUTLINE", enable);
    }
    /**
     * Checks if outline is enabled.
     */
    get outline() {
        return Utils_1.getShaderMaterialDefine(this, "USE_OUTLINE") === true;
    }
    /**
     * Line opacity.
     */
    get opacity() {
        return this.m_opacity;
    }
    set opacity(value) {
        var _a;
        this.m_opacity = value;
        // Setting opacity before uniform being created requires late invalidation,
        // call to invalidateOpacity() is done at the end of c-tor.
        if ((_a = this.uniforms) === null || _a === void 0 ? void 0 : _a.opacity) {
            this.uniforms.opacity.value = value;
        }
        this.stencilWrite = this.m_opacity < 0.98;
    }
    /**
     * Line color.
     */
    get color() {
        return this.uniforms.diffuse.value;
    }
    set color(value) {
        this.uniforms.diffuse.value.copy(value);
    }
    /**
     * Outline color.
     *
     * @note The width of outline ([[outlineWidth]]) need to be also set to enable outlining.
     */
    get outlineColor() {
        return this.uniforms.outlineColor.value;
    }
    set outlineColor(value) {
        this.uniforms.outlineColor.value.copy(value);
    }
    /**
     * Dash color.
     *
     * @note The property [[gapSize]] need to be set to enable dashed line.
     */
    get dashColor() {
        return this.uniforms.dashColor.value;
    }
    set dashColor(value) {
        this.uniforms.dashColor.value.copy(value);
        Utils_1.setShaderMaterialDefine(this, "USE_DASH_COLOR", true);
    }
    /**
     * Line width.
     */
    get lineWidth() {
        return this.uniforms.extrusionWidth.value * 2;
    }
    set lineWidth(value) {
        this.uniforms.extrusionWidth.value = value / 2;
    }
    /**
     * Outline width.
     */
    get outlineWidth() {
        return this.uniforms.outlineWidth.value;
    }
    set outlineWidth(value) {
        this.uniforms.outlineWidth.value = value;
        this.outline = value > 0.0;
    }
    /**
     * Size of the dashed segments.
     *
     * @note Ths [[gapSize]] need to be also set to enable dashed line.
     * @see gapSize.
     */
    get dashSize() {
        return this.uniforms.dashSize.value;
    }
    set dashSize(value) {
        this.uniforms.dashSize.value = value;
    }
    /**
     * Size of the gaps between dashed segments.
     *
     * @note You may also need to set [[dashSize]].
     * @see dashSize.
     */
    get gapSize() {
        return this.uniforms.gapSize.value;
    }
    set gapSize(value) {
        var _a, _b;
        this.uniforms.gapSize.value = value;
        Utils_1.setShaderMaterialDefine(this, "USE_DASHED_LINE", value > 0.0);
        if (((_b = (_a = this.uniforms) === null || _a === void 0 ? void 0 : _a.gapSize) === null || _b === void 0 ? void 0 : _b.value) === 0) {
            this.stencilWrite = this.m_opacity < 0.98;
        }
    }
    /**
     * Caps mode.
     */
    get caps() {
        let result = "Round";
        const capsMode = Utils_1.getShaderMaterialDefine(this, "CAPS_MODE");
        // Sanity check if material define is numerical and has direct mapping to LineCaps type.
        if (typeof capsMode === "number" && DefinesLineCapsMapping.hasOwnProperty(capsMode)) {
            result = DefinesLineCapsMapping[capsMode];
        }
        return result;
    }
    set caps(value) {
        // Line caps mode may be set directly from theme, thus we need to check value
        // for correctness and provide string to define mapping in fragment shader.
        if (LineCapsDefinesMapping.hasOwnProperty(value)) {
            Utils_1.setShaderMaterialDefine(this, "CAPS_MODE", LineCapsDefinesMapping[value]);
        }
    }
    /**
     * Dashes mode.
     */
    get dashes() {
        let result = "Square";
        const dashesMode = Utils_1.getShaderMaterialDefine(this, "DASHES_MODE");
        // Sanity check if material define is numerical and has direct mapping to LineDashes type.
        if (typeof dashesMode === "number" && DefinesLineDashesMapping.hasOwnProperty(dashesMode)) {
            result = DefinesLineDashesMapping[dashesMode];
        }
        return result;
    }
    set dashes(value) {
        // Line dashes mode may be set directly from theme, thus we need to check value
        // for correctness and provide string to define mapping in fragment shader.
        if (LineDashesDefinesMapping.hasOwnProperty(value)) {
            Utils_1.setShaderMaterialDefine(this, "DASHES_MODE", LineDashesDefinesMapping[value]);
        }
    }
    get fadeNear() {
        return this.uniforms.fadeNear.value;
    }
    set fadeNear(value) {
        this.uniforms.fadeNear.value = value;
    }
    get fadeFar() {
        return this.uniforms.fadeFar.value;
    }
    set fadeFar(value) {
        this.uniforms.fadeFar.value = value;
        Utils_1.setShaderMaterialDefine(this, "USE_FADING", value > 0.0);
    }
    get displacementMap() {
        return this.uniforms.displacementMap.value;
    }
    set displacementMap(map) {
        if (this.uniforms.displacementMap.value === map) {
            return;
        }
        this.uniforms.displacementMap.value = map;
        const useDisplacementMap = map !== null;
        if (useDisplacementMap) {
            this.uniforms.displacementMap.value.needsUpdate = true;
        }
        Utils_1.setShaderMaterialDefine(this, "USE_DISPLACEMENTMAP", useDisplacementMap);
    }
    get drawRangeStart() {
        return this.uniforms.drawRange.value.x;
    }
    set drawRangeStart(value) {
        this.uniforms.drawRange.value.x = value;
    }
    get drawRangeEnd() {
        return this.uniforms.drawRange.value.y;
    }
    set drawRangeEnd(value) {
        this.uniforms.drawRange.value.y = value;
    }
    set clipTileSize(tileSize) {
        this.uniforms.tileSize.value.copy(tileSize);
        const useTileClip = tileSize.x > 0 && tileSize.y > 0;
        Utils_1.setShaderMaterialDefine(this, "USE_TILE_CLIP", useTileClip);
    }
    get clipTileSize() {
        return this.uniforms.tileSize.value;
    }
    copy(other) {
        super.copy(other);
        this.fog = other.fog;
        this.opacity = other.opacity;
        return this;
    }
    invalidateFog() {
        if (this.m_fog !== Utils_1.getShaderMaterialDefine(this, "USE_FOG")) {
            Utils_1.setShaderMaterialDefine(this, "USE_FOG", this.m_fog);
        }
    }
    invalidateOpacity() {
        if (this.m_opacity !== this.uniforms.opacity.value) {
            this.uniforms.opacity.value = this.m_opacity;
        }
    }
}
exports.SolidLineMaterial = SolidLineMaterial;
SolidLineMaterial.DEFAULT_COLOR = 0xff0000;
SolidLineMaterial.DEFAULT_WIDTH = 1.0;
SolidLineMaterial.DEFAULT_OUTLINE_WIDTH = 0.0;
SolidLineMaterial.DEFAULT_OPACITY = 1.0;
SolidLineMaterial.DEFAULT_DRAW_RANGE_START = 0.0;
SolidLineMaterial.DEFAULT_DRAW_RANGE_END = 1.0;
SolidLineMaterial.DEFAULT_DASH_SIZE = 1.0;
SolidLineMaterial.DEFAULT_GAP_SIZE = 1.0;
SolidLineMaterial.DEFAULT_OFFSET = 0.0;
//# sourceMappingURL=SolidLineMaterial.js.map