"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CirclePointsMaterial = void 0;
const THREE = require("three");
const Utils_1 = require("./Utils");
const vertexShader = `
uniform float size;

void main() {
    vec3 transformed = vec3(position);
    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);

    gl_Position = projectionMatrix * mvPosition;
    gl_PointSize = size;
}
`;
const fragmentShader = `
uniform vec3 diffuse;
uniform float opacity;

void main() {
    float alpha = opacity;

    float radius = 0.5;
    vec2 coords = gl_PointCoord.xy - vec2(0.5);
    float len = length(coords);
    float falloff = fwidth(len);
    float threshold = 1.0 - smoothstep(radius - falloff, radius, len);
    alpha *= threshold;

    gl_FragColor = vec4(diffuse, alpha);
}`;
/**
 * Material designed to render circle points. Note that it is always transparent since the circle
 * shape is created with an alpha channel to benefit an antialising that a mere `discard` could
 * not bring.
 */
class CirclePointsMaterial extends THREE.ShaderMaterial {
    /**
     * Constructs a new `CirclePointsMaterial`.
     *
     * @param parameters - The constructor's parameters.
     */
    constructor(parameters = {}) {
        const { size, color, opacity } = parameters, shaderParams = __rest(parameters, ["size", "color", "opacity"]);
        shaderParams.name = "CirclePointsMaterial";
        shaderParams.vertexShader = vertexShader;
        shaderParams.fragmentShader = fragmentShader;
        shaderParams.uniforms = {
            size: new THREE.Uniform(CirclePointsMaterial.DEFAULT_CIRCLE_SIZE),
            diffuse: new THREE.Uniform(new THREE.Color()),
            opacity: new THREE.Uniform(1.0)
        };
        shaderParams.depthTest = false;
        shaderParams.extensions = Object.assign(Object.assign({}, shaderParams.extensions), { derivatives: true });
        super(shaderParams);
        // Blending needs to always be enabled to support smooth edges
        Utils_1.enforceBlending(this);
        this.type = "CirclePointsMaterial";
        this.m_color = this.uniforms.diffuse.value;
        this.m_opacity = this.uniforms.opacity.value;
        if (size !== undefined) {
            this.size = size;
        }
        if (color !== undefined) {
            this.color = color;
        }
        if (opacity !== undefined) {
            this.opacity = opacity;
        }
    }
    /**
     * Gets the circle screen size.
     */
    get size() {
        return this.uniforms.size.value;
    }
    /**
     * Sets the circle screen size.
     */
    set size(size) {
        this.uniforms.size.value = size;
    }
    /**
     * Get circle opacity.
     */
    get opacity() {
        return this.m_opacity;
    }
    /**
     * Set circle opacity.
     */
    set opacity(opacity) {
        this.m_opacity = opacity;
        // Base constructor may set opacity before uniform being created.
        if (this.uniforms && this.uniforms.opacity) {
            this.uniforms.opacity.value = opacity;
        }
    }
    /**
     * Gets the diffuse.
     */
    get color() {
        return this.m_color;
    }
    /**
     * Sets the diffuse.
     */
    set color(color) {
        this.m_color.set(color);
    }
}
exports.CirclePointsMaterial = CirclePointsMaterial;
CirclePointsMaterial.DEFAULT_CIRCLE_SIZE = 1;
//# sourceMappingURL=CirclePointsMaterial.js.map