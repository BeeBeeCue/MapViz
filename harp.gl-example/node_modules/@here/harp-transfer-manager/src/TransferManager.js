"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TransferManager = void 0;
/** @module
 *
 * This module provides classes to ease downloading URLs. In particular, following redirects,
 * retrying on HTTP errors, and limiting the number of parallel concurrent downloads.
 */
require("@here/harp-fetch");
const DeferredPromise_1 = require("./DeferredPromise");
/**
 * `TransferManager` for downloading URLs.
 *
 * Features:
 *
 * * Merges JSON downloads, for example, the same URL if requested as JSON will only be downloaded
 *   once.
 * * Limits the amount of parallel downloads, useful when requesting a large amount of URLs that
 *   would otherwise stall the browser.
 * * Retries the downloads with an increasing timeout on HTTP 503 replies.
 *
 * The static method [[instance]] can be used to get a default constructed instance.
 */
class TransferManager {
    /**
     * Constructs a new [[TransferManager]].
     *
     * @param fetchFunction - The default fetch function to use.
     * @param maxRetries - The maximum amount to try to re-fetch a resource.
     */
    constructor(fetchFunction = fetch, maxRetries = 5) {
        this.fetchFunction = fetchFunction;
        this.maxRetries = maxRetries;
        this.activeDownloadCount = 0;
        this.downloadQueue = new Array();
        this.activeDownloads = new Map();
    }
    /**
     * Returns a default instance of [[TransferManager]].
     */
    static instance() {
        return TransferManager.defaultInstance;
    }
    static async fetchRepeatedly(fetchFunction, retryCount, maxRetries, url, init) {
        try {
            if (retryCount < maxRetries) {
                const response = await fetchFunction(url, init);
                if (response.status !== 503) {
                    return response;
                }
            }
            else {
                throw new Error("Max number of retries reached");
            }
        }
        catch (err) {
            if (err.hasOwnProperty("isCancelled") ||
                err.name === "AbortError" ||
                retryCount >= maxRetries) {
                throw err;
            }
        }
        return await TransferManager.waitFor(TransferManager.retryTimeout * retryCount).then(() => TransferManager.fetchRepeatedly(fetchFunction, retryCount + 1, maxRetries, url, init));
    }
    static waitFor(milliseconds) {
        return new Promise(resolve => setTimeout(resolve, milliseconds));
    }
    /**
     * Downloads a JSON object. Merges downloads of string URLs if requested multiple times.
     *
     * Note: This method merges multiple downloads of the same string URL to
     * only one request. The init parameter is ignored if the download is merged.
     * Call [[download]] instead to download the resource without merging.
     *
     * @param url - The URL or RequestInfo to download
     * @param init - Optional extra parameters for the download.
     */
    downloadJson(url, init) {
        return this.downloadAs(response => response.json(), url, init);
    }
    /**
     * Downloads a binary object. Merges downloads of string URLS if requested multiple times.
     *
     * Note: This method merges multiple downloads of the same string URL to
     * only one request. The init parameter is ignored if the download is merged.
     * Call [[download]] instead to download the resource without merging.
     *
     * @param url - The URL or RequestInfo to download
     * @param init - Optional extra parameters for the download
     */
    downloadArrayBuffer(url, init) {
        return this.download(url, init).then(response => response.arrayBuffer());
    }
    /**
     * Downloads a URL and returns the response.
     *
     * Does not merge multiple requests to the same URL.
     *
     * @param url - The URL or RequestInfo to download.
     * @param init - Optional extra parameters for the download.
     */
    download(url, init) {
        if (this.activeDownloadCount >= TransferManager.maxParallelDownloads) {
            const deferred = new DeferredPromise_1.DeferredPromise(() => this.doDownload(url, init));
            this.downloadQueue.push(deferred);
            return deferred.promise;
        }
        return this.doDownload(url, init);
    }
    async doDownload(url, init) {
        try {
            ++this.activeDownloadCount;
            const response = await TransferManager.fetchRepeatedly(this.fetchFunction, 0, this.maxRetries, url, init);
            this.onDownloadDone();
            return response;
        }
        catch (error) {
            this.onDownloadDone();
            throw error;
        }
    }
    onDownloadDone() {
        --this.activeDownloadCount;
        this.execDeferredDownload();
    }
    execDeferredDownload() {
        const future = this.downloadQueue.pop();
        if (future === undefined) {
            return;
        }
        future.exec();
    }
    downloadAs(converter, url, init) {
        const cacheKey = url;
        const pendingFetch = this.activeDownloads.get(cacheKey);
        if (pendingFetch !== undefined) {
            return Promise.resolve(pendingFetch);
        }
        const newFetch = this.download(url, init)
            .then(response => {
            this.activeDownloads.delete(cacheKey);
            if (response.ok) {
                return converter(response);
            }
            throw new Error(JSON.stringify(response));
        })
            .catch(err => {
            this.activeDownloads.delete(cacheKey);
            throw err;
        });
        this.activeDownloads.set(cacheKey, newFetch);
        return newFetch;
    }
}
exports.TransferManager = TransferManager;
/**
 * The timeout in milliseconds to wait between retries. This timeout is multiplied with the
 * number of retries. First retry waits for 0 ms, second retry for 500 ms, third for 1000 ms and
 * so on.
 */
TransferManager.retryTimeout = 500;
/**
 * The amount of maximum parallel downloads to allow.
 */
TransferManager.maxParallelDownloads = 16;
TransferManager.defaultInstance = new TransferManager();
//# sourceMappingURL=TransferManager.js.map