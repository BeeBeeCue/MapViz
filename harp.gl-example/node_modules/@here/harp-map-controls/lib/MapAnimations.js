"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraPanAnimation = exports.CameraRotationAnimation = exports.CameraAnimation = exports.InterpolationFunction = exports.EasingFunction = void 0;
const harp_geoutils_1 = require("@here/harp-geoutils");
const harp_utils_1 = require("@here/harp-utils");
const TWEEN = require("@tweenjs/tween.js");
const THREE = require("three");
const MapControls_1 = require("./MapControls");
/**
 * Functions used for specifying animations' speed.
 */
var EasingFunction;
(function (EasingFunction) {
    EasingFunction[EasingFunction["Linear"] = 0] = "Linear";
    EasingFunction[EasingFunction["QuadraticIn"] = 1] = "QuadraticIn";
    EasingFunction[EasingFunction["QuadraticOut"] = 2] = "QuadraticOut";
    EasingFunction[EasingFunction["QuadraticInOut"] = 3] = "QuadraticInOut";
    EasingFunction[EasingFunction["CubicIn"] = 4] = "CubicIn";
    EasingFunction[EasingFunction["CubicOut"] = 5] = "CubicOut";
    EasingFunction[EasingFunction["CubicInOut"] = 6] = "CubicInOut";
    EasingFunction[EasingFunction["QuarticIn"] = 7] = "QuarticIn";
    EasingFunction[EasingFunction["QuarticOut"] = 8] = "QuarticOut";
    EasingFunction[EasingFunction["QuarticInOut"] = 9] = "QuarticInOut";
    EasingFunction[EasingFunction["QuinticIn"] = 10] = "QuinticIn";
    EasingFunction[EasingFunction["QuinticOut"] = 11] = "QuinticOut";
    EasingFunction[EasingFunction["QuinticInOut"] = 12] = "QuinticInOut";
    EasingFunction[EasingFunction["SinusoidalIn"] = 13] = "SinusoidalIn";
    EasingFunction[EasingFunction["SinusoidalOut"] = 14] = "SinusoidalOut";
    EasingFunction[EasingFunction["SinusoidalInOut"] = 15] = "SinusoidalInOut";
    EasingFunction[EasingFunction["ExponentialIn"] = 16] = "ExponentialIn";
    EasingFunction[EasingFunction["ExponentialOut"] = 17] = "ExponentialOut";
    EasingFunction[EasingFunction["ExponentialInOut"] = 18] = "ExponentialInOut";
    EasingFunction[EasingFunction["CircularIn"] = 19] = "CircularIn";
    EasingFunction[EasingFunction["CircularOut"] = 20] = "CircularOut";
    EasingFunction[EasingFunction["CircularInOut"] = 21] = "CircularInOut";
    EasingFunction[EasingFunction["ElasticIn"] = 22] = "ElasticIn";
    EasingFunction[EasingFunction["ElasticOut"] = 23] = "ElasticOut";
    EasingFunction[EasingFunction["ElasticInOut"] = 24] = "ElasticInOut";
    EasingFunction[EasingFunction["BackIn"] = 25] = "BackIn";
    EasingFunction[EasingFunction["BackOut"] = 26] = "BackOut";
    EasingFunction[EasingFunction["BackInOut"] = 27] = "BackInOut";
    EasingFunction[EasingFunction["BounceIn"] = 28] = "BounceIn";
    EasingFunction[EasingFunction["BounceOut"] = 29] = "BounceOut";
    EasingFunction[EasingFunction["BounceInOut"] = 30] = "BounceInOut";
})(EasingFunction = exports.EasingFunction || (exports.EasingFunction = {}));
/**
 * Functions used to generate intermediate animation values.
 */
var InterpolationFunction;
(function (InterpolationFunction) {
    InterpolationFunction[InterpolationFunction["Linear"] = 0] = "Linear";
    InterpolationFunction[InterpolationFunction["Bezier"] = 1] = "Bezier";
    InterpolationFunction[InterpolationFunction["CatmullRom"] = 2] = "CatmullRom";
})(InterpolationFunction = exports.InterpolationFunction || (exports.InterpolationFunction = {}));
/**
 * Abstract class used as base to define camera animations.
 */
class CameraAnimation {
    /**
     * Creates a new `CameraAnimation` object.
     *
     * @param mapView - [[MapView]] which will be affected by the animation.
     * @param name - Animation's name.
     */
    constructor(mapView, name) {
        this.mapView = mapView;
        this.name = name;
        /**
         * `True` if animation is being played.
         */
        this.running = false;
        /**
         * `True` if the animation has been interrupted.
         */
        this.stopped = false;
        /**
         * Duration of a whole animation in milliseconds. Defaults to `10` seconds.
         */
        this.duration = 10000;
        /**
         * Number of times the animation should be repeated. Defaults to `0`.
         */
        this.repeat = 0;
        /**
         * Easing function that control acceleration. Defaults to [[EasingFunction.Linear]].
         */
        this.easing = TWEEN.Easing.Linear.None;
        checkSetupTween();
    }
    /**
     * Update function is to be called before the next frame is rendered.
     */
    update(time) {
        if (this.tween) {
            return this.tween.update(time !== null && time !== void 0 ? time : harp_utils_1.PerformanceTimer.now());
        }
        return false;
    }
    /**
     * Returns `true` if the animation is being played.
     */
    get isRunning() {
        return this.running;
    }
}
exports.CameraAnimation = CameraAnimation;
/**
 * Create an animation around the Z-axis of the camera.
 */
class CameraRotationAnimation extends CameraAnimation {
    /**
     * Creates a new `CameraRotationAnimation` object.
     *
     * @param mapView - [[MapView]] which will be affected by the animation.
     * @param m_mapControls - [[MapControls]] this animation will be taking control of.
     * @param options - Animation's options.
     * @param name - Animation's name.
     */
    constructor(mapView, m_mapControls, options, name) {
        var _a;
        super(mapView, name);
        this.m_mapControls = m_mapControls;
        /**
         * Initial camera rotation (in the Z-axis).
         */
        this.startAngle = 0;
        /**
         * Final camera rotation (in the Z-axis).
         */
        this.endAngle = 360;
        this.m_axis = new THREE.Vector3(0, 0, 1);
        this.beginInteractionListener = () => {
            if (!this.stopped) {
                this.stopTween();
            }
        };
        this.endInteractionListener = () => {
            if (!this.stopped) {
                this.startTween();
            }
        };
        if (options.axis !== undefined) {
            this.m_axis = options.axis;
        }
        if (options.startAngle !== undefined) {
            this.startAngle = options.startAngle;
        }
        if (options.endAngle !== undefined) {
            this.endAngle = options.endAngle;
        }
        if (options.duration !== undefined) {
            this.duration = options.duration;
        }
        if (options.repeat !== undefined) {
            this.repeat = options.repeat;
        }
        if (options.easing !== undefined) {
            this.easing =
                typeof options.easing === "function"
                    ? options.easing
                    : (_a = easingMap.get(options.easing)) !== null && _a !== void 0 ? _a : TWEEN.Easing.Linear.None;
        }
        this.m_lastRotationValue = this.startAngle;
    }
    /**
     * Start the animation.
     *
     * @param time - Duration of the animation in milliseconds.
     * @param onFinished - Callback that gets triggered once the animation ends.
     * @override
     */
    start(time, onFinished) {
        if (this.running) {
            throw new Error("Animation already running" + this.name !== undefined ? this.name : "");
        }
        this.running = true;
        this.onFinished = onFinished;
        this.stopped = false;
        if (this.m_mapControls) {
            this.m_mapControls.addEventListener(MapControls_1.EventNames.BeginInteraction, this.beginInteractionListener);
            this.m_mapControls.addEventListener(MapControls_1.EventNames.EndInteraction, this.endInteractionListener);
        }
        this.startTween(time);
        this.mapView.beginAnimation();
    }
    /**
     * Stop the animation. Can be started again (with original values only, though).
     * @override
     */
    stop() {
        if (!this.running) {
            throw new Error("Animation not running" + this.name !== undefined ? this.name : "");
        }
        this.running = false;
        this.stopped = true;
        this.mapView.endAnimation();
        if (this.tween) {
            this.tween.stop();
        }
        if (this.m_mapControls) {
            this.m_mapControls.removeEventListener(MapControls_1.EventNames.BeginInteraction, this.beginInteractionListener);
            this.m_mapControls.removeEventListener(MapControls_1.EventNames.EndInteraction, this.endInteractionListener);
        }
    }
    /**
     * Internal start of tween. Required because the tween may be interrupted by the
     * [[MapControls]].
     */
    startTween(time) {
        const rotZ = new THREE.Quaternion();
        this.m_userCamerRotation = new THREE.Quaternion();
        this.mapView.camera.getWorldQuaternion(this.m_userCamerRotation);
        // Create a tween to animate the camera rotation around the Z axis.
        //
        // make this a relative rotation, always starting from 0. Take into account the
        // lastRotationValue which may be a leftover from the previous run of "this" tween.
        this.tween = new TWEEN.Tween({ rotation: 0 })
            .to({ rotation: this.endAngle - this.m_lastRotationValue }, this.duration)
            .onComplete(() => {
            this.stop();
            if (this.onFinished) {
                this.onFinished();
            }
        })
            .onUpdate(({ rotation }) => {
            this.m_lastRotationValue = rotation;
            rotZ.setFromEuler(new THREE.Euler(0, 0, THREE.MathUtils.degToRad(rotation)));
            if (this.m_userCamerRotation !== undefined) {
                rotZ.multiply(this.m_userCamerRotation);
            }
            this.mapView.camera.quaternion.copy(rotZ);
        });
        this.tween.repeat(this.repeat);
        this.tween.easing(this.easing);
        this.tween.start(time);
    }
    /**
     * Internal stop of tween. Required because the tween may be interrupted by the [[MapControls]].
     */
    stopTween() {
        if (this.tween) {
            this.tween.stop();
        }
    }
}
exports.CameraRotationAnimation = CameraRotationAnimation;
/**
 * Class to pan between the specified geo coordinates. Height can be specified to move the camera in
 * and out.
 */
class CameraPanAnimation extends CameraAnimation {
    /**
     * Creates a new `CameraPanAnimation` object.
     *
     * @param mapView - [[MapView]] which will be affected by the animation.
     * @param options - Animation's options.
     * @param name - Animation's name.
     */
    constructor(mapView, options, name) {
        var _a, _b;
        super(mapView, name);
        this.name = name;
        /**
         * Specifies interpolation. Defaults to [[InterpolationFunction.CatmullRom]]
         */
        this.interpolation = TWEEN.Interpolation.CatmullRom;
        if (options.duration !== undefined) {
            this.duration = options.duration;
        }
        if (options.repeat !== undefined) {
            this.repeat = options.repeat;
        }
        if (options.easing !== undefined) {
            this.easing =
                typeof options.easing === "function"
                    ? options.easing
                    : (_a = easingMap.get(options.easing)) !== null && _a !== void 0 ? _a : TWEEN.Easing.Linear.None;
        }
        if (options.interpolation !== undefined) {
            this.interpolation =
                typeof options.interpolation === "function"
                    ? options.interpolation
                    : (_b = interpolationMap.get(options.interpolation)) !== null && _b !== void 0 ? _b : TWEEN.Interpolation.Linear;
        }
        this.m_geoCoordinates = options.geoCoordinates !== undefined ? options.geoCoordinates : [];
    }
    /**
     * Add a geo coordinate that should be visited.
     *
     * @param geoPos - Geographical coordinate to animate to.
     */
    addPosition(geoPos) {
        this.m_geoCoordinates.push(geoPos);
    }
    /**
     * Start the animation.
     *
     * @param time - Duration of the animation in milliseconds.
     * @param onFinished - Callback that gets triggered once the animation ends.
     * @override
     */
    start(time, onFinished) {
        var _a;
        if (this.running) {
            throw new Error("Animation already running" + this.name !== undefined ? this.name : "");
        }
        this.onFinished = onFinished;
        this.running = true;
        const from = new harp_geoutils_1.GeoCoordinates(this.mapView.geoCenter.latitude, this.mapView.geoCenter.longitude, this.mapView.camera.position.z);
        const to = {
            latitude: new Array(),
            longitude: new Array(),
            altitude: new Array()
        };
        for (const pos of this.m_geoCoordinates) {
            to.latitude.push(pos.latitude);
            to.longitude.push(pos.longitude);
            to.altitude.push((_a = pos.altitude) !== null && _a !== void 0 ? _a : this.mapView.camera.position.z);
        }
        this.tween = new TWEEN.Tween(from)
            .to(to, this.duration)
            .onComplete(() => {
            this.stop();
            if (this.onFinished) {
                this.onFinished();
            }
        })
            .onUpdate(({ latitude, longitude, altitude }) => {
            this.mapView.geoCenter = new harp_geoutils_1.GeoCoordinates(latitude, longitude, altitude);
            this.mapView.camera.position.z = altitude;
        });
        this.tween.repeat(this.repeat);
        this.tween.easing(this.easing);
        this.tween.interpolation(this.interpolation);
        this.tween.start(time);
        this.mapView.beginAnimation();
    }
    /**
     * Stop the animation. Can be started again (with original values only, though).
     * @override
     */
    stop() {
        if (!this.running) {
            throw new Error("Animation not running" + this.name !== undefined ? this.name : "");
        }
        this.running = false;
        this.mapView.endAnimation();
        if (this.tween) {
            this.tween.stop();
        }
    }
    /**
     * Returns `true` if the animation is being played.
     * @override
     */
    get isRunning() {
        return this.running;
    }
}
exports.CameraPanAnimation = CameraPanAnimation;
// Cannot use enum as map index in a typesave manner, otherwise I would love to make it more
// elegant...
let easingMap;
let interpolationMap;
function checkSetupTween() {
    if (easingMap !== undefined) {
        return;
    }
    easingMap = new Map();
    interpolationMap = new Map();
    easingMap.set(EasingFunction.Linear, TWEEN.Easing.Linear.None);
    easingMap.set(EasingFunction.QuadraticIn, TWEEN.Easing.Quadratic.In);
    easingMap.set(EasingFunction.QuadraticOut, TWEEN.Easing.Quadratic.Out);
    easingMap.set(EasingFunction.QuadraticInOut, TWEEN.Easing.Quadratic.InOut);
    easingMap.set(EasingFunction.CubicIn, TWEEN.Easing.Cubic.In);
    easingMap.set(EasingFunction.CubicOut, TWEEN.Easing.Cubic.Out);
    easingMap.set(EasingFunction.CubicInOut, TWEEN.Easing.Cubic.InOut);
    easingMap.set(EasingFunction.QuarticIn, TWEEN.Easing.Quartic.In);
    easingMap.set(EasingFunction.QuarticOut, TWEEN.Easing.Quartic.Out);
    easingMap.set(EasingFunction.QuarticInOut, TWEEN.Easing.Quartic.InOut);
    easingMap.set(EasingFunction.QuinticIn, TWEEN.Easing.Quintic.In);
    easingMap.set(EasingFunction.QuinticOut, TWEEN.Easing.Quintic.Out);
    easingMap.set(EasingFunction.QuinticInOut, TWEEN.Easing.Quintic.InOut);
    easingMap.set(EasingFunction.SinusoidalIn, TWEEN.Easing.Sinusoidal.In);
    easingMap.set(EasingFunction.SinusoidalOut, TWEEN.Easing.Sinusoidal.Out);
    easingMap.set(EasingFunction.SinusoidalInOut, TWEEN.Easing.Sinusoidal.InOut);
    easingMap.set(EasingFunction.ExponentialIn, TWEEN.Easing.Exponential.In);
    easingMap.set(EasingFunction.ExponentialOut, TWEEN.Easing.Exponential.Out);
    easingMap.set(EasingFunction.ExponentialInOut, TWEEN.Easing.Exponential.InOut);
    easingMap.set(EasingFunction.CircularIn, TWEEN.Easing.Circular.In);
    easingMap.set(EasingFunction.CircularOut, TWEEN.Easing.Circular.Out);
    easingMap.set(EasingFunction.CircularOut, TWEEN.Easing.Circular.InOut);
    easingMap.set(EasingFunction.ElasticIn, TWEEN.Easing.Elastic.In);
    easingMap.set(EasingFunction.ElasticOut, TWEEN.Easing.Elastic.Out);
    easingMap.set(EasingFunction.ElasticInOut, TWEEN.Easing.Elastic.InOut);
    easingMap.set(EasingFunction.BackIn, TWEEN.Easing.Back.In);
    easingMap.set(EasingFunction.BackOut, TWEEN.Easing.Back.Out);
    easingMap.set(EasingFunction.BackInOut, TWEEN.Easing.Back.InOut);
    easingMap.set(EasingFunction.BounceIn, TWEEN.Easing.Bounce.In);
    easingMap.set(EasingFunction.BounceOut, TWEEN.Easing.Bounce.Out);
    easingMap.set(EasingFunction.BounceInOut, TWEEN.Easing.Bounce.InOut);
    interpolationMap.set(InterpolationFunction.Linear, TWEEN.Interpolation.Linear);
    interpolationMap.set(InterpolationFunction.Bezier, TWEEN.Interpolation.Bezier);
    interpolationMap.set(InterpolationFunction.CatmullRom, TWEEN.Interpolation.CatmullRom);
}
//# sourceMappingURL=MapAnimations.js.map