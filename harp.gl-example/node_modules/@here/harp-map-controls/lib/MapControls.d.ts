import { EventDispatcher, MapView, MapViewUtils } from "@here/harp-mapview";
import * as THREE from "three";
export declare enum TiltState {
    Tilted = 0,
    Down = 1
}
/**
 * Map interaction events' names.
 */
export declare enum EventNames {
    Update = "update",
    BeginInteraction = "begin-interaction",
    EndInteraction = "end-interaction"
}
/**
 * This map control provides basic map-related building blocks to interact with the map. It also
 * provides a default way of handling user input. Currently we support basic mouse interaction and
 * touch input interaction.
 *
 * Mouse interaction:
 *  - Left mouse button + move = Panning the map.
 *  - Right mouse button + move = Orbits the camera around the focus point.
 *  - Middle mouse button + move = Rotating the view. Up down movement changes the pitch. Left/right
 *    movement changes the yaw.
 *  - Mouse wheel = Zooms up and down by one zoom level, zooms on target.
 *
 * Touch interaction:
 *  - One finger = Panning the map.
 *  - Two fingers = Scale, rotate and panning the map.
 *  - Three fingers = Orbiting the map. Up down movements influences the current orbit altitude.
 *    Left/right changes the azimuth.
 */
export declare class MapControls extends EventDispatcher {
    readonly mapView: MapView;
    /**
     * Creates MapControls object and attaches it specified [[MapView]].
     *
     * @param mapView - [[MapView]] object to which MapControls should be attached to.
     * @param disposeWithMapView - If `true`, an event with MapView is registered to dispose of
     * `MapControls` if MapView itself is disposed.
     */
    static create(mapView: MapView, disposeWithMapView?: boolean): MapControls;
    /**
     * This factor will be applied to the delta of the current mouse pointer position and the last
     * mouse pointer position: The result then will be used as an offset for the rotation then.
     * Default value is `0.1`.
     */
    rotationMouseDeltaFactor: number;
    /**
     * This factor will be applied to the delta of the current mouse pointer position and the last
     * mouse pointer position: The result then will be used as an offset to orbit the camera.
     * Default value is `0.1`.
     */
    orbitingMouseDeltaFactor: number;
    /**
     * This factor will be applied to the delta of the current touch pointer position and the last
     * touch pointer position: The result then will be used as an offset to orbit the camera.
     * Default value is `0.1`.
     */
    orbitingTouchDeltaFactor: number;
    /**
     * Set to `true` to enable input handling through this map control, `false` to disable input
     * handling. Even when disabling input handling, you can manually use the public functions to
     * change the view to the current map.
     */
    enabled: boolean;
    /**
     * Set to `true` to enable zooming through these controls, `false` otherwise.
     */
    zoomEnabled: boolean;
    /**
     * Set to `true` to enable panning through these controls, `false` otherwise.
     */
    panEnabled: boolean;
    /**
     * Set to `true` to enable tilting through these controls, `false` otherwise.
     */
    tiltEnabled: boolean;
    /**
     * Set to `true` to enable rotation through this map control, `false` to disable rotation.
     */
    rotateEnabled: boolean;
    /**
     * Set to `true` to enable an inertia dampening on zooming and panning. `false` cancels inertia.
     */
    inertiaEnabled: boolean;
    /**
     * Inertia damping duration for the zoom, in seconds.
     */
    zoomInertiaDampingDuration: number;
    /**
     * Inertia damping duration for the panning, in seconds.
     */
    panInertiaDampingDuration: number;
    /**
     * Duration in seconds of the camera animation when the tilt button is clicked. Independent of
     * inertia.
     */
    tiltToggleDuration: number;
    /**
     * Camera tilt to the target when tilting from the `toggleTilt` public method.
     */
    tiltAngle: number;
    /**
     * Duration of the animation to reset the camera to looking north, in seconds. Independent of
     * inertia.
     */
    northResetAnimationDuration: number;
    /**
     * Determines the zoom level delta for single mouse wheel movement. So after each mouse wheel
     * movement the current zoom level will be added or subtracted by this value. The default value
     * is `0.2` - this means that every 5th mouse wheel movement you will cross a zoom level.
     *
     * **Note**: To reverse the zoom direction, you can provide a negative value.
     */
    zoomLevelDeltaOnMouseWheel: number;
    /**
     * Zoom level delta when using the UI controls.
     */
    zoomLevelDeltaOnControl: number;
    /**
     * Determines the minimum zoom level we can zoom to.
     */
    minZoomLevel: number;
    /**
     * Determines the maximum zoom level we can zoom to.
     */
    maxZoomLevel: number;
    /**
     * Determines the minimum camera height in meter.
     */
    minCameraHeight: number;
    /**
     * Zoom level delta to apply when double clicking or double tapping. `0` disables the feature.
     */
    zoomLevelDeltaOnDoubleClick: number;
    /**
     * Double click uses the OS delay through the double click event. Tapping is implemented locally
     * here in `MapControls` with this duration setting the maximum delay to define a double tap.
     * The value is in seconds. `300ms` is picked as the default value as jQuery does.
     */
    doubleTapTime: number;
    /**
     * Three.js camera that this controller affects.
     */
    readonly camera: THREE.Camera;
    /**
     * Map's HTML DOM element.
     */
    readonly domElement: HTMLCanvasElement;
    private readonly m_currentViewDirection;
    private readonly m_lastMousePosition;
    private readonly m_initialMousePosition;
    private readonly m_mouseDelta;
    private m_needsRenderLastFrame;
    private m_panIsAnimated;
    private readonly m_panDistanceFrameDelta;
    private m_panAnimationTime;
    private m_panAnimationStartTime;
    private m_lastAveragedPanDistanceOrAngle;
    private m_currentInertialPanningSpeed;
    private readonly m_lastPanVector;
    private readonly m_rotateGlobeQuaternion;
    private readonly m_lastRotateGlobeAxis;
    private m_lastRotateGlobeAngle;
    private readonly m_lastRotateGlobeFromVector;
    private m_recentPanDistancesOrAngles;
    private m_currentPanDistanceOrAngleIndex;
    private m_zoomIsAnimated;
    private m_zoomDeltaRequested;
    private readonly m_zoomTargetNormalizedCoordinates;
    private m_zoomAnimationTime;
    private m_zoomAnimationStartTime;
    private m_startZoom;
    private m_targetedZoom?;
    private m_currentZoom?;
    private m_tiltIsAnimated;
    private m_tiltRequested?;
    private m_tiltAnimationTime;
    private m_tiltAnimationStartTime;
    private m_startTilt;
    private m_targetedTilt?;
    private m_currentTilt?;
    private m_tiltState?;
    private m_state;
    private readonly m_tmpVector2;
    private readonly m_tmpVector3;
    private m_tapStartTime;
    private m_lastSingleTapTime;
    private m_fingerMoved;
    private m_isDoubleTap;
    private m_resetNorthStartTime;
    private m_resetNorthIsAnimated;
    private m_resetNorthAnimationDuration;
    private m_currentAzimuth;
    private m_lastAzimuth;
    private m_startAzimuth;
    /**
     * Determines the maximum angle the camera can tilt to. It is defined in radians.
     */
    private m_maxTiltAngle;
    private m_cleanupMouseEventListeners?;
    private m_touchState;
    /**
     * Constructs a new `MapControls` object.
     *
     * @param mapView - [[MapView]] this controller modifies.
     * @param disposeWithMapView - If `true`, an event with MapView is registered to dispose of
     * `MapControls` if MapView itself is disposed.
     */
    constructor(mapView: MapView, disposeWithMapView?: boolean);
    /**
     * Destroy this `MapControls` instance.
     *
     * Unregisters all global event handlers used. This is method should be called when you stop
     * using `MapControls`.
     * @override
     */
    dispose: () => void;
    /**
     * Current viewing angles yaw/pitch/roll in degrees.
     */
    get attitude(): MapViewUtils.Attitude;
    /**
     * Reset the camera to looking north, in an orbiting movement around the target point instead
     * of changing the yaw (which would be the camera rotating on itself).
     */
    pointToNorth(): void;
    /**
     * Zooms and moves the map in such a way that the given target position remains at the same
     * position after the zoom.
     *
     * @param targetPositionOnScreenXinNDC - Target x position in NDC space.
     * @param targetPositionOnScreenYinNDC - Target y position in NDC space.
     */
    zoomOnTargetPosition(targetPositionOnScreenXinNDC: number, targetPositionOnScreenYinNDC: number, zoomLevel: number): void;
    /**
     * Zooms to the desired location by the provided value.
     *
     * @param zoomLevel - Zoom level.
     * @param screenTarget - Zoom target on screen.
     */
    setZoomLevel(zoomLevel: number, screenTarget?: {
        x: number;
        y: number;
    } | THREE.Vector2): void;
    /**
     * Toggles the camera tilt between 0 (looking down) and the value at `this.tiltAngle`.
     */
    toggleTilt(): void;
    /**
     * Set the camera height.
     */
    set cameraHeight(height: number);
    /**
     * Get the current camera height.
     */
    get cameraHeight(): number;
    /**
     * Set camera max tilt angle. The value is clamped between 0 and 89 degrees. In sphere
     * projection, at runtime, the value is also clamped so that the camera does not look above the
     * horizon.
     *
     * @param angle - Angle in degrees.
     */
    set maxTiltAngle(angle: number);
    /**
     * Get the camera max tilt angle in degrees.
     */
    get maxTiltAngle(): number;
    /**
     * Get the zoom level targeted by `MapControls`. Useful when inertia is on, to add incremented
     * values to the target instead of getting the random zoomLevel value during the interpolation.
     */
    get zoomLevelTargeted(): number;
    /**
     * Handy getter to know if the view is in the process of looking down or not.
     */
    get tiltState(): TiltState;
    private set currentZoom(value);
    private get currentZoom();
    private set currentTilt(value);
    private get currentTilt();
    private get targetedTilt();
    private assignZoomAfterTouchZoomRender;
    private stopExistingAnimations;
    private resetNorth;
    private stopResetNorth;
    private tilt;
    private stopTilt;
    private easeOutCubic;
    private handleZoom;
    private stopZoom;
    /**
     * Method to flip crêpes.
     */
    private handlePan;
    private stopPan;
    private bindInputEvents;
    private updateMapView;
    private mouseDoubleClick;
    private mouseDown;
    private mouseMove;
    private mouseUp;
    private mouseWheel;
    /**
     * Calculates the angle of the vector, which is formed by two touch points in world space
     * against the X axis in world space on the map. The resulting angle is in radians and between
     * `-PI` and `PI`.
     */
    private updateCurrentRotation;
    /**
     * Calculates the difference of the current distance of two touch points against their initial
     * distance in world space.
     */
    private calculatePinchDistanceInWorldSpace;
    private convertTouchPoint;
    private setTouchState;
    private updateTouches;
    private zoomOnDoubleClickOrTap;
    private touchStart;
    private touchMove;
    private touchEnd;
    private handleDoubleTap;
    private contextMenu;
    private getWorldPositionWithElevation;
    private panFromTo;
    /**
     * Acquire mouse or touch pointer position relative to canvas for `MouseEvent` or `Touch` event.
     *
     * Function takes into account canvas position in client space (including scrolling) as also
     * canvas scaling factor.
     *
     * @param event - The mouse event.
     * @returns [[THREE.Vector2]] containing _x_, _y_ mouse pointer position.
     */
    private getPointerPosition;
}
//# sourceMappingURL=MapControls.d.ts.map