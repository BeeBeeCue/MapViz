"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CameraKeyTrackAnimation = exports.ControlPoint = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_geoutils_1 = require("@here/harp-geoutils");
const harp_mapview_1 = require("@here/harp-mapview");
const harp_utils_1 = require("@here/harp-utils");
const THREE = require("three");
const logger = harp_utils_1.LoggerManager.instance.create("CameraKeyTrackAnimation");
const MIN_DISTANCE = 0;
/**
 * A ControlPoint used to defined the Track of the [[CameraKeyTrackAnimation]]
 * @beta
 */
class ControlPoint {
    constructor(options) {
        var _a, _b, _c, _d;
        /**
         * The time, when this ControlPoint should be reached in the animation flow, in seconds.
         */
        this.timestamp = 0;
        this.timestamp = options.timestamp;
        this.target = options.target
            ? harp_geoutils_1.GeoCoordinates.fromObject(options.target)
            : new harp_geoutils_1.GeoCoordinates(0, 0);
        this.tilt = (_a = options.tilt) !== null && _a !== void 0 ? _a : 0;
        this.heading = (_b = options.heading) !== null && _b !== void 0 ? _b : 0;
        this.distance = (_c = options.distance) !== null && _c !== void 0 ? _c : MIN_DISTANCE;
        this.name = (_d = options.name) !== null && _d !== void 0 ? _d : Date.now().toString();
    }
}
exports.ControlPoint = ControlPoint;
/**
 * The KeyFrameTracks from THREE.js used in this animation are directly bound to an
 * [[THREE.Object3D]] to manipulate its properties.
 * Therefore this Dummy object is used, the animation manipulates its properties, which then are
 * used to set the actual paramters of [[MapView]]
 */
class AnimationDummy extends THREE.Object3D {
    constructor(name) {
        super();
        this.distance = 0;
        this.name = name;
    }
}
/**
 * A [[CameraAnimation]] along of a set of [[ControlPoint]]s
 * @beta
 */
class CameraKeyTrackAnimation {
    constructor(m_mapView, m_options) {
        var _a, _b, _c, _d;
        this.m_mapView = m_mapView;
        this.m_options = m_options;
        this.m_dummy = new AnimationDummy("dummy");
        this.m_azimuthAxis = new THREE.Vector3(0, 0, 1);
        this.m_altitudeAxis = new THREE.Vector3(1, 0, 0);
        this.m_running = false;
        this.m_lastFrameTime = 0;
        const interpolation = this.m_options.interpolation !== undefined
            ? this.m_options.interpolation
            : THREE.InterpolateSmooth;
        this.m_options.loop = (_a = this.m_options.loop) !== null && _a !== void 0 ? _a : THREE.LoopOnce;
        this.m_options.repetitions = (_b = this.m_options.repetitions) !== null && _b !== void 0 ? _b : 1;
        this.m_options.rotateOnlyClockwise = (_c = this.m_options.rotateOnlyClockwise) !== null && _c !== void 0 ? _c : true;
        this.m_name = ((_d = this.m_options.name) !== null && _d !== void 0 ? _d : "CameraKeyTrackAnimation") + Date.now();
        const timestamps = this.m_options.controlPoints.map(point => {
            return point.timestamp;
        });
        const posValues = [];
        const rotValues = [];
        this.m_options.controlPoints.map(point => {
            const worldPos = this.m_mapView.projection.projectPoint(point.target);
            posValues.push(worldPos.x);
            posValues.push(worldPos.y);
            posValues.push(worldPos.z);
            const rot = new THREE.Quaternion();
            rot.setFromAxisAngle(this.m_azimuthAxis, THREE.MathUtils.degToRad(point.heading));
            rot.multiply(new THREE.Quaternion().setFromAxisAngle(this.m_altitudeAxis, THREE.MathUtils.degToRad(point.tilt)));
            rotValues.push(rot.x);
            rotValues.push(rot.y);
            rotValues.push(rot.z);
            rotValues.push(rot.w);
        });
        const lookAtTrack = new THREE.VectorKeyframeTrack(".position", timestamps, posValues, interpolation);
        const rotationTrack = new THREE.QuaternionKeyframeTrack(".quaternion", timestamps, rotValues, interpolation);
        const distanceTrack = new THREE.NumberKeyframeTrack(".distance", timestamps, this.m_options.controlPoints.map(point => {
            return point.distance;
        }), interpolation);
        this.m_animationClip = new THREE.AnimationClip("cameraflyoveranimation", -1, [
            lookAtTrack,
            rotationTrack,
            distanceTrack
        ]);
        if (!this.m_animationClip.validate()) {
            logger.error("Review the entered controlpoints for: ", this.m_name, ", The Animation was provided with invalid track data");
        }
        this.m_animationClip.resetDuration();
        this.m_animationClip.trim();
        this.m_animationMixer = new THREE.AnimationMixer(this.m_dummy);
        this.m_animationAction = this.m_animationMixer.clipAction(this.m_animationClip);
        this.m_animationAction.setLoop(this.m_options.loop, this.m_options.repetitions);
        this.m_animationAction.clampWhenFinished = true;
        this.m_animateCb = this.animate.bind(this);
        this.m_animationMixer.addEventListener("finished", this.stop.bind(this));
    }
    set loop(value) {
        this.m_options.loop = value;
        this.m_animationAction.setLoop(this.m_options.loop, this.m_options.repetitions);
    }
    set repetitions(value) {
        this.m_options.repetitions = value;
        this.m_animationAction.setLoop(this.m_options.loop, this.m_options.repetitions);
    }
    set rotateOnlyClockwise(value) {
        this.m_options.rotateOnlyClockwise = value;
    }
    /**
     * Start the Animation
     */
    start(time, onFinished) {
        if (this.m_running) {
            this.stop();
        }
        this.m_onFinished = onFinished;
        this.m_animationAction.reset().play();
        this.m_lastFrameTime = Date.now();
        this.m_mapView.addEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_animateCb);
        this.m_mapView.beginAnimation();
        this.m_running = true;
    }
    /**
     * Stop the Animation
     */
    stop() {
        this.m_mapView.removeEventListener(harp_mapview_1.MapViewEventNames.Render, this.m_animateCb);
        this.m_mapView.endAnimation();
        if (this.m_onFinished !== undefined) {
            // called asynchronously, as the last animate event still will get dispatched
            // and should run before the onFinished callback
            window.setTimeout(this.m_onFinished, 0);
        }
        this.m_running = false;
    }
    isRunning() {
        return this.m_running;
    }
    updateCameraFromDummy() {
        let tilt = THREE.MathUtils.radToDeg(this.m_azimuthAxis
            .clone()
            .applyQuaternion(this.m_dummy.quaternion)
            .angleTo(this.m_azimuthAxis));
        tilt = THREE.MathUtils.clamp(tilt, 0, harp_mapview_1.MapViewUtils.MAX_TILT_DEG);
        const vec0 = this.m_altitudeAxis.clone().applyQuaternion(this.m_dummy.quaternion);
        let angle = vec0.angleTo(this.m_altitudeAxis);
        if (this.m_options.rotateOnlyClockwise) {
            const direction = this.m_azimuthAxis.dot(vec0.normalize().cross(this.m_altitudeAxis));
            if (direction >= 0) {
                angle = 2 * Math.PI - angle;
            }
        }
        const heading = THREE.MathUtils.radToDeg(angle);
        const target = this.m_mapView.projection.unprojectPoint(this.m_dummy.position);
        const distance = Math.max(MIN_DISTANCE, this.m_dummy.distance);
        if (isNaN(tilt) || isNaN(heading) || isNaN(distance) || !target.isValid()) {
            logger.error("Cannot update due to invalid data", tilt, heading, distance, target);
        }
        this.m_mapView.lookAt({ target, distance, tilt, heading });
    }
    animate(event) {
        const deltaTime = (Date.now() - this.m_lastFrameTime) / 1000;
        this.m_animationMixer.update(deltaTime);
        this.m_lastFrameTime = Date.now();
        this.updateCameraFromDummy();
    }
}
exports.CameraKeyTrackAnimation = CameraKeyTrackAnimation;
//# sourceMappingURL=CameraKeyTrackAnimation.js.map