"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VectorTileDecoderService = exports.VectorTileDecoder = exports.VectorTileDataProcessor = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = require("@here/harp-datasource-protocol");
const index_worker_1 = require("@here/harp-mapview-decoder/index-worker");
const harp_utils_1 = require("@here/harp-utils");
const GeoJsonVtDataAdapter_1 = require("./adapters/geojson-vt/GeoJsonVtDataAdapter");
const GeoJsonDataAdapter_1 = require("./adapters/geojson/GeoJsonDataAdapter");
const OmvDataAdapter_1 = require("./adapters/omv/OmvDataAdapter");
const DecodeInfo_1 = require("./DecodeInfo");
const OmvDataFilter_1 = require("./OmvDataFilter");
const OmvDecoderDefs_1 = require("./OmvDecoderDefs");
const OmvPoliticalViewFeatureModifier_1 = require("./OmvPoliticalViewFeatureModifier");
const StyleSetDataFilter_1 = require("./StyleSetDataFilter");
const VectorTileDataEmitter_1 = require("./VectorTileDataEmitter");
const logger = harp_utils_1.LoggerManager.instance.create("VectorTileDecoder", { enabled: false });
class VectorTileDataProcessor {
    constructor(m_projection, m_styleSetEvaluator, m_showMissingTechniques, m_dataFilter, m_featureModifiers, m_gatherFeatureAttributes = false, m_skipShortLabels = true, m_storageLevelOffset = 0, m_enableElevationOverlay = false, m_roundUpCoordinatesIfNeeded = false, m_languages) {
        this.m_projection = m_projection;
        this.m_styleSetEvaluator = m_styleSetEvaluator;
        this.m_showMissingTechniques = m_showMissingTechniques;
        this.m_dataFilter = m_dataFilter;
        this.m_featureModifiers = m_featureModifiers;
        this.m_gatherFeatureAttributes = m_gatherFeatureAttributes;
        this.m_skipShortLabels = m_skipShortLabels;
        this.m_storageLevelOffset = m_storageLevelOffset;
        this.m_enableElevationOverlay = m_enableElevationOverlay;
        this.m_roundUpCoordinatesIfNeeded = m_roundUpCoordinatesIfNeeded;
        this.m_languages = m_languages;
        this.m_dataAdapters = [];
        const styleSetDataFilter = new StyleSetDataFilter_1.StyleSetDataFilter(m_styleSetEvaluator);
        const dataPreFilter = m_dataFilter
            ? new OmvDataFilter_1.ComposedDataFilter([styleSetDataFilter, m_dataFilter])
            : styleSetDataFilter;
        // Register the default adapters.
        const omvDataAdapter = new OmvDataAdapter_1.OmvDataAdapter(this, dataPreFilter, logger);
        omvDataAdapter.roundUpCoordinatesIfNeeded = m_roundUpCoordinatesIfNeeded;
        this.m_dataAdapters.push(omvDataAdapter);
        this.m_dataAdapters.push(new GeoJsonVtDataAdapter_1.GeoJsonVtDataAdapter(this, dataPreFilter, logger));
        this.m_dataAdapters.push(new GeoJsonDataAdapter_1.GeoJsonDataAdapter(this, dataPreFilter, logger));
    }
    get storageLevelOffset() {
        return this.m_storageLevelOffset;
    }
    /**
     * Given a tile and a protobuffer, it returns a decoded tile and it creates the geometries that
     * belong to it.
     *
     * @param tileKey - The tile to be decoded.
     * @param data - The protobuffer to decode from.
     * @returns A [[DecodedTile]]
     */
    getDecodedTile(tileKey, data) {
        let dataAdapter;
        for (const adapter of this.m_dataAdapters.values()) {
            if (adapter.canProcess(data)) {
                dataAdapter = adapter;
                break;
            }
        }
        if (dataAdapter === undefined) {
            return {
                techniques: [],
                geometries: []
            };
        }
        this.m_styleSetEvaluator.resetTechniques();
        const decodeInfo = new DecodeInfo_1.DecodeInfo(dataAdapter.id, this.m_projection, tileKey, this.m_storageLevelOffset);
        this.m_decodedTileEmitter = new VectorTileDataEmitter_1.VectorTileDataEmitter(decodeInfo, this.m_styleSetEvaluator, this.m_gatherFeatureAttributes, this.m_skipShortLabels, this.m_enableElevationOverlay, this.m_languages);
        dataAdapter.process(data, decodeInfo);
        return this.m_decodedTileEmitter.getDecodedTile();
    }
    processPointFeature(layer, extents, geometry, env, storageLevel) {
        if (this.m_featureModifiers !== undefined) {
            if (this.m_featureModifiers.find(fm => {
                // TODO: The logic of feature ignore should be actually in the feature filtering
                // mechanism - see OmvFeatureFilter.
                return !fm.doProcessPointFeature(layer, env, storageLevel);
            }) !== undefined) {
                return;
            }
        }
        const techniques = this.applyKindFilter(this.m_styleSetEvaluator.getMatchingTechniques(env, layer, "point"), harp_datasource_protocol_1.GeometryKind.Label);
        if (techniques.length === 0) {
            if (this.m_showMissingTechniques) {
                logger.log("OmvDecoder#processPointFeature: no techniques for object:", JSON.stringify(env.unmap()));
            }
            return;
        }
        const context = {
            env,
            cachedExprResults: new Map()
        };
        if (this.m_decodedTileEmitter) {
            this.m_decodedTileEmitter.processPointFeature(layer, extents, geometry, context, techniques);
        }
    }
    processLineFeature(layer, extents, geometry, env, storageLevel) {
        if (this.m_featureModifiers !== undefined) {
            if (this.m_featureModifiers.find(fm => {
                return !fm.doProcessLineFeature(layer, env, storageLevel);
            }) !== undefined) {
                return;
            }
        }
        const techniques = this.applyKindFilter(this.m_styleSetEvaluator.getMatchingTechniques(env, layer, "line"), harp_datasource_protocol_1.GeometryKind.Line);
        if (techniques.length === 0) {
            if (this.m_showMissingTechniques) {
                logger.log("OmvDecoder#processLineFeature: no techniques for object:", JSON.stringify(env.unmap()));
            }
            return;
        }
        const context = {
            env,
            cachedExprResults: new Map()
        };
        const featureId = env.lookup("$id");
        if (this.m_decodedTileEmitter) {
            this.m_decodedTileEmitter.processLineFeature(layer, extents, geometry, context, techniques, featureId);
        }
    }
    processPolygonFeature(layer, extents, geometry, env, storageLevel) {
        if (this.m_featureModifiers !== undefined) {
            if (this.m_featureModifiers.find(fm => {
                return !fm.doProcessPolygonFeature(layer, env, storageLevel);
            }) !== undefined) {
                return;
            }
        }
        const techniques = this.applyKindFilter(this.m_styleSetEvaluator.getMatchingTechniques(env, layer, "polygon"), harp_datasource_protocol_1.GeometryKind.Area);
        if (techniques.length === 0) {
            if (this.m_showMissingTechniques) {
                logger.log("OmvDecoder#processPolygonFeature: no techniques for object:", JSON.stringify(env.unmap()));
            }
            return;
        }
        const context = {
            env,
            cachedExprResults: new Map()
        };
        const featureId = env.lookup("$id");
        if (this.m_decodedTileEmitter) {
            this.m_decodedTileEmitter.processPolygonFeature(layer, extents, geometry, context, techniques, featureId);
        }
    }
    applyKindFilter(techniques, defaultKind) {
        if (this.m_dataFilter !== undefined && this.m_dataFilter.hasKindFilter) {
            techniques = techniques.filter(technique => {
                const kind = technique.kind === undefined ? defaultKind : technique.kind;
                return this.m_dataFilter.wantsKind(kind);
            });
        }
        return techniques;
    }
}
exports.VectorTileDataProcessor = VectorTileDataProcessor;
/**
 * The vector tile decoder.
 */
class VectorTileDecoder extends index_worker_1.ThemedTileDecoder {
    constructor() {
        super(...arguments);
        this.m_showMissingTechniques = false;
        this.m_gatherFeatureAttributes = false;
        this.m_skipShortLabels = true;
        this.m_enableElevationOverlay = false;
        this.m_roundUpCoordinatesIfNeeded = false;
    }
    /** @override */
    connect() {
        return Promise.resolve();
    }
    /** @override */
    decodeThemedTile(data, tileKey, styleSetEvaluator, projection) {
        const startTime = harp_utils_1.PerformanceTimer.now();
        const decoder = new VectorTileDataProcessor(projection, styleSetEvaluator, this.m_showMissingTechniques, this.m_featureFilter, this.m_featureModifiers, this.m_gatherFeatureAttributes, this.m_skipShortLabels, this.m_storageLevelOffset, this.m_enableElevationOverlay, this.m_roundUpCoordinatesIfNeeded, this.languages);
        const decodedTile = decoder.getDecodedTile(tileKey, data);
        decodedTile.decodeTime = harp_utils_1.PerformanceTimer.now() - startTime;
        return Promise.resolve(decodedTile);
    }
    /** @override */
    configure(options, customOptions) {
        super.configure(options, customOptions);
        if (customOptions) {
            const omvOptions = customOptions;
            if (omvOptions.showMissingTechniques !== undefined) {
                this.m_showMissingTechniques = omvOptions.showMissingTechniques === true;
            }
            if (omvOptions.filterDescription !== undefined) {
                if (omvOptions.filterDescription !== null) {
                    // TODO: Feature modifier is always used only with feature filter.
                    // At best the filtering feature should be excluded from other feature
                    // modifiers and be performed solely via OmvGenericFeature modifier or filter.
                    const filterDescription = omvOptions.filterDescription;
                    const featureModifiersIds = omvOptions.featureModifiers;
                    // Create new filter from description.
                    this.m_featureFilter = new OmvDataFilter_1.OmvGenericFeatureFilter(filterDescription);
                    // Create feature modifiers.
                    const featureModifiers = [];
                    if (featureModifiersIds !== undefined) {
                        featureModifiersIds.forEach(fmId => {
                            featureModifiers.push(this.createFeatureModifier(filterDescription, fmId));
                        });
                    }
                    else {
                        featureModifiers.push(this.createFeatureModifier(filterDescription, OmvDecoderDefs_1.FeatureModifierId.default));
                    }
                    this.m_featureModifiers = featureModifiers;
                }
                else {
                    // null is the signal to clear the filter/modifier
                    this.m_featureFilter = undefined;
                    this.m_featureModifiers = undefined;
                }
            }
            if (omvOptions.politicalView !== undefined) {
                const politicalView = omvOptions.politicalView;
                let featureModifiers = this.m_featureModifiers;
                // Remove existing political view modifiers, this actually setups default,
                // commonly accepted point of view - without feature modifier.
                if (featureModifiers) {
                    featureModifiers = featureModifiers.filter(fm => !(fm instanceof OmvPoliticalViewFeatureModifier_1.OmvPoliticalViewFeatureModifier));
                }
                // If political view is indeed requested append feature modifier at the end of list.
                if (politicalView.length !== 0) {
                    harp_utils_1.assert(politicalView.length === 2, "The political view must be specified as two letters ISO 3166-1 standard!");
                    const povFeatureModifier = new OmvPoliticalViewFeatureModifier_1.OmvPoliticalViewFeatureModifier(politicalView);
                    if (featureModifiers) {
                        featureModifiers.push(povFeatureModifier);
                    }
                    else {
                        featureModifiers = [povFeatureModifier];
                    }
                }
                // Reset modifiers if nothing was added.
                this.m_featureModifiers =
                    featureModifiers && featureModifiers.length > 0 ? featureModifiers : undefined;
            }
            if (omvOptions.gatherFeatureAttributes !== undefined) {
                this.m_gatherFeatureAttributes = omvOptions.gatherFeatureAttributes === true;
            }
            if (omvOptions.skipShortLabels !== undefined) {
                this.m_skipShortLabels = omvOptions.skipShortLabels;
            }
            if (omvOptions.enableElevationOverlay !== undefined) {
                this.m_enableElevationOverlay = omvOptions.enableElevationOverlay;
            }
            if (omvOptions.roundUpCoordinatesIfNeeded !== undefined) {
                this.m_roundUpCoordinatesIfNeeded = omvOptions.roundUpCoordinatesIfNeeded;
            }
        }
        if ((options === null || options === void 0 ? void 0 : options.languages) !== undefined) {
            this.languages = options.languages;
        }
    }
    createFeatureModifier(filterDescription, featureModifierId) {
        switch (featureModifierId) {
            case OmvDecoderDefs_1.FeatureModifierId.default:
                return new OmvDataFilter_1.OmvGenericFeatureModifier(filterDescription);
            default:
                harp_utils_1.assert(!"Unrecognized feature modifier id, using default!");
                return new OmvDataFilter_1.OmvGenericFeatureModifier(filterDescription);
        }
    }
}
exports.VectorTileDecoder = VectorTileDecoder;
/**
 * Vector Tile Decoder Service.
 */
class VectorTileDecoderService {
    /**
     * Register a vector tile decoder service.
     *
     * @remarks
     * Has to be called during initialization of decoder bundle.
     */
    static start() {
        index_worker_1.WorkerServiceManager.getInstance().register({
            serviceType: OmvDecoderDefs_1.VECTOR_TILE_DECODER_SERVICE_TYPE,
            factory: (serviceId) => index_worker_1.TileDecoderService.start(serviceId, new VectorTileDecoder())
        });
    }
}
exports.VectorTileDecoderService = VectorTileDecoderService;
//# sourceMappingURL=VectorTileDecoder.js.map