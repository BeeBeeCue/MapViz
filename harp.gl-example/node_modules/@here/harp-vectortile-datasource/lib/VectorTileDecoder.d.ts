import { DecodedTile, DecoderOptions, OptionsMap } from "@here/harp-datasource-protocol";
import { MapEnv, StyleSetEvaluator } from "@here/harp-datasource-protocol/index-decoder";
import { Projection, TileKey } from "@here/harp-geoutils";
import { ThemedTileDecoder } from "@here/harp-mapview-decoder/index-worker";
import * as THREE from "three";
import { IGeometryProcessor, ILineGeometry, IPolygonGeometry } from "./IGeometryProcessor";
import { OmvFeatureFilter, OmvFeatureModifier } from "./OmvDataFilter";
export declare class VectorTileDataProcessor implements IGeometryProcessor {
    private readonly m_projection;
    private readonly m_styleSetEvaluator;
    private readonly m_showMissingTechniques;
    private readonly m_dataFilter?;
    private readonly m_featureModifiers?;
    private readonly m_gatherFeatureAttributes;
    private readonly m_skipShortLabels;
    private readonly m_storageLevelOffset;
    private readonly m_enableElevationOverlay;
    private readonly m_roundUpCoordinatesIfNeeded;
    private readonly m_languages?;
    private m_decodedTileEmitter;
    private readonly m_dataAdapters;
    constructor(m_projection: Projection, m_styleSetEvaluator: StyleSetEvaluator, m_showMissingTechniques: boolean, m_dataFilter?: OmvFeatureFilter | undefined, m_featureModifiers?: OmvFeatureModifier[] | undefined, m_gatherFeatureAttributes?: boolean, m_skipShortLabels?: boolean, m_storageLevelOffset?: number, m_enableElevationOverlay?: boolean, m_roundUpCoordinatesIfNeeded?: boolean, m_languages?: string[] | undefined);
    get storageLevelOffset(): number;
    /**
     * Given a tile and a protobuffer, it returns a decoded tile and it creates the geometries that
     * belong to it.
     *
     * @param tileKey - The tile to be decoded.
     * @param data - The protobuffer to decode from.
     * @returns A [[DecodedTile]]
     */
    getDecodedTile(tileKey: TileKey, data: ArrayBufferLike | {}): DecodedTile;
    processPointFeature(layer: string, extents: number, geometry: THREE.Vector2[], env: MapEnv, storageLevel: number): void;
    processLineFeature(layer: string, extents: number, geometry: ILineGeometry[], env: MapEnv, storageLevel: number): void;
    processPolygonFeature(layer: string, extents: number, geometry: IPolygonGeometry[], env: MapEnv, storageLevel: number): void;
    private applyKindFilter;
}
/**
 * The vector tile decoder.
 */
export declare class VectorTileDecoder extends ThemedTileDecoder {
    private m_showMissingTechniques;
    private m_featureFilter?;
    private m_featureModifiers?;
    private m_gatherFeatureAttributes;
    private m_skipShortLabels;
    private m_enableElevationOverlay;
    private m_roundUpCoordinatesIfNeeded;
    /** @override */
    connect(): Promise<void>;
    /** @override */
    decodeThemedTile(data: ArrayBufferLike, tileKey: TileKey, styleSetEvaluator: StyleSetEvaluator, projection: Projection): Promise<DecodedTile>;
    /** @override */
    configure(options?: DecoderOptions, customOptions?: OptionsMap): void;
    private createFeatureModifier;
}
/**
 * Vector Tile Decoder Service.
 */
export declare class VectorTileDecoderService {
    /**
     * Register a vector tile decoder service.
     *
     * @remarks
     * Has to be called during initialization of decoder bundle.
     */
    static start(): void;
}
//# sourceMappingURL=VectorTileDecoder.d.ts.map