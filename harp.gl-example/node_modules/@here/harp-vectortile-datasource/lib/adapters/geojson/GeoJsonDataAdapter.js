"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeoJsonDataAdapter = void 0;
const Env_1 = require("@here/harp-datasource-protocol/lib/Env");
const harp_geoutils_1 = require("@here/harp-geoutils");
const three_1 = require("three");
const OmvUtils_1 = require("../../OmvUtils");
const DEFAULT_EXTENTS = 4 * 1024;
function convertGeometryType(type) {
    switch (type) {
        case "LineString":
            return "line";
        case "MultiLineString":
            return "line";
        case "Polygon":
            return "polygon";
        case "MultiPolygon":
            return "polygon";
        case "Point":
            return "point";
        case "MultiPoint":
            return "point";
        default:
            return "unknown";
    } // switch
}
const worldP = new three_1.Vector3();
const localP = new three_1.Vector2();
/**
 * Converts a `geoPoint` to local tile space.
 *
 * @param geoPoint - The input [[GeoPointLike]].
 * @param decodeInfo - The [[DecodeInfo]].
 * @hidden
 */
function convertPoint(geoPoint, decodeInfo) {
    harp_geoutils_1.webMercatorProjection.projectPoint(harp_geoutils_1.GeoCoordinates.fromGeoPoint(geoPoint), worldP);
    localP.set(worldP.x, worldP.y);
    return OmvUtils_1.world2tile(DEFAULT_EXTENTS, decodeInfo, localP, false, new three_1.Vector2());
}
function convertLineStringGeometry(coordinates, decodeInfo) {
    const untiledPositions = coordinates.map(geoPoint => {
        return harp_geoutils_1.GeoCoordinates.fromGeoPoint(geoPoint);
    });
    const positions = coordinates.map(geoPoint => convertPoint(geoPoint, decodeInfo));
    return { untiledPositions, positions };
}
function convertLineGeometry(geometry, decodeInfo) {
    if (geometry.type === "LineString") {
        return [convertLineStringGeometry(geometry.coordinates, decodeInfo)];
    }
    return geometry.coordinates.map(lineString => convertLineStringGeometry(lineString, decodeInfo));
}
function convertRings(coordinates, decodeInfo) {
    const rings = coordinates.map(ring => {
        const { positions } = convertLineStringGeometry(ring, decodeInfo);
        return positions;
    });
    return { rings };
}
function convertPolygonGeometry(geometry, decodeInfo) {
    if (geometry.type === "Polygon") {
        return [convertRings(geometry.coordinates, decodeInfo)];
    }
    return geometry.coordinates.map(polygon => convertRings(polygon, decodeInfo));
}
function convertPointGeometry(geometry, decodeInfo) {
    if (geometry.type === "Point") {
        return [convertPoint(geometry.coordinates, decodeInfo)];
    }
    return geometry.coordinates.map(geoPoint => convertPoint(geoPoint, decodeInfo));
}
class GeoJsonDataAdapter {
    constructor(m_processor, dataFilter, m_logger) {
        this.m_processor = m_processor;
        this.dataFilter = dataFilter;
        this.m_logger = m_logger;
        this.id = "GeoJsonDataAdapter";
    }
    canProcess(featureCollection) {
        return (featureCollection &&
            featureCollection.type === "FeatureCollection" &&
            Array.isArray(featureCollection.features));
    }
    process(featureCollection, decodeInfo) {
        var _a;
        if (!Array.isArray(featureCollection.features) || featureCollection.features.length === 0) {
            return;
        }
        const { tileKey } = decodeInfo;
        const $level = tileKey.level;
        const $zoom = Math.max(0, tileKey.level - ((_a = this.m_processor.storageLevelOffset) !== null && _a !== void 0 ? _a : 0));
        const $layer = "geojson";
        for (const feature of featureCollection.features) {
            const $geometryType = convertGeometryType(feature.geometry.type);
            const env = new Env_1.MapEnv(Object.assign(Object.assign({}, feature.properties), { $layer,
                $level,
                $zoom,
                $geometryType }));
            switch (feature.geometry.type) {
                case "LineString":
                case "MultiLineString": {
                    const geometry = convertLineGeometry(feature.geometry, decodeInfo);
                    this.m_processor.processLineFeature($layer, DEFAULT_EXTENTS, geometry, env, $level);
                    break;
                }
                case "Polygon":
                case "MultiPolygon": {
                    const geometry = convertPolygonGeometry(feature.geometry, decodeInfo);
                    this.m_processor.processPolygonFeature($layer, DEFAULT_EXTENTS, geometry, env, $level);
                    break;
                }
                case "Point":
                case "MultiPoint": {
                    const geometry = convertPointGeometry(feature.geometry, decodeInfo);
                    this.m_processor.processPointFeature($layer, DEFAULT_EXTENTS, geometry, env, $level);
                    break;
                }
            }
        }
    }
}
exports.GeoJsonDataAdapter = GeoJsonDataAdapter;
//# sourceMappingURL=GeoJsonDataAdapter.js.map