"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeoJsonVtDataAdapter = exports.VTJsonDataAdapterId = void 0;
const index_decoder_1 = require("@here/harp-datasource-protocol/index-decoder");
const harp_geoutils_1 = require("@here/harp-geoutils");
const three_1 = require("three");
const OmvUtils_1 = require("../../OmvUtils");
const VT_JSON_EXTENTS = 4096;
var VTJsonGeometryType;
(function (VTJsonGeometryType) {
    VTJsonGeometryType[VTJsonGeometryType["Unknown"] = 0] = "Unknown";
    VTJsonGeometryType[VTJsonGeometryType["Point"] = 1] = "Point";
    VTJsonGeometryType[VTJsonGeometryType["LineString"] = 2] = "LineString";
    VTJsonGeometryType[VTJsonGeometryType["Polygon"] = 3] = "Polygon";
})(VTJsonGeometryType || (VTJsonGeometryType = {}));
const tmpPos = new three_1.Vector2();
const worldPos = new three_1.Vector3();
/**
 * Unique ID of {@link VTJsonDataAdapter}.
 */
exports.VTJsonDataAdapterId = "vt-json";
/**
 * The class `GeoJsonVtDataAdapter` converts VT-json data to geometries for the given
 * {@link IGeometryProcessor}.
 */
class GeoJsonVtDataAdapter {
    constructor(m_processor, m_dataFilter, m_logger) {
        this.m_processor = m_processor;
        this.m_dataFilter = m_dataFilter;
        this.m_logger = m_logger;
        this.id = exports.VTJsonDataAdapterId;
    }
    get dataFilter() {
        return this.m_dataFilter;
    }
    set dataFilter(dataFilter) {
        this.m_dataFilter = dataFilter;
    }
    canProcess(data) {
        if (OmvUtils_1.isArrayBufferLike(data)) {
            return false;
        }
        const tile = data;
        if (tile.features === undefined ||
            tile.source === undefined ||
            tile.x === undefined ||
            tile.y === undefined ||
            tile.z === undefined) {
            return false;
        }
        return true;
    }
    process(tile, decodeInfo) {
        var _a;
        const { tileKey } = decodeInfo;
        for (const feature of tile.features) {
            const env = new index_decoder_1.MapEnv(Object.assign({ $layer: tile.layer, $geometryType: this.convertGeometryType(feature.type), $level: tileKey.level, $zoom: Math.max(0, tileKey.level - ((_a = this.m_processor.storageLevelOffset) !== null && _a !== void 0 ? _a : 0)), $id: feature.id }, feature.tags));
            switch (feature.type) {
                case VTJsonGeometryType.Point: {
                    for (const pointGeometry of feature.geometry) {
                        const x = pointGeometry[0];
                        const y = pointGeometry[1];
                        const position = new three_1.Vector2(x, y);
                        this.m_processor.processPointFeature(tile.layer, VT_JSON_EXTENTS, [position], env, tileKey.level);
                    }
                    break;
                }
                case VTJsonGeometryType.LineString: {
                    const lineGeometries = feature.geometry;
                    let lastLine;
                    const lines = [];
                    lineGeometries.forEach(lineGeometry => {
                        const lastPos = lastLine === null || lastLine === void 0 ? void 0 : lastLine.positions[lastLine.positions.length - 1];
                        const [startx, starty] = lineGeometry[0];
                        if ((lastPos === null || lastPos === void 0 ? void 0 : lastPos.x) === startx && (lastPos === null || lastPos === void 0 ? void 0 : lastPos.y) === starty) {
                            // continue the last line
                            for (let i = 1; i < lineGeometry.length; ++i) {
                                const [x, y] = lineGeometry[i];
                                lastLine === null || lastLine === void 0 ? void 0 : lastLine.positions.push(new three_1.Vector2(x, y));
                            }
                        }
                        else {
                            // start a new line
                            const positions = lineGeometry.map(([x, y]) => new three_1.Vector2(x, y));
                            lines.push({ positions });
                            lastLine = lines[lines.length - 1];
                        }
                    });
                    lines.forEach(line => {
                        line.untiledPositions = line.positions.map(tilePos => {
                            OmvUtils_1.tile2world(VT_JSON_EXTENTS, decodeInfo, tilePos, false, tmpPos);
                            worldPos.set(tmpPos.x, tmpPos.y, 0);
                            return harp_geoutils_1.webMercatorProjection.unprojectPoint(worldPos);
                        });
                    });
                    this.m_processor.processLineFeature(tile.layer, VT_JSON_EXTENTS, lines, env, tileKey.level);
                    break;
                }
                case VTJsonGeometryType.Polygon: {
                    const polygon = { rings: [] };
                    for (const outline of feature.geometry) {
                        const ring = [];
                        for (const [currX, currY] of outline) {
                            const position = new three_1.Vector2(currX, currY);
                            ring.push(position);
                        }
                        polygon.rings.push(ring);
                    }
                    this.m_processor.processPolygonFeature(tile.layer, VT_JSON_EXTENTS, [polygon], env, tileKey.level);
                    break;
                }
                case VTJsonGeometryType.Unknown: {
                    break;
                }
            }
        }
    }
    convertGeometryType(type) {
        switch (type) {
            case VTJsonGeometryType.Point:
                return "point";
            case VTJsonGeometryType.LineString:
                return "line";
            case VTJsonGeometryType.Polygon:
                return "polygon";
            default:
                return "unknown";
        }
    }
}
exports.GeoJsonVtDataAdapter = GeoJsonVtDataAdapter;
//# sourceMappingURL=GeoJsonVtDataAdapter.js.map