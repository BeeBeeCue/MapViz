import { GeoBox, GeoCoordinates, GeoCoordinatesLike, Projection, TileKey, Vector3Like } from "@here/harp-geoutils";
import { GeoCoordLike } from "@here/harp-geoutils/lib/coordinates/GeoCoordLike";
import * as THREE from "three";
import { ElevationProvider } from "./ElevationProvider";
import { MapView } from "./MapView";
export declare namespace MapViewUtils {
    const MAX_TILT_DEG = 89;
    const MAX_TILT_RAD: number;
    /**
     * The anti clockwise rotation of an object along the axes of its tangent space, with itself
     * as origin.
     */
    interface Attitude {
        /**
         * Rotation of the object along its vertical axis.
         */
        yaw: number;
        /**
         * Rotation of the object along its horizontal axis.
         */
        pitch: number;
        /**
         * Rotation of the object along its forward axis.
         */
        roll: number;
    }
    /**
     * Describes estimated usage of memory on heap and GPU.
     */
    interface MemoryUsage {
        heapSize: number;
        gpuSize: number;
    }
    /**
     * Zooms and moves the map in such a way that the given target position remains at the same
     * position after the zoom.
     *
     * @param mapView - Instance of MapView.
     * @param targetNDCx - Target x position in NDC space.
     * @param targetNDCy - Target y position in NDC space.
     * @param zoomLevel - The desired zoom level.
     * @param maxTiltAngle - The maximum tilt angle to comply by, in globe projection, in radian.
     * @returns `false` if requested zoom cannot be achieved due to the map view's maximum bounds
     * {@link MapView.geoMaxBounds},`true` otherwise.
     */
    function zoomOnTargetPosition(mapView: MapView, targetNDCx: number, targetNDCy: number, zoomLevel: number, maxTiltAngle?: number): boolean;
    /**
     * Orbits the camera around a given point on the screen.
     *
     * @param mapView - The {@link MapView} instance to manipulate.
     * @param offsetX - Orbit point in NDC space.
     * @param offsetY - Orbit point in NDC space.
     * @param deltaAzimuth - Delta azimuth in radians.
     * @param deltaTil - Delta tilt in radians.
     * @param maxTiltAngle - The maximum tilt between the camera and its target in radian.
     */
    function orbitAroundScreenPoint(mapView: MapView, offsetX: number, offsetY: number, deltaAzimuth: number, deltaTilt: number, maxTiltAngle: number): void;
    /**
     * Calculate target (focus) point geo-coordinates for given camera.
     * @see getTargetPositionFromCamera
     *
     * @param camera - The camera looking on target point.
     * @param projection - The geo-projection used.
     * @param elevation - Optional elevation above (or below) sea level measured in world units.
     *
     * @deprecated This function is for internal use only and will be removed in the future. Use
     * MapView.worldTarget instead.
     */
    function getGeoTargetFromCamera(camera: THREE.Camera, projection: Projection, elevation?: number): GeoCoordinates | null;
    /**
     * Calculate target (focus) point world coordinates for given camera position and orientation.
     * @param camera - The camera looking on target point.
     * @param projection - The geo-projection used.
     * @param elevation - Optional elevation above (or below) sea level in world units.
     *
     * @deprecated This function is for internal use only and will be removed in the future.
     */
    function getWorldTargetFromCamera(camera: THREE.Camera, projection: Projection, elevation?: number): THREE.Vector3 | null;
    /**
     * Constrains given camera target and distance to {@link MapView.maxBounds}.
     *
     * @remarks
     * The resulting
     * target and distance will keep the view within the maximum bounds for a camera with tilt and
     * yaw set to 0.
     * @param target - The camera target.
     * @param distance - The camera distance.
     * @param mapView - The map view whose maximum bounds will be used as constraints.
     * @returns constrained target and distance, or the unchanged input arguments if the view
     * does not have maximum bounds set.
     */
    function constrainTargetAndDistanceToViewBounds(target: THREE.Vector3, distance: number, mapView: MapView): {
        target: THREE.Vector3;
        distance: number;
    };
    /**
     * @internal
     * Computes the target for a given camera and the distance between them.
     * @param projection - The world space projection.
     * @param camera - The camera whose target will be computed.
     * @param elevationProvider - If provided, elevation at the camera position will be used.
     * @returns The target, the distance to it and a boolean flag set to false in case an elevation
     * provider was passed but the elevation was not available yet.
     */
    function getTargetAndDistance(projection: Projection, camera: THREE.Camera, elevationProvider?: ElevationProvider): {
        target: THREE.Vector3;
        distance: number;
        final: boolean;
    };
    /**
     * Returns the {@link @here/harp-geoutils#GeoCoordinates} of the camera,
     * given its target coordinates on the map and its
     * zoom, yaw and pitch.
     *
     * @param targetCoordinates - Coordinates of the center of the view.
     * @param distance - Distance to the target in meters.
     * @param yawDeg - Camera yaw in degrees.
     * @param pitchDeg - Camera pitch in degrees.
     * @param projection - Active MapView, needed to get the camera fov and map projection.
     * @param result - Optional output vector.
     * @returns Camera position in world space.
     */
    function getCameraPositionFromTargetCoordinates(targetCoordinates: GeoCoordinates, distance: number, yawDeg: number, pitchDeg: number, projection: Projection, result?: THREE.Vector3): THREE.Vector3;
    /**
     * @hidden
     * @internal
     *
     * Add offset to geo points for minimal view box in flat projection with tile wrapping.
     *
     * @remarks
     * In flat projection, with wrap around enabled, we should detect clusters of points around that
     * wrap antimeridian.
     *
     * Here, we fit points into minimal geo box taking world wrapping into account.
     */
    function wrapGeoPointsToScreen(points: GeoCoordLike[], startPosition?: GeoCoordinates): GeoCoordinates[];
    /**
     * @hidden
     * @internal
     *
     * Given `cameraPos`, force all points that lie on non-visible sphere half to be "near" max
     * possible viewable circle from given camera position.
     *
     * @remarks
     * Assumes that shpere projection with world center is in `(0, 0, 0)`.
     */
    function wrapWorldPointsToView(points: THREE.Vector3[], cameraPos: THREE.Vector3): void;
    /**
     * @hidden
     * @internal
     *
     * Return `GeoPoints` bounding {@link @here/harp-geoutils#GeoBox}
     * applicable for {@link getFitBoundsDistance}.
     *
     * @returns {@link @here/harp-geoutils#GeoCoordinates} set that covers `box`
     */
    function geoBoxToGeoPoints(box: GeoBox): GeoCoordinates[];
    /**
     * @hidden
     * @internal
     *
     * Get minimal distance required for `camera` looking at `worldTarget` to cover `points`.
     *
     * All dimensions belong to world space.
     *
     * @param points - points which shall are to be covered by view
     *
     * @param worldTarget - readonly, world target of {@link MapView}
     * @param camera - readonly, camera with proper `position` and rotation set
     * @returns new distance to camera to be used with {@link (MapView.lookAt:WITH_PARAMS)}
     */
    function getFitBoundsDistance(points: THREE.Vector3[], worldTarget: THREE.Vector3, camera: THREE.PerspectiveCamera): number;
    /**
     * @hidden
     * @internal
     *
     * Paremeters for [[getFitBoundsLookAtParams]] function.
     */
    interface FitPointParams {
        tilt: number;
        heading: number;
        projection: Projection;
        minDistance: number;
        camera: THREE.PerspectiveCamera;
    }
    /**
     * @hidden
     * @internal
     *
     * Get {@link LookAtParams} that fit all `worldPoints`
     * giving that {@link MapView} will target at
     * `geoTarget`.
     *
     * @param geoTarget - desired target (see {@link MapView.target}) as geo point
     * @param worldTarget - same as `geoTarget` but in world space
     * @param worldPoints - points we want to see
     * @param params - other params derived from {@link MapView}.
     */
    function getFitBoundsLookAtParams(geoTarget: GeoCoordinates, worldTarget: THREE.Vector3, worldPoints: THREE.Vector3[], params: FitPointParams): {
        target: GeoCoordinates;
        distance: number;
        heading: number;
        tilt: number;
    };
    /**
     * @deprecated use getCameraPositionFromTargetCoordinates instead
     */
    function getCameraCoordinatesFromTargetCoordinates(targetCoordinates: GeoCoordinates, distance: number, yawDeg: number, pitchDeg: number, mapView: MapView): GeoCoordinates;
    /**
     * Casts a ray in NDC space from the current map view and returns the intersection point of that
     * ray wih the map in world space.
     *
     * @param mapView - Instance of MapView.
     * @param pointOnScreenXinNDC - X coordinate in NDC space.
     * @param pointOnScreenYinNDC - Y coordinate in NDC space.
     * @param elevation - Optional param used to offset the ground plane. Used when wanting to pan
     * based on a plane at some altitude. Necessary for example when panning with terrain.
     *
     * @returns Intersection coordinates, or `null` if raycast failed.
     */
    function rayCastWorldCoordinates(mapView: MapView | {
        camera: THREE.Camera;
        projection: Projection;
    }, pointOnScreenXinNDC: number, pointOnScreenYinNDC: number, elevation?: number): THREE.Vector3 | null;
    /**
     * Pans the camera according to the projection.
     *
     * @param mapView - Instance of MapView.
     * @param xOffset - In world space. Value > 0 will pan the map to the right, value < 0 will pan
     *                  the map to the left in default camera orientation.
     * @param yOffset - In world space. Value > 0 will pan the map upwards, value < 0 will pan the
     *                  map downwards in default camera orientation.
     */
    function panCameraAboveFlatMap(mapView: MapView, offsetX: number, offsetY: number): void;
    /**
     * The function doing a pan in the spherical space
     * when {@link MapView}'s active [[ProjectionType]]
     * is spherical. In other words, the function that rotates the camera around the globe.
     *
     * @param mapView - MapView instance.
     * @param fromWorld - Start vector representing the scene position of a geolocation.
     * @param toWorld - End vector representing the scene position of a geolocation.
     */
    function panCameraAroundGlobe(mapView: MapView, fromWorld: THREE.Vector3, toWorld: THREE.Vector3): void;
    /**
     * Rotates the camera by the given delta yaw and delta pitch. The pitch will be clamped to the
     * maximum possible tilt to the new target, and under the horizon in sphere projection.
     *
     * @param mapView - The {@link MapView} instance in use.
     * @param deltaYawDeg - Delta yaw in degrees.
     * @param deltaPitchDeg - Delta pitch in degrees.
     * @param maxTiltAngleRad - Max tilt angle in radians.
     */
    function rotate(mapView: {
        projection: Projection;
        camera: THREE.PerspectiveCamera;
    }, deltaYawDeg: number, deltaPitchDeg?: number, maxTiltAngleRad?: number): void;
    /**
     * Computes the rotation of the camera according to yaw and pitch in degrees. The computations
     * hinge on the current `projection` and `target`, because yaw and pitch are defined in
     * tangent space of the target point.
     *
     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the
     * map.
     *
     * @param projection - Current projection.
     * @param target - The camera target.
     * @param yawDeg - Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.
     * @param pitchDeg - Pitch in degrees.
     */
    function getCameraRotationAtTarget(projection: Projection, target: GeoCoordinates, yawDeg: number, pitchDeg: number, result?: THREE.Quaternion): THREE.Quaternion;
    /**
     * Sets the rotation of the camera according to yaw and pitch in degrees. The computations hinge
     * on the current projection and `geoCenter`, because yaw and pitch are defined in tangent
     * space. In particular, `MapView#geoCenter` needs to be set before calling `setRotation`.
     *
     * **Note:** `yaw == 0 && pitch == 0` will north up the map and you will look downwards onto the
     * map.
     *
     * @param mapView - Instance of MapView.
     * @param yawDeg - Yaw in degrees, counter-clockwise (as opposed to azimuth), starting north.
     * @param pitchDeg - Pitch in degrees.
     */
    function setRotation(mapView: MapView, yawDeg: number, pitchDeg: number): void;
    /**
     * Extracts current camera tilt angle in radians.
     *
     * @param camera - The [[Camera]] in use.
     * @param projection - The {@link @here/harp-geoutils#Projection} used to
     *                     convert between geo and world coordinates.
     *
     * @deprecated Use MapView.tilt
     */
    function extractCameraTilt(camera: THREE.Camera, projection: Projection): number;
    /**
     * Extracts yaw, pitch, and roll rotation in radians.
     * - Yaw : Rotation around the vertical axis, counter-clockwise (as opposed to azimuth),
     * starting north.
     * - Pitch :Rotation around the horizontal axis.
     * - Roll : Rotation around the view axis.
     *
     * @see https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles
     *
     * @param options - Subset of necessary {@link MapView} properties.
     * @param object - The [[THREE.Object3D]] instance to extract the rotations from.
     */
    function extractAttitude(mapView: {
        projection: Projection;
    }, object: THREE.Object3D): Attitude;
    /**
     * Gets the spherical coordinates in radian of the object to the coordinates of `point`.
     *
     * Note: this method can be used to get the direction that an object points to, when `location`
     * is the target of that object, by adding PI to it. Otherwise it only returns the spherical
     * coordinates of `object` in the tangent space of `location`.
     *
     * @param mapView - The {@link MapView} instance to consider.
     * @param object - The object to get the coordinates from.
     * @param location - The reference point.
     */
    function extractSphericalCoordinatesFromLocation(mapView: {
        projection: Projection;
    }, object: THREE.Object3D, location: GeoCoordinatesLike | Vector3Like): {
        azimuth: number;
        tilt: number;
    };
    /**
     * Gets the tilt angle (in radians) of the object relative to the coordinates of `location`.
     *
     * Note: this method can be used to get the direction that an object points to, when `location`
     * is the target of that object, by adding PI to it. Otherwise it only returns the tilt angle
     * (in radians) of `object` in the tangent space of `location`.
     *
     * @param projection - The {@link @here/harp-geoutils#Projection} used when
     *                     converting from geo to world coordinates.
     * @param object - The object to get the coordinates from.
     * @param location - The reference point.
     * @param tiltAxis - Optional axis used to define the rotation about which the object's tilt
     * occurs, the direction vector to the location from the camera is projected on the plane with
     * the given angle.
     */
    function extractTiltAngleFromLocation(projection: Projection, object: THREE.Object3D, location: GeoCoordinates | Vector3Like, tiltAxis?: THREE.Vector3): number;
    /**
     * Get perspective camera frustum planes distances.
     * @return all plane distances in helper object.
     */
    function getCameraFrustumPlanes(camera: THREE.PerspectiveCamera): {
        left: number;
        right: number;
        top: number;
        bottom: number;
        near: number;
        far: number;
    };
    /**
     * Casts a ray in NDC space from the current view of the camera and returns the intersection
     * point of that ray against the map in geo coordinates. The return value can be `null` when
     * the raycast is above the horizon.
     *
     * @param mapView - Instance of MapView.
     * @param pointOnScreenXNDC -  Abscissa in NDC space.
     * @param pointOnScreenYNDC -  Ordinate in NDC space.
     * @returns Intersection geo coordinates, or `null` if raycast is above the horizon.
     */
    function rayCastGeoCoordinates(mapView: MapView, pointOnScreenXinNDC: number, pointOnScreenYinNDC: number): GeoCoordinates | null;
    /**
     * Calculates and returns the distance from the ground, which is needed to put the camera to
     * this height, to see the size of the area that would be covered by one tile for the given zoom
     * level.
     *
     * @param mapView - Instance of MapView.
     * @param options - Subset of necessary {@link MapView} properties.
     */
    function calculateDistanceToGroundFromZoomLevel(mapView: {
        projection: Projection;
        focalLength: number;
        camera: THREE.PerspectiveCamera;
    }, zoomLevel: number): number;
    /**
     * Calculates and returns the distance to the target point.
     *
     * @param options - Necessary subset of MapView properties to compute the distance.
     * @param zoomLevel - The zoom level to get the equivalent height to.
     */
    function calculateDistanceFromZoomLevel(options: {
        focalLength: number;
    }, zoomLevel: number): number;
    /**
     * Calculates the zoom level, which corresponds to the current distance from
     * camera to lookAt point.
     * Therefore the zoom level is a `float` and not an `int`. The height of the camera can be in
     * between zoom levels. By setting the zoom level, you change the height position of the camera
     * in away that the field of view of the camera should be able to cover one tile for the given
     * zoom level.
     *
     * As an example for this, when you have a tile of zoom level 14 in front of the camera and you
     * set the zoom level of the camera to 14, then you are able to see the whole tile in front of
     * you.
     *
     * @param options - Subset of necessary {@link MapView} properties.
     * @param distance - The distance in meters, which are scene units in {@link MapView}.
     */
    function calculateZoomLevelFromDistance(options: {
        focalLength: number;
        minZoomLevel: number;
        maxZoomLevel: number;
    }, distance: number): number;
    /**
     * Translates a linear clip-space distance value to the actual value stored in the depth buffer.
     * This is useful as the depth values are not stored in the depth buffer linearly, and this can
     * lead into confusing behavior when not taken into account.
     *
     * @param clipDistance - Distance from the camera in clip space (range: [0, 1]).
     * @param camera - Camera applying the perspective projection.
     */
    function calculateDepthFromClipDistance(clipDistance: number, camera: THREE.Camera): number;
    /**
     * Translates a linear distance value [0..1], where 1 is the distance to the far plane, into
     * [0..cameraFar].
     *
     * @param distance - Distance from the camera (range: [0, 1]).
     * @param camera - Camera applying the perspective projection.
     */
    function cameraToWorldDistance(distance: number, camera: THREE.Camera): number;
    /**
     * Calculates vertical field of view for given horizontal field of vision and aspect ratio.
     *
     * @param hFov - Horizontal field of view in rad.
     * @param aspect - Aspect ratio.
     */
    function calculateVerticalFovByHorizontalFov(hFov: number, aspect: number): number;
    /**
     * Calculates horizontal field of view for given vertical field of vision and aspect ratio.
     *
     * @param hFov - Vertical field of view in rad.
     * @param aspect - Aspect ratio.
     */
    function calculateHorizontalFovByVerticalFov(vFov: number, aspect: number): number;
    /**
     * Calculates the focal length based on the vertical FOV and height.
     *
     * @param vFov - Vertical field of view in rad.
     * @param height - Height of canvas in pixels.
     */
    function calculateFocalLengthByVerticalFov(vFov: number, height: number): number;
    /**
     * Calculates the vertical field of view based on the focal length and the height.
     *
     * @param focalLength - Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param height - Height of canvas in pixels.
     */
    function calculateFovByFocalLength(focalLength: number, height: number): number;
    /**
     * Calculates object's screen size based on the focal length and it's camera distance.
     *
     * @param focalLength - Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param distance - Object distance in world space.
     * @param worldSize - Object size in world space.
     * @return object size in screen space.
     */
    function calculateScreenSizeByFocalLength(focalLength: number, distance: number, worldSize: number): number;
    /**
     * Calculates object's world size based on the focal length and it's camera distance.
     *
     * @param focalLength - Focal length in pixels (see [[calculateFocalLengthByVerticalFov]])
     * @param distance - Object distance in world space.
     * @param screenSize - Object size in screen space.
     * @return object size in world space.
     */
    function calculateWorldSizeByFocalLength(focalLength: number, distance: number, screenSize: number): number;
    /**
     * Computes estimate for size of a THREE.Object3D object and its children. Shared materials
     * and/or attributes will be counted multiple times.
     *
     * @param object - The mesh object to evaluate
     * @param size - The {@link MemoryUsage} to update.
     * @param visitedObjects - Optional map to store large objects that could be shared.
     *
     * @returns Estimate of object size in bytes for heap and GPU.
     */
    function estimateObject3dSize(object: THREE.Object3D, parentSize?: MemoryUsage, visitedObjects?: Map<string, boolean>): MemoryUsage;
    /**
     * Check if tiles or other content is currently being loaded.
     *
     * This method can be removed once HARP-7932 is implemented.
     *
     * @returns `true` if MapView has visible tiles or other content that is being loaded.
     */
    function mapViewIsLoading(mapView: MapView): boolean;
    function closeToFrustum(point: THREE.Vector3, camera: THREE.Camera, eps?: number): boolean;
    /**
     * Gets language list used by the browser
     *
     * @returns Array of iso language codes
     */
    function getBrowserLanguages(): string[] | undefined;
}
export declare namespace TileOffsetUtils {
    /**
     * Creates a unique key based on the supplied parameters. Note, the uniqueness is bounded by the
     * bitshift. The [[TileKey.mortonCode()]] supports currently up to 26 levels (this is because
     * 26*2 equals 52, and 2^52 is the highest bit that can be set in an integer in Javascript), the
     * bitshift reduces this accordingly, so given the default bitshift of four, we support up to 24
     * levels. Given the current support up to level 19 this should be fine.
     *
     * @param tileKey - The unique {@link @here/harp-geoutils#TileKey}
     *                  from which to compute the unique key.
     * @param offset - How much the given {@link @here/harp-geoutils#TileKey} is offset
     * @param bitshift - How much space we have to store the offset. The default of 4 means we have
     *      enough space to store 16 unique tiles in a single view.
     */
    function getKeyForTileKeyAndOffset(tileKey: TileKey, offset: number, bitshift?: number): number;
    /**
     * Extracts the offset and morton key from the given key (must be created by:
     * [[getKeyForTileKeyAndOffset]])
     *
     * Note, we can't use bitshift operators in Javascript because they work on 32-bit integers, and
     * would truncate the numbers, hence using powers of two.
     *
     * @param key - Key to extract offset and morton key.
     * @param bitshift - How many bits to shift by, must be the same as was used when creating the
     * key.
     */
    function extractOffsetAndMortonKeyFromKey(key: number, bitshift?: number): {
        offset: number;
        mortonCode: number;
    };
    /**
     * Returns the key of the parent. Key must have been computed using the function
     * [[getKeyForTileKeyAndOffset]].
     *
     * @param calculatedKey - Key to decompose
     * @param bitshift - Bit shift used to create the key
     */
    function getParentKeyFromKey(calculatedKey: number, bitshift?: number): number;
}
//# sourceMappingURL=Utils.d.ts.map