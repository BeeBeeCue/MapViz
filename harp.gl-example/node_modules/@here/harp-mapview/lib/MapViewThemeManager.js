"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapViewThemeManager = void 0;
const harp_utils_1 = require("@here/harp-utils");
const MapViewImageCache_1 = require("./image/MapViewImageCache");
const ThemeLoader_1 = require("./ThemeLoader");
const logger = harp_utils_1.LoggerManager.instance.create("MapViewThemeManager");
/**
 * Class handling theme updates for MapView
 */
class MapViewThemeManager {
    constructor(m_mapView, m_uriResolver) {
        this.m_mapView = m_mapView;
        this.m_uriResolver = m_uriResolver;
        this.m_abortControllers = [];
        this.m_theme = {};
        this.m_isUpdating = false;
        this.m_imageCache = new MapViewImageCache_1.MapViewImageCache(this.m_mapView);
    }
    async getTheme() {
        if (!this.m_themePromise) {
            return this.m_theme;
        }
        else {
            return await this.m_themePromise;
        }
    }
    isLoading() {
        return this.m_themePromise !== undefined;
    }
    isUpdating() {
        return this.m_isUpdating;
    }
    /**
     * @deprecated
     * A helper for the deprecated MapView.theme getter, remove when
     * after deprecation
     */
    get theme() {
        return this.isLoading() ? {} : this.m_theme;
    }
    async loadTheme(theme) {
        if (typeof theme === "string" || !ThemeLoader_1.ThemeLoader.isThemeLoaded(theme)) {
            try {
                this.m_themePromise = ThemeLoader_1.ThemeLoader.load(theme, {
                    uriResolver: this.m_uriResolver,
                    signal: this.createAbortController().signal
                });
                theme = await this.m_themePromise;
            }
            catch (error) {
                logger.error(`failed to load theme: ${error}`, error);
                theme = {};
            }
        }
        this.m_themePromise = undefined;
        return theme;
    }
    async setTheme(theme) {
        var _a, _b;
        if (this.isLoading() || this.isUpdating()) {
            logger.warn("Formerly set Theme is still updating");
            this.m_themePromise = undefined;
            this.cancelThemeUpdate();
        }
        theme = await this.loadTheme(theme);
        this.m_isUpdating = true;
        const environment = this.m_mapView.sceneEnvironment;
        // Fog and sky.
        this.m_theme.fog = theme.fog;
        this.m_theme.sky = theme.sky;
        environment.updateSkyBackground(theme);
        environment.fog.reset(theme);
        this.m_theme.lights = theme.lights;
        environment.updateLighting(theme);
        // Clear color.
        this.m_theme.clearColor = theme.clearColor;
        this.m_theme.clearAlpha = theme.clearAlpha;
        environment.updateClearColor(theme);
        // Images.
        this.m_theme.images = theme.images;
        this.m_theme.imageTextures = theme.imageTextures;
        await this.updateImages(theme);
        // POI tables.
        this.m_theme.poiTables = theme.poiTables;
        await this.loadPoiTables(theme);
        // Text.
        this.m_theme.textStyles = theme.textStyles;
        this.m_theme.defaultTextStyle = theme.defaultTextStyle;
        this.m_theme.fontCatalogs = theme.fontCatalogs;
        await this.m_mapView.resetTextRenderer(theme);
        if (Array.isArray(theme.priorities)) {
            this.m_theme.priorities = theme.priorities;
        }
        this.m_mapView.mapAnchors.setPriorities((_a = theme.priorities) !== null && _a !== void 0 ? _a : []);
        if (Array.isArray(theme.labelPriorities)) {
            this.m_theme.labelPriorities = theme.labelPriorities;
        }
        if (this.m_theme.styles === undefined) {
            this.m_theme.styles = {};
        }
        environment.setBackgroundTheme(theme);
        this.m_theme.styles = (_b = theme.styles) !== null && _b !== void 0 ? _b : {};
        this.m_theme.definitions = theme.definitions;
        for (const dataSource of this.m_mapView.dataSources) {
            dataSource.setTheme(this.m_theme);
        }
        this.m_isUpdating = false;
        return this.m_theme;
    }
    updateCache() {
        this.updateImages(this.m_theme);
        this.m_mapView.sceneEnvironment.updateLighting(this.m_theme);
        this.m_mapView.sceneEnvironment.updateSkyBackground(this.m_theme);
    }
    get imageCache() {
        return this.m_imageCache;
    }
    dispose() {
        this.m_imageCache.clear();
    }
    async loadPoiTables(theme) {
        this.m_mapView.poiTableManager.clear();
        // Add the POI tables defined in the theme.
        await this.m_mapView.poiTableManager.loadPoiTables(theme);
    }
    cancelThemeUpdate() {
        for (var i = 0; i < this.m_abortControllers.length; i++) {
            this.m_abortControllers[i].abort();
        }
        this.m_abortControllers = [];
        this.m_imageCache.clear();
        this.m_mapView.poiManager.clear();
        this.m_mapView.poiTableManager.clear();
    }
    createAbortController() {
        this.m_abortControllers.push(new AbortController());
        return this.m_abortControllers[this.m_abortControllers.length - 1];
    }
    async updateImages(theme) {
        this.m_imageCache.clear();
        this.m_mapView.poiManager.clear();
        if (theme.images !== undefined) {
            for (const name of Object.keys(theme.images)) {
                const image = theme.images[name];
                this.m_imageCache.addImage(name, image.url, image.preload === true);
                if (typeof image.atlas === "string") {
                    await this.m_mapView.poiManager.addTextureAtlas(name, image.atlas, this.createAbortController().signal);
                }
            }
        }
        if (theme.imageTextures !== undefined) {
            theme.imageTextures.forEach((imageTexture) => {
                this.m_mapView.poiManager.addImageTexture(imageTexture);
            });
        }
    }
}
exports.MapViewThemeManager = MapViewThemeManager;
//# sourceMappingURL=MapViewThemeManager.js.map