"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PickHandler = exports.PickObjectType = void 0;
const harp_datasource_protocol_1 = require("@here/harp-datasource-protocol");
const harp_geoutils_1 = require("@here/harp-geoutils");
const THREE = require("three");
const MapViewPoints_1 = require("./MapViewPoints");
const PickListener_1 = require("./PickListener");
/**
 * Describes the general type of a picked object.
 */
var PickObjectType;
(function (PickObjectType) {
    /**
     * Unspecified.
     */
    PickObjectType[PickObjectType["Unspecified"] = 0] = "Unspecified";
    /**
     * A point object.
     */
    PickObjectType[PickObjectType["Point"] = 1] = "Point";
    /**
     * A line object.
     */
    PickObjectType[PickObjectType["Line"] = 2] = "Line";
    /**
     * An area object.
     */
    PickObjectType[PickObjectType["Area"] = 3] = "Area";
    /**
     * The text part of a {@link TextElement}
     */
    PickObjectType[PickObjectType["Text"] = 4] = "Text";
    /**
     * The Icon of a {@link TextElement}.
     */
    PickObjectType[PickObjectType["Icon"] = 5] = "Icon";
    /**
     * Any general 3D object, for example, a landmark.
     */
    PickObjectType[PickObjectType["Object3D"] = 6] = "Object3D";
})(PickObjectType = exports.PickObjectType || (exports.PickObjectType = {}));
const tmpOBB = new harp_geoutils_1.OrientedBox3();
// Intersects the dependent tile objects using the supplied raycaster. Note, because multiple
// tiles can point to the same dependency we need to store which results we have already
// raycasted, see checkedDependencies.
function intersectDependentObjects(tile, intersects, rayCaster, checkedDependencies, mapView) {
    for (const tileKey of tile.dependencies) {
        const mortonCode = tileKey.mortonCode();
        if (checkedDependencies.has(mortonCode)) {
            continue;
        }
        checkedDependencies.add(mortonCode);
        const otherTile = mapView.visibleTileSet.getCachedTile(tile.dataSource, tileKey, tile.offset, mapView.frameNumber);
        if (otherTile !== undefined) {
            rayCaster.intersectObjects(otherTile.objects, true, intersects);
        }
    }
}
/**
 * Handles the picking of scene geometry and roads.
 * @internal
 */
class PickHandler {
    constructor(mapView, camera, enablePickTechnique = false) {
        this.mapView = mapView;
        this.camera = camera;
        this.enablePickTechnique = enablePickTechnique;
    }
    /**
     * Does a raycast on all objects in the scene; useful for picking. This function is Limited to
     * objects that THREE.js can raycast. However, any solid lines that have their geometry in the
     * shader cannot be tested for intersection.
     *
     * @param x - The X position in CSS/client coordinates, without the applied display ratio.
     * @param y - The Y position in CSS/client coordinates, without the applied display ratio.
     * @param parameters - The intersection test behaviour may be adjusted by providing an instance
     * of {@link IntersectParams}.
     * @returns the list of intersection results.
     */
    intersectMapObjects(x, y, parameters) {
        const worldPos = this.mapView.getNormalizedScreenCoordinates(x, y);
        const rayCaster = this.mapView.raycasterFromScreenPoint(x, y);
        const pickListener = new PickListener_1.PickListener(parameters);
        if (this.mapView.textElementsRenderer !== undefined) {
            const { clientWidth, clientHeight } = this.mapView.canvas;
            const screenX = worldPos.x * clientWidth * 0.5;
            const screenY = worldPos.y * clientHeight * 0.5;
            const scenePosition = new THREE.Vector2(screenX, screenY);
            this.mapView.textElementsRenderer.pickTextElements(scenePosition, pickListener);
        }
        const intersects = [];
        const intersectedTiles = this.getIntersectedTiles(rayCaster);
        // This ensures that we check a given dependency only once (because multiple tiles could
        // have the same dependency).
        const checkedDependencies = new Set();
        for (const { tile, distance } of intersectedTiles) {
            if (pickListener.done && pickListener.furthestResult.distance < distance) {
                // Stop when the listener has all results it needs and remaining tiles are further
                // away than then furthest pick result found so far.
                break;
            }
            intersects.length = 0;
            rayCaster.intersectObjects(tile.objects, true, intersects);
            intersectDependentObjects(tile, intersects, rayCaster, checkedDependencies, this.mapView);
            for (const intersect of intersects) {
                pickListener.addResult(this.createResult(intersect));
            }
        }
        // Intersect any objects added by the user.
        intersects.length = 0;
        for (const child of this.mapView.mapAnchors.children) {
            rayCaster.intersectObject(child, true, intersects);
            for (const intersect of intersects) {
                pickListener.addResult(this.createResult(intersect));
            }
        }
        pickListener.finish();
        return pickListener.results;
    }
    createResult(intersection) {
        var _a;
        const pickResult = {
            type: PickObjectType.Unspecified,
            point: intersection.point,
            distance: intersection.distance,
            intersection
        };
        if (intersection.object.userData === undefined ||
            intersection.object.userData.feature === undefined) {
            return pickResult;
        }
        if (this.enablePickTechnique) {
            pickResult.technique = intersection.object.userData.technique;
        }
        pickResult.renderOrder = (_a = intersection.object) === null || _a === void 0 ? void 0 : _a.renderOrder;
        const featureData = intersection.object.userData.feature;
        this.addObjInfo(featureData, intersection, pickResult);
        if (pickResult.userData) {
            const featureId = harp_datasource_protocol_1.getFeatureId(pickResult.userData);
            pickResult.featureId = featureId === 0 ? undefined : featureId;
        }
        let pickObjectType;
        switch (featureData.geometryType) {
            case harp_datasource_protocol_1.GeometryType.Point:
            case harp_datasource_protocol_1.GeometryType.Text:
                pickObjectType = PickObjectType.Point;
                break;
            case harp_datasource_protocol_1.GeometryType.Line:
            case harp_datasource_protocol_1.GeometryType.ExtrudedLine:
            case harp_datasource_protocol_1.GeometryType.SolidLine:
            case harp_datasource_protocol_1.GeometryType.TextPath:
                pickObjectType = PickObjectType.Line;
                break;
            case harp_datasource_protocol_1.GeometryType.Polygon:
            case harp_datasource_protocol_1.GeometryType.ExtrudedPolygon:
                pickObjectType = PickObjectType.Area;
                break;
            case harp_datasource_protocol_1.GeometryType.Object3D:
                pickObjectType = PickObjectType.Object3D;
                break;
            default:
                pickObjectType = PickObjectType.Unspecified;
        }
        pickResult.type = pickObjectType;
        return pickResult;
    }
    getIntersectedTiles(rayCaster) {
        const tiles = new Array();
        const tileList = this.mapView.visibleTileSet.dataSourceTileList;
        tileList.forEach(dataSourceTileList => {
            if (!dataSourceTileList.dataSource.enablePicking) {
                return;
            }
            dataSourceTileList.renderedTiles.forEach(tile => {
                tmpOBB.copy(tile.boundingBox);
                tmpOBB.position.sub(this.mapView.worldCenter);
                // This offset shifts the box by the given tile offset, see renderTileObjects in
                // MapView
                const worldOffsetX = tile.computeWorldOffsetX();
                tmpOBB.position.x += worldOffsetX;
                const distance = tmpOBB.intersectsRay(rayCaster.ray);
                if (distance !== undefined) {
                    tiles.push({ tile, distance });
                }
            });
        });
        tiles.sort((lhs, rhs) => {
            return lhs.distance - rhs.distance;
        });
        return tiles;
    }
    addObjInfo(featureData, intersect, pickResult) {
        if (featureData.objInfos === undefined) {
            return;
        }
        if (pickResult.intersection.object instanceof MapViewPoints_1.MapViewPoints) {
            pickResult.userData = featureData.objInfos[intersect.index];
            return;
        }
        if (featureData.starts === undefined ||
            featureData.starts.length === 0 ||
            (intersect.faceIndex === undefined && intersect.index === undefined)) {
            if (featureData.objInfos.length === 1) {
                pickResult.userData = featureData.objInfos[0];
            }
            return;
        }
        if (featureData.starts.length === 1) {
            pickResult.userData = featureData.objInfos[0];
            return;
        }
        const intersectIndex = intersect.faceIndex !== undefined ? intersect.faceIndex * 3 : intersect.index;
        // TODO: Implement binary search.
        let objInfosIndex = 0;
        for (const featureStartIndex of featureData.starts) {
            if (featureStartIndex > intersectIndex) {
                break;
            }
            objInfosIndex++;
        }
        pickResult.userData = featureData.objInfos[objInfosIndex - 1];
    }
}
exports.PickHandler = PickHandler;
//# sourceMappingURL=PickHandler.js.map