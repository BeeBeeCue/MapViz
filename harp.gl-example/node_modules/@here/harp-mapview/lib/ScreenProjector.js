"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ScreenProjector = void 0;
const THREE = require("three");
/**
 * Determines whether a position in NDC (Normalized Device Coordinates) is inside the screen.
 * @param ndc - The position to check.
 */
function isOnScreen(ndc) {
    return ndc.z > -1 && ndc.z < 1 && ndc.x >= -1 && ndc.x <= 1 && ndc.y >= -1 && ndc.y <= 1;
}
/**
 * Determines whether a position in NDC (Normalized Device Coordinates) is between the near
 * and far plane.
 * @param ndc - The position to check.
 */
function isInRange(ndc) {
    return ndc.z > -1 && ndc.z < 1;
}
/**
 * @hidden
 * Handles the projection of world coordinates to screen coordinates.
 */
class ScreenProjector {
    /**
     * Constructs a new `ScreenProjector`.
     *
     * @param m_camera - Camera to project against.
     */
    constructor(m_camera) {
        this.m_camera = m_camera;
        this.m_width = 0;
        this.m_height = 0;
    }
    /**
     * Height of the screen.
     */
    get width() {
        return this.m_width;
    }
    /**
     * Width of the screen.
     */
    get height() {
        return this.m_height;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector into
     * screen coordinates.
     *
     * @param {(Vector3Like)} source The source vector to project.
     * @param {THREE.Vector2} target The target vector.
     * @returns {THREE.Vector2} The projected vector (the parameter 'target')
     */
    project(source, target = new THREE.Vector2()) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        return this.ndcToScreen(p, target);
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector into
     * screen coordinates.
     *
     * @param {(Vector3Like)} source The source vector to project.
     * @param {THREE.Vector2} target The target vector.
     * @returns {THREE.Vector2} The projected vector (the parameter 'target') or undefined if
     * outside of the near/far plane. The point may be outside the screen.
     */
    projectToScreen(source, target = new THREE.Vector2()) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        if (isInRange(p)) {
            return this.ndcToScreen(p, target);
        }
        return undefined;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector into
     * screen coordinates. The z component between -1 and 1 is also returned.
     *
     * @param {(Vector3Like)} source The source vector to project.
     * @param {THREE.Vector3} target The target vector.
     * @returns {THREE.Vector3} The projected vector (the parameter 'target') or undefined if
     * outside the near / far plane.
     */
    project3(source, target = new THREE.Vector3()) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        if (p.z > -1 && p.z < 1) {
            target.set((p.x * this.m_width) / 2, (p.y * this.m_height) / 2, p.z);
            return target;
        }
        return undefined;
    }
    /**
     * Apply current projectionViewMatrix of the camera to project the source vector. Stores
     * result in NDC in the target vector.
     *
     * @param {(Vector3Like)} source The source vector to project.
     * @param {THREE.Vector3} target The target vector.
     * @returns {THREE.Vector3} The projected vector (the parameter 'target').
     */
    projectVector(source, target) {
        target.set(source.x, source.y, source.z).project(this.m_camera);
        return target;
    }
    /**
     * Fast test to check if projected point is on screen.
     *
     * @returns {boolean} `true` if point is on screen, `false` otherwise.
     */
    onScreen(source) {
        const p = this.projectVector(source, ScreenProjector.tempV3);
        return isOnScreen(p);
    }
    /**
     * Update the `ScreenProjector` with the latest values of the screen and the camera.
     *
     * @param {THREE.Camera} camera Camera to project against.
     * @param {number} width Width of screen/canvas.
     * @param {number} height Height of screen/canvas.
     */
    update(camera, width, height) {
        this.m_camera = camera;
        this.m_width = width;
        this.m_height = height;
    }
    ndcToScreen(ndc, screenCoords) {
        return screenCoords.set((ndc.x * this.m_width) / 2, (ndc.y * this.m_height) / 2);
    }
}
exports.ScreenProjector = ScreenProjector;
ScreenProjector.tempV2 = new THREE.Vector2();
ScreenProjector.tempV3 = new THREE.Vector3();
//# sourceMappingURL=ScreenProjector.js.map