"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.BackgroundDataSource = void 0;
const harp_geoutils_1 = require("@here/harp-geoutils");
const DataSource_1 = require("./DataSource");
const TileGeometryCreator_1 = require("./geometry/TileGeometryCreator");
const Tile_1 = require("./Tile");
/**
 * Provides background geometry for all tiles.
 */
class BackgroundDataSource extends DataSource_1.DataSource {
    constructor() {
        super({ name: "background" });
        this.m_tilingScheme = BackgroundDataSource.DEFAULT_TILING_SCHEME;
        this.cacheable = true;
        this.addGroundPlane = true;
        this.enablePicking = false;
    }
    updateStorageLevelOffset() {
        let storageLevelOffset;
        this.mapView.dataSources.forEach(ds => {
            if (ds === this) {
                return;
            }
            const tilingScheme = ds.getTilingScheme();
            if (tilingScheme === this.m_tilingScheme) {
                storageLevelOffset =
                    storageLevelOffset === undefined
                        ? ds.storageLevelOffset
                        : Math.max(storageLevelOffset, ds.storageLevelOffset);
            }
        });
        if (storageLevelOffset === undefined) {
            storageLevelOffset = 0;
        }
        if (storageLevelOffset !== this.storageLevelOffset) {
            this.storageLevelOffset = storageLevelOffset;
            this.mapView.clearTileCache(this.name);
        }
    }
    /** @override */
    setTheme(theme, languages) {
        this.mapView.clearTileCache(this.name);
    }
    setTilingScheme(tilingScheme) {
        const newScheme = tilingScheme !== null && tilingScheme !== void 0 ? tilingScheme : BackgroundDataSource.DEFAULT_TILING_SCHEME;
        if (newScheme === this.m_tilingScheme) {
            return;
        }
        this.m_tilingScheme = newScheme;
        this.updateStorageLevelOffset();
        this.mapView.clearTileCache(this.name);
    }
    /** @override */
    getTilingScheme() {
        return this.m_tilingScheme;
    }
    /** @override */
    getTile(tileKey) {
        const tile = new Tile_1.Tile(this, tileKey);
        tile.forceHasGeometry(true);
        TileGeometryCreator_1.TileGeometryCreator.instance.addGroundPlane(tile, Number.MIN_SAFE_INTEGER);
        return tile;
    }
}
exports.BackgroundDataSource = BackgroundDataSource;
BackgroundDataSource.DEFAULT_TILING_SCHEME = harp_geoutils_1.webMercatorTilingScheme;
//# sourceMappingURL=BackgroundDataSource.js.map