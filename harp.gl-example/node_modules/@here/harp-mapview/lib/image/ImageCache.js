"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ImageCache = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_utils_1 = require("@here/harp-utils");
const THREE = require("three");
const MipMapGenerator_1 = require("./MipMapGenerator");
const logger = harp_utils_1.LoggerManager.instance.create("ImageCache");
const mipMapGenerator = new MipMapGenerator_1.MipMapGenerator();
/**
 * Combines an {@link ImageItem} with a list of {@link MapView}s that reference it.
 */
class ImageCacheItem {
    /**
     * Instantiates `ImageCacheItem`.
     *
     * @param imageItem - The {@link ImageItem} referenced by
     *                    the associated {@link MapView}s instances.
     * @param mapView - An optional first {@link MapView} referencing the {@link ImageItem}.
     */
    constructor(imageItem, mapView) {
        this.imageItem = imageItem;
        /**
         * The list of {@link MapView}s referencing the {@link ImageItem}.
         */
        this.mapViews = [];
        if (mapView !== undefined) {
            this.mapViews.push(mapView);
        }
    }
}
/**
 * `ImageCache` is a singleton, so it can be used with multiple MapViews on a single page.
 *
 * @remarks
 * This allows to have an image loaded only once for multiple views.
 * THREE is doing something similar,
 * but does not allow to share images that have been loaded from a canvas (which we may need to do
 * if we use SVG images for textures).
 *
 * One application that makes our own cache necessary is the generation of our own textures from
 * data that is not an URL.
 *
 * The `ImageCache` can be improved by adding satistics for memory footprint as well.
 */
class ImageCache {
    constructor() {
        this.m_images = new Map();
    }
    /**
     * Returns the singleton `instance` of the `ImageCache`.
     */
    static get instance() {
        if (ImageCache.m_instance === undefined) {
            ImageCache.m_instance = new ImageCache();
        }
        return ImageCache.m_instance;
    }
    /**
     * Dispose the singleton object.
     *
     * @remarks
     * Not normally implemented for singletons, but good for debugging.
     */
    static dispose() {
        ImageCache.m_instance = undefined;
    }
    /**
     * Add an image definition to the global cache. Useful when the image data is already loaded.
     *
     * @param mapView - Specifiy which {@link MapView} requests the image.
     * @param url - URL of image.
     * @param imageData - Optional {@link ImageData}containing the image content.
     * @param htmlElement - Optional containing a HtmlCanvasElement or a HtmlImageElement as conten.
     */
    registerImage(mapView, url, imageData, htmlElement) {
        let imageCacheItem = this.findImageCacheItem(url);
        if (imageCacheItem !== undefined) {
            if (mapView !== undefined && !imageCacheItem.mapViews.includes(mapView)) {
                imageCacheItem.mapViews.push(mapView);
            }
            return imageCacheItem.imageItem;
        }
        const mapViews = [];
        if (mapView !== undefined) {
            mapViews.push(mapView);
        }
        imageCacheItem = {
            imageItem: {
                url,
                imageData,
                htmlElement: htmlElement,
                loaded: false
            },
            mapViews
        };
        this.m_images.set(url, imageCacheItem);
        return imageCacheItem.imageItem;
    }
    /**
     * Add an image definition, and optionally start loading the content.
     *
     * @param mapView - {@link MapView} requesting the image.
     * @param url - URL of image.
     * @param startLoading - Optional flag. If `true` the image will be loaded in the background.
     * @param htmlElement - Optional containing a HtmlCanvasElement or a HtmlImageElement as content,
     * if set, `startLoading = true` will start the rendering process in the background.
     */
    addImage(mapView, url, startLoading = true, htmlElement) {
        const imageItem = this.registerImage(mapView, url, undefined, htmlElement);
        if (imageItem !== undefined && startLoading === true) {
            return this.loadImage(imageItem);
        }
        return imageItem;
    }
    /**
     * Remove an image from the cache..
     *
     * @param url - URL of the image.
     * @returns `true` if image has been removed.
     */
    removeImage(url) {
        const cacheItem = this.m_images.get(url);
        if (cacheItem !== undefined) {
            this.m_images.delete(url);
            this.cancelLoading(cacheItem.imageItem);
            return true;
        }
        return false;
    }
    /**
     * Remove an image from the cache.
     *
     * @param imageItem - Item identifying the image.
     * @returns `true` if image has been removed.
     */
    removeImageItem(imageItem) {
        if (this.m_images.has(imageItem.url) !== undefined) {
            this.m_images.delete(imageItem.url);
            this.cancelLoading(imageItem);
            return true;
        }
        return false;
    }
    /**
     * Remove images from the cache using a filter function.
     *
     * @param itemFilter - Filter to identify images to remove. Should return `true` if item
     * should be removed.
     * @returns Number of images removed.
     */
    removeImageItems(itemFilter) {
        const oldSize = this.m_images.size;
        [...this.m_images.values()].filter((cacheItem) => {
            if (itemFilter(cacheItem.imageItem)) {
                this.m_images.delete(cacheItem.imageItem.url);
                this.cancelLoading(cacheItem.imageItem);
            }
        });
        return oldSize - this.m_images.size;
    }
    /**
     * Find {@link ImageItem} for the specified URL.
     *
     * @param url - URL of image.
     * @returns `ImageItem` for the URL if the URL is registered, `undefined` otherwise.
     */
    findImage(url) {
        const cacheItem = this.m_images.get(url);
        if (cacheItem !== undefined) {
            return cacheItem.imageItem;
        }
        return undefined;
    }
    /**
     * Clear all {@link ImageItem}s belonging to a {@link MapView}.
     *
     * @remarks
     * May remove cached items if no
     * {@link MapView} are registered anymore.
     *
     * @param mapView - MapView to remove all {@link ImageItem}s from.
     * @returns Number of images removed.
     */
    clear(mapView) {
        const oldSize = this.m_images.size;
        const itemsToRemove = [];
        this.m_images.forEach(cacheItem => {
            const mapViewIndex = cacheItem.mapViews.indexOf(mapView);
            if (mapViewIndex >= 0) {
                cacheItem.mapViews.splice(mapViewIndex, 1);
            }
            if (cacheItem.mapViews.length === 0) {
                itemsToRemove.push(cacheItem.imageItem.url);
                this.cancelLoading(cacheItem.imageItem);
            }
        });
        for (const keyToDelete of itemsToRemove) {
            this.m_images.delete(keyToDelete);
        }
        return oldSize - this.m_images.size;
    }
    /**
     * Clear all {@link ImageItem}s from all {@link MapView}s.
     */
    clearAll() {
        this.m_images.forEach(cacheItem => {
            this.cancelLoading(cacheItem.imageItem);
        });
        this.m_images = new Map();
    }
    /**
     * Returns the number of all cached {@link ImageItem}s.
     */
    get size() {
        return this.m_images.size;
    }
    /**
     * Load an {@link ImageItem}.
     *
     * @remarks
     * If the loading process is already running, it returns the current promise.
     *
     * @param imageItem - `ImageItem` containing the URL to load image from.
     * @returns An {@link ImageItem} if the image has already been loaded, a promise otherwise.
     */
    loadImage(imageItem) {
        if (imageItem.imageData !== undefined) {
            return imageItem;
        }
        if (imageItem.loadingPromise !== undefined) {
            return imageItem.loadingPromise;
        }
        if (imageItem.htmlElement) {
            imageItem.loadingPromise = new Promise((resolve, reject) => {
                if (imageItem.htmlElement instanceof HTMLImageElement &&
                    !imageItem.htmlElement.complete) {
                    imageItem.htmlElement.addEventListener("load", this.createOnImageLoaded(imageItem, resolve, reject));
                    imageItem.htmlElement.addEventListener("error", err => {
                        reject("The image with src: " +
                            imageItem.htmlElement.src +
                            " could not be loaded: " +
                            err.message);
                    });
                }
                else {
                    this.createOnImageLoaded(imageItem, resolve, reject
                    // cast to be a HtmlCanvasElement, as undefined and HtmlImageElement are
                    // already excluded from the conditions above
                    )(imageItem.htmlElement);
                }
            });
        }
        else {
            const imageLoader = new THREE.ImageLoader();
            imageItem.loadingPromise = new Promise((resolve, reject) => {
                logger.debug(`Loading image: ${imageItem.url}`);
                if (imageItem.cancelled === true) {
                    logger.debug(`Cancelled loading image: ${imageItem.url}`);
                    resolve(undefined);
                }
                else {
                    imageLoader.load(imageItem.url, this.createOnImageLoaded(imageItem, resolve, reject), undefined, errorEvent => {
                        logger.error(`... loading image failed: ${imageItem.url} : ${errorEvent}`);
                        imageItem.loadingPromise = undefined;
                        reject(`... loading image failed: ${imageItem.url} : ${errorEvent}`);
                    });
                }
            });
        }
        return imageItem.loadingPromise;
    }
    /**
     * Apply a function to every `ImageItem` in the cache.
     *
     * @param func - Function to apply to every `ImageItem`.
     */
    apply(func) {
        this.m_images.forEach(cacheItem => {
            func(cacheItem.imageItem);
        });
    }
    createOnImageLoaded(imageItem, onDone, onError) {
        return (image) => {
            logger.debug(`... finished loading image: ${imageItem.url}`);
            if (imageItem.cancelled === true) {
                logger.debug(`Cancelled loading image: ${imageItem.url}`);
                onDone(undefined);
            }
            this.renderImage(imageItem, image)
                .then(() => {
                imageItem.mipMaps = mipMapGenerator.generateTextureAtlasMipMap(imageItem);
                imageItem.loadingPromise = undefined;
                imageItem.htmlElement = undefined;
                onDone(imageItem);
            })
                .catch(ex => {
                logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);
                onError(imageItem, `... loading image failed: ${imageItem.url} : ${ex}`);
            });
        };
    }
    /**
     * Find the cached {@link ImageItem} by URL.
     *
     * @param url - URL of image.
     */
    findImageCacheItem(url) {
        return this.m_images.get(url);
    }
    /**
     * Render the `ImageItem` by using `createImageBitmap()` or by rendering the image into a
     * `HTMLCanvasElement`.
     *
     * @param imageItem - {@link ImageItem} to assign image data to.
     * @param image - `HTMLImageElement`
     */
    renderImage(imageItem, image) {
        return new Promise((resolve, reject) => {
            if (imageItem.cancelled) {
                resolve(undefined);
            }
            // use createImageBitmap if it is available. It should be available in webworkers as
            // well
            if (typeof createImageBitmap === "function") {
                const options = {
                    premultiplyAlpha: "default"
                };
                logger.debug(`Creating bitmap image: ${imageItem.url}`);
                createImageBitmap(image, 0, 0, image.width, image.height, options)
                    .then(imageBitmap => {
                    if (imageItem.cancelled) {
                        resolve(undefined);
                    }
                    logger.debug(`... finished creating bitmap image: ${imageItem.url}`);
                    imageItem.loadingPromise = undefined;
                    imageItem.imageData = imageBitmap;
                    imageItem.loaded = true;
                    resolve(imageBitmap);
                })
                    .catch(ex => {
                    logger.error(`... loading image failed: ${imageItem.url} : ${ex}`);
                    reject(ex);
                });
            }
            else {
                try {
                    if (typeof document === "undefined") {
                        logger.error("Error: document is not available, cannot generate image");
                        reject(new Error("ImageCache#renderImage: document is not available, cannot " +
                            "render image to create texture"));
                    }
                    // TODO: Extract the rendering to the canvas part and make it configurable for
                    // the client, so it does not rely on the `document`.
                    // use the image, e.g. draw part of it on a canvas
                    let canvas;
                    if (image instanceof HTMLCanvasElement) {
                        canvas = image;
                    }
                    else {
                        canvas = document.createElement("canvas");
                        canvas.width = image.width;
                        canvas.height = image.height;
                    }
                    const context = canvas.getContext("2d");
                    if (context !== null) {
                        logger.debug(`... finished creating bitmap image in canvas: ${imageItem.url} ${image}`);
                        context.drawImage(image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height);
                        const imageData = context.getImageData(0, 0, image.width, image.height);
                        imageItem.imageData = imageData;
                        imageItem.loaded = true;
                        resolve(imageData);
                    }
                    else {
                        logger.error(`renderImage: no context found`);
                        reject(new Error(`ImageCache#renderImage: no context found`));
                    }
                }
                catch (ex) {
                    logger.error(`renderImage failed: ${ex}`);
                    imageItem.imageData = undefined;
                    imageItem.loaded = true;
                    reject(new Error(`ImageCache#renderImage failed: ${ex}`));
                }
            }
        });
    }
    /**
     * Cancel loading an image.
     *
     * @param imageItem - Item to cancel loading.
     */
    cancelLoading(imageItem) {
        if (imageItem.loadingPromise !== undefined) {
            // Notify that we are cancelling.
            imageItem.cancelled = true;
        }
    }
}
exports.ImageCache = ImageCache;
//# sourceMappingURL=ImageCache.js.map