"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapMaterialAdapter = void 0;
const harp_datasource_protocol_1 = require("@here/harp-datasource-protocol");
const harp_materials_1 = require("@here/harp-materials");
const THREE = require("three");
const DecodedTileHelpers_1 = require("./DecodedTileHelpers");
/**
 * @hidden
 *
 * {@link MapView} specific data assigned to `THREE.Material` instance in installed in `userData`.
 *
 * [[MapMaterialAdapter]] is registered in `usedData.mapAdapter` property of `THREE.Material`.
 */
class MapMaterialAdapter {
    constructor(material, styledProperties) {
        this.m_lastUpdateFrameNumber = -1;
        this.material = material;
        this.styledProperties = styledProperties;
        this.currentStyledProperties = {};
        this.m_dynamicProperties = [];
        for (const propName in styledProperties) {
            if (!styledProperties.hasOwnProperty(propName)) {
                continue;
            }
            const propDefinition = styledProperties[propName];
            if (harp_datasource_protocol_1.Expr.isExpr(propDefinition) || typeof propDefinition === "function") {
                this.m_dynamicProperties.push([propName, propDefinition]);
            }
            else {
                this.currentStyledProperties[propName] = propDefinition;
            }
        }
        this.setupStaticProperties();
    }
    /**
     * Resolve `MapMaterialAdapter` associated with `material`.
     */
    static get(material) {
        var _a;
        const mapAdapter = (_a = material.userData) === null || _a === void 0 ? void 0 : _a.mapAdapter;
        if (mapAdapter instanceof MapMaterialAdapter) {
            return mapAdapter;
        }
        else if (mapAdapter !== undefined) {
            // NOTE: we can rebuild MapMaterialAdapter here if userData.mapAdapter contains
            // stylesed etc, this can be done to rebuild previously saved scene
            return undefined;
        }
        else {
            return undefined;
        }
    }
    static install(objData) {
        if (!objData.material.userData) {
            objData.material.userData = {};
        }
        return (objData.material.userData.mapAdapter = objData);
    }
    static create(material, styledProperties) {
        return MapMaterialAdapter.install(new MapMaterialAdapter(material, styledProperties));
    }
    static ensureUpdated(material, context) {
        var _a, _b;
        return (_b = (_a = MapMaterialAdapter.get(material)) === null || _a === void 0 ? void 0 : _a.ensureUpdated(context)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Serialize contents.
     *
     * `THREE.Material.userData` is serialized during `clone`/`toJSON`, so we need to ensure that
     * we emit only "data" set of this object.
     */
    toJSON() {
        return { styledProperties: this.styledProperties };
    }
    /**
     * Ensure that underlying object is updated to current state of {@link MapView}.
     *
     * Updates dynamically styled properties of material by evaluating scene dependent expressions.
     *
     * Executes updates only once per frame basing on [[MapView.frameNumber]].
     *
     * @returns `true` if object performed some kind of update, `false` if no update was needed.
     */
    ensureUpdated(context) {
        if (this.m_lastUpdateFrameNumber === context.frameNumber) {
            return false;
        }
        this.m_lastUpdateFrameNumber = context.frameNumber;
        return this.updateDynamicProperties(context);
    }
    /**
     * Applies static properties to target material.
     */
    setupStaticProperties() {
        var _a, _b;
        let updateBaseColor = false;
        for (const propName in this.styledProperties) {
            if (!this.styledProperties.hasOwnProperty(propName)) {
                continue;
            }
            const currentValue = this.currentStyledProperties[propName];
            if (currentValue === undefined || currentValue === null) {
                continue;
            }
            if (propName === "color" || propName === "opacity") {
                updateBaseColor = true;
            }
            else {
                this.applyMaterialGenericProp(propName, currentValue);
            }
        }
        if (updateBaseColor) {
            const color = (_a = this.currentStyledProperties.color) !== null && _a !== void 0 ? _a : 0xff0000;
            const opacity = (_b = this.currentStyledProperties.opacity) !== null && _b !== void 0 ? _b : 1;
            this.applyMaterialBaseColor(color, opacity);
        }
    }
    /**
     * Applies static properties to target material.
     */
    updateDynamicProperties(context) {
        var _a, _b;
        let somethingChanged = false;
        if (this.m_dynamicProperties.length > 0) {
            let updateBaseColor = false;
            for (const [propName, propDefinition] of this.m_dynamicProperties) {
                const newValue = harp_datasource_protocol_1.Expr.isExpr(propDefinition)
                    ? harp_datasource_protocol_1.getPropertyValue(propDefinition, context.env)
                    : propDefinition(context);
                if (newValue === this.currentStyledProperties[propName]) {
                    continue;
                }
                this.currentStyledProperties[propName] = newValue;
                // `color` and `opacity` are special properties to support RGBA
                if (propName === "color" || propName === "opacity") {
                    updateBaseColor = true;
                }
                else {
                    this.applyMaterialGenericProp(propName, newValue);
                    somethingChanged = true;
                }
            }
            if (updateBaseColor) {
                const color = (_a = this.currentStyledProperties.color) !== null && _a !== void 0 ? _a : 0xff0000;
                const opacity = (_b = this.currentStyledProperties.opacity) !== null && _b !== void 0 ? _b : 1;
                this.applyMaterialBaseColor(color, opacity);
                somethingChanged = true;
            }
        }
        return somethingChanged;
    }
    applyMaterialGenericProp(propName, value) {
        const m = this.material;
        if (m[propName] instanceof THREE.Color) {
            let colorValue = value;
            if (typeof colorValue !== "number") {
                const parsed = DecodedTileHelpers_1.evaluateColorProperty(colorValue);
                if (parsed === undefined) {
                    return;
                }
                colorValue = parsed;
            }
            const rgbValue = harp_datasource_protocol_1.ColorUtils.removeAlphaFromHex(colorValue);
            m[propName].set(rgbValue);
        }
        else {
            m[propName] = value;
        }
    }
    applyMaterialBaseColor(color, opacity) {
        if (typeof color !== "number") {
            const parsed = DecodedTileHelpers_1.evaluateColorProperty(color);
            if (parsed === undefined) {
                return;
            }
            color = parsed;
        }
        const { r, g, b, a } = harp_datasource_protocol_1.ColorUtils.getRgbaFromHex(color !== null && color !== void 0 ? color : 0xff0000);
        const actualOpacity = a * THREE.MathUtils.clamp(opacity !== null && opacity !== void 0 ? opacity : 1, 0, 1);
        this.material.opacity = actualOpacity;
        this.material.color.setRGB(r, g, b);
        const opaque = actualOpacity >= 1.0;
        if (!opaque) {
            harp_materials_1.enableBlending(this.material);
        }
        else {
            harp_materials_1.disableBlending(this.material);
        }
    }
}
exports.MapMaterialAdapter = MapMaterialAdapter;
//# sourceMappingURL=MapMaterialAdapter.js.map