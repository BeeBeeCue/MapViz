"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PickingRaycaster = void 0;
const THREE = require("three");
const MapObjectAdapter_1 = require("./MapObjectAdapter");
function intersectObject(object, raycaster, env, intersects, recursive) {
    if (object.layers.test(raycaster.layers) && object.visible) {
        const mapObjectAdapter = MapObjectAdapter_1.MapObjectAdapter.get(object);
        if (!mapObjectAdapter || mapObjectAdapter.isPickable(env)) {
            object.raycast(raycaster, intersects);
        }
    }
    if (recursive === true) {
        for (const child of object.children) {
            intersectObject(child, raycaster, env, intersects, true);
        }
    }
}
/**
 * Raycasting points is not supported as necessary in Three.js. This class extends a
 * [[THREE.Raycaster]] and adds the width / height of the canvas to allow picking of screen space
 * geometry.
 *
 * @internal
 */
class PickingRaycaster extends THREE.Raycaster {
    /**
     * Constructor.
     *
     * @param width - the canvas width.
     * @param height - the canvas height.
     * @param m_env - the view enviroment.
     */
    constructor(width, height, m_env) {
        super();
        this.width = width;
        this.height = height;
        this.m_env = m_env;
    }
    // HARP-9585: Override of base class method, however tslint doesn't recognize overrides of
    // three.js classes.
    intersectObject(object, recursive, optionalTarget) {
        const intersects = optionalTarget !== null && optionalTarget !== void 0 ? optionalTarget : [];
        intersectObject(object, this, this.m_env, intersects, recursive);
        return intersects;
    }
    // HARP-9585: Override of base class method, however tslint doesn't recognize overrides of
    // three.js classes.
    intersectObjects(objects, recursive, optionalTarget) {
        const intersects = optionalTarget !== null && optionalTarget !== void 0 ? optionalTarget : [];
        for (const object of objects) {
            intersectObject(object, this, this.m_env, intersects, recursive);
        }
        return intersects;
    }
}
exports.PickingRaycaster = PickingRaycaster;
//# sourceMappingURL=PickingRaycaster.js.map