"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MapObjectAdapter = void 0;
const harp_datasource_protocol_1 = require("@here/harp-datasource-protocol");
const MapMaterialAdapter_1 = require("./MapMaterialAdapter");
/**
 * @hidden
 *
 * {@link MapView} specific data assigned to `THREE.Object3D` instance in installed in `userData`.
 *
 * [[MapObjectAdapter]] is registered in `usedData.mapAdapter` property of `THREE.Object3D`.
 */
class MapObjectAdapter {
    constructor(object, params) {
        var _a;
        this.m_lastUpdateFrameNumber = -1;
        this.m_notCompletlyTransparent = true;
        this.object = object;
        this.technique = params.technique;
        this.kind = params.kind;
        this.m_pickable = (_a = params.pickable) !== null && _a !== void 0 ? _a : true;
        this.m_notCompletlyTransparent = this.getObjectMaterials().some(material => material.opacity > 0);
    }
    /**
     * Resolve `MapObjectAdapter` associated with `object`.
     */
    static get(object) {
        var _a;
        return ((_a = object.userData) === null || _a === void 0 ? void 0 : _a.mapAdapter) instanceof MapObjectAdapter
            ? object.userData.mapAdapter
            : undefined;
    }
    static install(objData) {
        if (!objData.object.userData) {
            objData.object.userData = {};
        }
        return (objData.object.userData.mapAdapter = objData);
    }
    static create(object, params) {
        return MapObjectAdapter.install(new MapObjectAdapter(object, params));
    }
    static ensureUpdated(object, context) {
        var _a, _b;
        return (_b = (_a = MapObjectAdapter.get(object)) === null || _a === void 0 ? void 0 : _a.ensureUpdated(context)) !== null && _b !== void 0 ? _b : false;
    }
    /**
     * Serialize contents.
     *
     * `THREE.Object3d.userData` is serialized during `clone`/`toJSON`, so we need to ensure that
     * we emit only "data" set of this object.
     */
    toJSON() {
        return { kind: this.kind, technique: this.technique };
    }
    /**
     * Ensure that underlying object is updated to current state of {@link MapView}.
     *
     * Updates object and attachments like materials to current state by evaluating scene dependent
     * expressions.
     *
     * Executes updates only once per frame basing on [[MapView.frameNumber]].
     *
     * Delegates updates of materials to [[MapMaterialAdapter.ensureUpdated]].
     *
     * @returns `true` if object performed some kind of update, `false` if no update was needed.
     */
    ensureUpdated(context) {
        if (this.m_lastUpdateFrameNumber === context.frameNumber) {
            return false;
        }
        this.m_lastUpdateFrameNumber = context.frameNumber;
        return this.updateMaterials(context);
    }
    /**
     * Whether underlying `THREE.Object3D` is actually visible in scene.
     */
    isVisible() {
        return this.object.visible && this.m_notCompletlyTransparent;
    }
    /**
     * Whether underlying `THREE.Object3D` should be pickable by {@link PickHandler}.
     * @param env - Property lookup environment.
     */
    isPickable(env) {
        var _a;
        // An object is pickable only if it's visible, not transient and it's not explicitely marked
        // as non-pickable.
        return (this.m_pickable &&
            this.isVisible() &&
            harp_datasource_protocol_1.getPropertyValue((_a = this.technique) === null || _a === void 0 ? void 0 : _a.transient, env) !== true);
    }
    updateMaterials(context) {
        let somethingChanged = false;
        const materials = this.getObjectMaterials();
        for (const material of materials) {
            const changed = MapMaterialAdapter_1.MapMaterialAdapter.ensureUpdated(material, context);
            somethingChanged = somethingChanged || changed;
        }
        if (somethingChanged) {
            this.m_notCompletlyTransparent = materials.some(material => material.opacity > 0);
        }
        return somethingChanged;
    }
    getObjectMaterials() {
        const object = this.object;
        return Array.isArray(object.material)
            ? object.material
            : object.material !== undefined
                ? [object.material]
                : [];
    }
}
exports.MapObjectAdapter = MapObjectAdapter;
//# sourceMappingURL=MapObjectAdapter.js.map