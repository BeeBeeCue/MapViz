"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PoiRenderer = void 0;
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
const harp_datasource_protocol_1 = require("@here/harp-datasource-protocol");
const harp_materials_1 = require("@here/harp-materials");
const harp_utils_1 = require("@here/harp-utils");
const THREE = require("three");
const MipMapGenerator_1 = require("../image/MipMapGenerator");
const BoxBuffer_1 = require("./BoxBuffer");
const logger = harp_utils_1.LoggerManager.instance.create("PoiRenderer");
const INVALID_RENDER_BATCH = -1;
const tempPos = new THREE.Vector3(0);
/**
 * Neutral color used as `vColor` attribute of [[IconMaterial]] if no `iconColor` color was
 * specified.
 */
const neutralColor = new THREE.Color(1, 1, 1);
/**
 * Temporary color instance used by `addPoi` to pass color derived from `iconBrightness` property.
 */
const tmpIconColor = new THREE.Color();
/**
 * The `PoiRenderBufferBatch` contains the geometry and the material for all POIs that share the
 * same icon image ({@link @here/harp-datasource-protocol#ImageTexture}).
 *
 * @remarks
 * If the image is the same, all the objects in this batch can
 * share the same material, which makes them renderable in the same draw call, whatever the number
 * of actual objects (WebGL limits apply!).
 *
 * There is a `PoiRenderBufferBatch` for every icon in a texture atlas, since the size of the icon
 * in the atlas as well as the texture coordinates are specified in the `PoiRenderBufferBatch`.
 */
class PoiRenderBufferBatch {
    /**
     * Create the `PoiRenderBufferBatch`.
     *
     * @param mapView - The {@link MapView} instance.
     * @param scene - The three.js scene to add the POIs to.
     * @param imageItem - The icon that will have his material shared.
     * @param renderOrder - RenderOrder of the batch geometry's [[Mesh]].
     */
    constructor(mapView, scene, imageItem, renderOrder) {
        this.mapView = mapView;
        this.scene = scene;
        this.imageItem = imageItem;
        this.renderOrder = renderOrder;
    }
    /**
     * Initialize with the {@link @here/harp-datasource-protocol#ImageTexture}.
     *
     * @remarks
     * Loads the image and sets up the icon size, the texture
     * coordinates and material of the batch. Since image loading is done asynchronously, this
     * batch cannot be rendered right away. MapView#update is being triggered if it loaded
     * successfully.
     */
    init() {
        if (this.boxBuffer === undefined) {
            this.setup();
        }
    }
    /**
     * Clean the `PoiRenderBufferBatch`, remove all icon boxes. Called before starting a new frame.
     */
    reset() {
        if (this.boxBuffer === undefined) {
            this.init();
        }
        this.boxBuffer.reset();
    }
    /**
     * Update the geometry with all the added boxes during the frame.
     */
    update() {
        if (this.boxBuffer === undefined) {
            this.init();
        }
        this.boxBuffer.updateBufferGeometry();
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the
     * `PoiRenderBufferBatch`.
     *
     * @param info - The info object to increment with the values from this `PoiRenderBufferBatch`.
     */
    updateMemoryUsage(info) {
        if (this.boxBuffer !== undefined) {
            this.boxBuffer.updateMemoryUsage(info);
        }
    }
    /**
     * Setup texture and material for the batch.
     */
    setup() {
        // Texture images should be generated with premultiplied alpha
        const premultipliedAlpha = true;
        const texture = new THREE.Texture(this.imageItem.imageData, THREE.UVMapping, undefined, undefined, PoiRenderBufferBatch.trilinear ? THREE.LinearFilter : THREE.LinearFilter, PoiRenderBufferBatch.trilinear ? THREE.LinearMipMapLinearFilter : THREE.LinearFilter, THREE.RGBAFormat);
        if (PoiRenderBufferBatch.trilinear && this.imageItem.mipMaps) {
            // Generate mipmaps for distance scaling of icon
            texture.mipmaps = this.imageItem.mipMaps;
            texture.image = texture.mipmaps[0];
        }
        texture.flipY = false;
        texture.premultiplyAlpha = premultipliedAlpha;
        texture.needsUpdate = true;
        this.m_material = new harp_materials_1.IconMaterial({
            rendererCapabilities: this.mapView.renderer.capabilities,
            map: texture
        });
        this.boxBuffer = new BoxBuffer_1.BoxBuffer(this.m_material, this.renderOrder);
        const mesh = this.boxBuffer.mesh;
        mesh.frustumCulled = false;
        this.scene.add(mesh);
        this.mapView.update();
    }
}
// Enable trilinear filtering to reduce flickering due to distance scaling
PoiRenderBufferBatch.trilinear = true;
/**
 * Contains all [[PoiRenderBufferBatch]]es. Selects (and initializes) the correct batch for a POI.
 */
class PoiRenderBuffer {
    /**
     * Create the `PoiRenderBuffer`.
     *
     * @param mapView - The {@link MapView} to be rendered to.
     * @param textCanvas - The [[TextCanvas]] to which scenes this `PoiRenderBuffer`
     *                     adds geometry to.
     * The actual scene a {@link TextElement} is added to is specified by the renderOrder of the
     * {@link TextElement}.
     */
    constructor(mapView, textCanvas) {
        this.mapView = mapView;
        this.textCanvas = textCanvas;
        this.batches = [];
        this.m_batchMap = new Map();
    }
    /**
     * Register the POI and prepare the [[PoiRenderBufferBatch]] for the POI at first usage.
     *
     * @param poiInfo - Describes the POI icon.
     */
    registerPoi(poiInfo) {
        const { imageItem, imageTexture, imageTextureName } = poiInfo;
        if (imageItem === undefined ||
            imageTextureName === undefined ||
            imageTexture === undefined) {
            // No image -> invisible -> ignore
            return INVALID_RENDER_BATCH;
        }
        const renderOrder = poiInfo.renderOrder;
        // There is a batch for every ImageDefinition, which could be a texture atlas with many
        // ImageTextures in it.
        const batchKey = imageTexture.image;
        let batchSet = this.m_batchMap.get(batchKey);
        let mappedIndex;
        if (batchSet === undefined) {
            batchSet = new Map();
            this.m_batchMap.set(batchKey, batchSet);
        }
        mappedIndex = batchSet.get(renderOrder);
        if (mappedIndex !== undefined) {
            return mappedIndex;
        }
        mappedIndex = this.batches.length;
        let layer = this.textCanvas.getLayer(renderOrder);
        if (layer === undefined) {
            this.textCanvas.addText("", tempPos, { layer: renderOrder });
            layer = this.textCanvas.getLayer(renderOrder);
        }
        const bufferBatch = new PoiRenderBufferBatch(this.mapView, layer.storage.scene, imageItem, renderOrder);
        bufferBatch.init();
        batchSet.set(renderOrder, mappedIndex);
        this.batches.push(bufferBatch);
        return mappedIndex;
    }
    /**
     * Render a POI image at the specified location.
     *
     * @param poiInfo - PoiInfo containing information for rendering the POI icon.
     * @param screenBox - Box to render icon into in 2D coordinates.
     * @param viewDistance - Box's distance to camera.
     * @param opacity - Opacity of icon to allow fade in/out.
     */
    addPoi(poiInfo, screenBox, viewDistance, opacity) {
        const poiRegistered = poiInfo.poiRenderBatch !== undefined && poiInfo.poiRenderBatch !== INVALID_RENDER_BATCH;
        const batchIndex = poiRegistered ? poiInfo.poiRenderBatch : this.registerPoi(poiInfo);
        if (batchIndex === INVALID_RENDER_BATCH) {
            return INVALID_RENDER_BATCH;
        }
        harp_utils_1.assert(batchIndex >= 0);
        harp_utils_1.assert(batchIndex < this.batches.length);
        harp_utils_1.assert(poiInfo.uvBox !== undefined);
        if (this.batches[batchIndex].boxBuffer === undefined) {
            this.batches[batchIndex].init();
        }
        let color;
        if (poiInfo.iconBrightness !== undefined) {
            color = tmpIconColor.setScalar(poiInfo.iconBrightness);
            if (poiInfo.iconColor !== undefined) {
                color = tmpIconColor.multiply(poiInfo.iconColor);
            }
        }
        else if (poiInfo.iconColor !== undefined) {
            color = poiInfo.iconColor;
        }
        else {
            color = neutralColor;
        }
        this.batches[batchIndex].boxBuffer.addBox(screenBox, poiInfo.uvBox, color, opacity, viewDistance, poiInfo.textElement);
        return batchIndex;
    }
    /**
     * Retrieve the [[PoiRenderBufferBatch]] from the array at the specified index. May be invalid
     * if the imageTexture could not be found
     *
     * @param index - Index into batch array.
     */
    getBatch(index) {
        if (index >= 0) {
            harp_utils_1.assert(index < this.batches.length);
            return this.batches[index];
        }
        // may be invalid if the imageTexture could not be found
        return undefined;
    }
    /**
     * Reset all batches, removing all content from the [[PoiRenderBufferBatch]]es. Called at the
     * beginning of a frame before the POIs are placed.
     */
    reset() {
        for (const batch of this.batches) {
            batch.reset();
        }
    }
    /**
     * Update the geometry of all [[PoiRenderBufferBatch]]es. Called before rendering.
     */
    update() {
        for (const batch of this.batches) {
            batch.update();
        }
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * {@link PoiInfo}s are found, the order of the results is unspecified.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickCallback - Callback to be called for every picked element.
     */
    pickTextElements(screenPosition, pickCallback) {
        for (const batch of this.batches) {
            if (batch.boxBuffer === undefined) {
                batch.init();
            }
            batch.boxBuffer.pickBoxes(screenPosition, pickCallback, batch.imageItem.imageData);
        }
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `PoiRenderBuffer`.
     *
     * @param info - The info object to increment with the values from this `PoiRenderBuffer`.
     */
    updateMemoryUsage(info) {
        for (const batch of this.batches) {
            if (batch.imageItem.imageData !== undefined) {
                const imageBytes = batch.imageItem.imageData.width * batch.imageItem.imageData.height * 4;
                info.heapSize += imageBytes;
                info.gpuSize += imageBytes;
            }
            if (batch.boxBuffer !== undefined) {
                batch.boxBuffer.updateMemoryUsage(info);
            }
        }
    }
}
/**
 * Manage POI rendering. Uses a [[PoiRenderBuffer]] to actually create the geometry that is being
 * rendered.
 */
class PoiRenderer {
    /**
     * Create the `PoiRenderer` for the specified {@link MapView}.
     *
     * @param mapView - The MapView to be rendered to.
     * @param textCanvas - The [[TextCanvas]] this `PoiRenderer` is associated to. POIs are added to
     * the different layers of this [[TextCanvas]] based on renderOrder.
     */
    constructor(mapView, textCanvas) {
        this.mapView = mapView;
        this.textCanvas = textCanvas;
        // temporary variable to save allocations
        this.m_tempScreenBox = new harp_utils_1.Math2D.Box();
        this.m_renderBuffer = new PoiRenderBuffer(mapView, textCanvas);
    }
    /**
     * Compute screen box for icon. It is required that `prepareRender` has been successfully called
     * before `computeScreenBox` may be called.
     *
     * @param poiInfo - PoiInfo containing information for rendering the POI icon.
     * @param screenPosition - Position on screen (2D).
     * @param scale - Scale to apply to icon.
     * @param env - Current zoom level.
     * @param screenBox - Box that will be used to store the result.
     * @returns The computed screen box for the icon.
     */
    static computeIconScreenBox(poiInfo, screenPosition, scale, env, 
    /* out */ screenBox = new harp_utils_1.Math2D.Box()) {
        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
        harp_utils_1.assert(poiInfo.poiRenderBatch !== INVALID_RENDER_BATCH);
        const width = poiInfo.computedWidth * scale;
        const height = poiInfo.computedHeight * scale;
        const technique = poiInfo.technique;
        const iconXOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconXOffset, env);
        const iconYOffset = harp_datasource_protocol_1.getPropertyValue(technique.iconYOffset, env);
        const centerX = screenPosition.x + (typeof iconXOffset === "number" ? iconXOffset : 0) * scale;
        const centerY = screenPosition.y + (typeof iconYOffset === "number" ? iconYOffset : 0) * scale;
        screenBox.x = centerX - width / 2;
        screenBox.y = centerY - height / 2;
        screenBox.w = width;
        screenBox.h = height;
        return screenBox;
    }
    /**
     * Prepare the POI for rendering, and determine which `poiRenderBatch` should be used. If a
     * `poiRenderBatch` is assigned, the POI is ready to be rendered.
     *
     * @param pointLabel - TextElement with PoiInfo for rendering the POI icon.
     * @param env - TODO! The current zoomLevel level of {@link MapView}
     *
     * @returns `True` if the space is not already allocated by another object (text label or POI)
     */
    prepareRender(pointLabel, env) {
        const poiInfo = pointLabel.poiInfo;
        if (poiInfo === undefined) {
            return false;
        }
        if (poiInfo.poiRenderBatch === undefined) {
            this.preparePoi(pointLabel, env);
        }
        return poiInfo.poiRenderBatch !== undefined;
    }
    /**
     * Reset all batches, removing all content from the [[PoiRenderBuffer]]es. Called at the
     * beginning of a frame before the POIs are placed.
     */
    reset() {
        this.m_renderBuffer.reset();
    }
    /**
     * Render the icon. Icon will only be rendered if opacity > 0, otherwise only its space will be
     * allocated.
     *
     * @param poiInfo - PoiInfo containing information for rendering the POI icon.
     * @param screenPosition - Position on screen (2D):
     * @param screenCollisions - Object handling the collision checks for screen-aligned 2D boxes.
     * @param viewDistance - Box's distance to camera.
     * @param scale - Scaling factor to apply to text and icon.
     * @param allocateScreenSpace - If `true` screen space will be allocated for the icon.
     * @param opacity - Opacity of icon to allow fade in/out.
     * @returns - `true` if icon has been actually rendered, `false` otherwise.
     */
    renderPoi(poiInfo, screenPosition, screenCollisions, viewDistance, scale, allocateScreenSpace, opacity, env) {
        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
        PoiRenderer.computeIconScreenBox(poiInfo, screenPosition, scale, env, this.m_tempScreenBox);
        if (allocateScreenSpace) {
            screenCollisions.allocate(this.m_tempScreenBox);
        }
        if (opacity > 0) {
            this.m_renderBuffer.addPoi(poiInfo, this.m_tempScreenBox, viewDistance, opacity);
            return true;
        }
        return false;
    }
    /**
     * Update the geometry of all [[PoiRenderBuffer]]es. Called before rendering.
     */
    update() {
        this.m_renderBuffer.update();
    }
    /**
     * Fill the picking results for the pixel with the given screen coordinate. If multiple
     * {@link PoiInfo}s are found, the order of the results is unspecified.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickCallback - Callback to be called for every picked element.
     */
    pickTextElements(screenPosition, pickCallback) {
        this.m_renderBuffer.pickTextElements(screenPosition, pickCallback);
    }
    /**
     * Update the info with the memory footprint caused by objects owned by the `PoiRenderer`.
     *
     * @param info - The info object to increment with the values from this `PoiRenderer`.
     */
    getMemoryUsage(info) {
        this.m_renderBuffer.updateMemoryUsage(info);
    }
    /**
     * Register the POI at the [[PoiRenderBuffer]] which may require some setup, for example loading
     * of the actual image.
     */
    preparePoi(pointLabel, env) {
        const poiInfo = pointLabel.poiInfo;
        if (poiInfo === undefined || !pointLabel.visible) {
            return;
        }
        if (poiInfo.poiRenderBatch !== undefined || poiInfo.isValid === false) {
            // Already set up, nothing to be done here.
            return;
        }
        if (poiInfo.poiTableName !== undefined) {
            if (this.mapView.poiManager.updatePoiFromPoiTable(pointLabel)) {
                if (!pointLabel.visible) {
                    // PoiTable set this POI to not visible.
                    return;
                }
            }
            else {
                // PoiTable has not been loaded, but is required to determine visibility.
                return;
            }
        }
        const imageTextureName = poiInfo.imageTextureName;
        const imageTexture = this.mapView.poiManager.getImageTexture(imageTextureName);
        if (imageTexture === undefined) {
            // Warn about a missing texture, but only once.
            if (PoiRenderer.m_missingTextureName.get(imageTextureName) === undefined) {
                PoiRenderer.m_missingTextureName.set(imageTextureName, true);
                logger.error(`preparePoi: No imageTexture with name '${imageTextureName}' found`);
            }
            poiInfo.isValid = false;
            return;
        }
        const imageDefinition = imageTexture.image;
        // Check user image cache first.
        let imageItem = this.mapView.userImageCache.findImageByName(imageDefinition);
        let imageCache;
        if (imageItem === undefined) {
            // Then check default image cache.
            imageItem = this.mapView.imageCache.findImageByName(imageDefinition);
            if (imageItem === undefined) {
                logger.error(`init: No imageItem found with name '${imageDefinition}'`);
                poiInfo.isValid = false;
                return;
            }
            else {
                imageCache = this.mapView.imageCache;
            }
        }
        else {
            imageCache = this.mapView.userImageCache;
        }
        if (!imageItem.loaded) {
            if (imageItem.loadingPromise !== undefined) {
                // already being loaded, will be rendered once available
                return;
            }
            const imageUrl = imageItem.url;
            const loading = imageCache.loadImage(imageItem);
            if (loading instanceof Promise) {
                loading
                    .then(loadedImageItem => {
                    if (loadedImageItem === undefined) {
                        logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`);
                        return;
                    }
                    this.setupPoiInfo(poiInfo, imageTexture, loadedImageItem, env);
                })
                    .catch(error => {
                    logger.error(`preparePoi: Failed to load imageItem: '${imageUrl}`, error);
                    poiInfo.isValid = false;
                });
                return;
            }
            else {
                imageItem = loading;
            }
        }
        this.setupPoiInfo(poiInfo, imageTexture, imageItem, env);
    }
    /**
     * Setup texture and material for the batch.
     *
     * @param poiInfo - {@link PoiInfo} to initialize.
     * @param imageTexture - Shared {@link @here/harp-datasource-protocol#ImageTexture},
     *                       defines used area in atlas.
     * @param imageItem - Shared {@link ImageItem}, contains cached image for texture.
     * @param env - The current zoom level of {@link MapView}
     */
    setupPoiInfo(poiInfo, imageTexture, imageItem, env) {
        harp_utils_1.assert(poiInfo.uvBox === undefined);
        if (imageItem === undefined || imageItem.imageData === undefined) {
            logger.error("setupPoiInfo: No imageItem/imageData found");
            // invalid render batch number
            poiInfo.poiRenderBatch = INVALID_RENDER_BATCH;
            poiInfo.isValid = false;
            return;
        }
        const technique = poiInfo.technique;
        const imageWidth = imageItem.imageData.width;
        const imageHeight = imageItem.imageData.height;
        const paddedSize = MipMapGenerator_1.MipMapGenerator.getPaddedSize(imageWidth, imageHeight);
        const trilinearFiltering = PoiRenderBufferBatch.trilinear && imageItem.mipMaps;
        const paddedImageWidth = trilinearFiltering ? paddedSize.width : imageWidth;
        const paddedImageHeight = trilinearFiltering ? paddedSize.height : imageHeight;
        const iconWidth = imageTexture.width !== undefined ? imageTexture.width : imageWidth;
        const iconHeight = imageTexture.height !== undefined ? imageTexture.height : imageHeight;
        let minS = 0;
        let maxS = 1;
        let minT = 0;
        let maxT = 1;
        let iconScaleH = technique.iconScale !== undefined ? technique.iconScale : 1;
        let iconScaleV = technique.iconScale !== undefined ? technique.iconScale : 1;
        const width = imageTexture.width !== undefined ? imageTexture.width : imageWidth;
        const height = imageTexture.height !== undefined ? imageTexture.height : imageHeight;
        const xOffset = imageTexture.xOffset !== undefined ? imageTexture.xOffset : 0;
        const yOffset = imageTexture.yOffset !== undefined ? imageTexture.yOffset : 0;
        minS = xOffset / paddedImageWidth;
        maxS = (xOffset + width) / paddedImageWidth;
        const flipY = false;
        if (flipY) {
            minT = (imageHeight - yOffset) / paddedImageHeight;
            maxT = (imageHeight - yOffset - height) / paddedImageHeight;
        }
        else {
            minT = yOffset / paddedImageHeight;
            maxT = (yOffset + height) / paddedImageHeight;
        }
        // minS += 0.5 / imageWidth;
        // maxS += 0.5 / imageWidth;
        // minT += 0.5 / imageHeight;
        // maxT += 0.5 / imageHeight;
        // By default, iconScaleV should be equal to iconScaleH, whatever is set in the style.
        const screenWidth = harp_datasource_protocol_1.getPropertyValue(technique.screenWidth, env);
        if (screenWidth !== undefined && screenWidth !== null) {
            iconScaleV = iconScaleH = screenWidth / iconWidth;
        }
        const screenHeight = harp_datasource_protocol_1.getPropertyValue(technique.screenHeight, env);
        if (screenHeight !== undefined && screenHeight !== null) {
            iconScaleV = screenHeight / iconHeight;
            if (screenWidth !== undefined) {
                iconScaleH = iconScaleV;
            }
        }
        // compute stored values in imageTexture
        poiInfo.computedWidth = iconWidth * iconScaleH;
        poiInfo.computedHeight = iconHeight * iconScaleV;
        poiInfo.uvBox = {
            s0: minS,
            t0: maxT,
            s1: maxS,
            t1: minT
        };
        poiInfo.imageItem = imageItem;
        poiInfo.imageTexture = imageTexture;
        poiInfo.poiRenderBatch = this.m_renderBuffer.registerPoi(poiInfo);
        poiInfo.isValid = true;
        harp_utils_1.assert(poiInfo.poiRenderBatch !== undefined);
    }
}
exports.PoiRenderer = PoiRenderer;
// keep track of the missing textures, but only warn once
PoiRenderer.m_missingTextureName = new Map();
//# sourceMappingURL=PoiRenderer.js.map