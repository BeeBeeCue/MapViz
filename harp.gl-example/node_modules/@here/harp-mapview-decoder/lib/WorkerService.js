"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.WorkerService = void 0;
const harp_datasource_protocol_1 = require("@here/harp-datasource-protocol");
const harp_utils_1 = require("@here/harp-utils");
const logger = harp_utils_1.LoggerManager.instance.create("WorkerService", { enabled: true });
/**
 * Worker Service communication helper.
 *
 * @remarks
 * Listens to Web Worker messages from `entWorkerSet` and implements:
 *  - worker service initialization
 *  - request/response scheme
 *  - error handling.
 *
 * This class should be subclassed to provide concrete like `TileDecoderService`.
 *
 * Communication peer for `ConcurrentWorkerSet`.
 */
class WorkerService {
    /**
     * Sets up the `WorkerService` with the specified name, and starts processing messages.
     *
     * @param serviceId - The service id.
     */
    constructor(serviceId) {
        this.serviceId = serviceId;
        this.m_pendingRequests = new Map();
        /**
         * Central message handler for this service.
         *
         * Responsible for filtering message target and managing request/response sequence.
         *
         * @param message - Message to be dispatched.
         */
        this.onMessage = (message) => {
            if (typeof message.data.service !== "string" || message.data.service !== this.serviceId) {
                return;
            }
            try {
                if (harp_datasource_protocol_1.WorkerServiceProtocol.isRequestMessage(message.data)) {
                    const request = message.data;
                    const requestEntry = {
                        service: request.service,
                        messageId: request.messageId,
                        responseSent: false
                    };
                    this.m_pendingRequests.set(request.messageId, requestEntry);
                    this.tryHandleRequest(request.request)
                        .then(response => {
                        this.doSendResponse(requestEntry, {
                            service: this.serviceId,
                            type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Response,
                            messageId: request.messageId,
                            response: response.response
                        }, response.transferList);
                    })
                        .catch(error => {
                        this.doSendResponse(requestEntry, {
                            service: this.serviceId,
                            type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Response,
                            messageId: request.messageId,
                            errorMessage: error.toString(),
                            errorStack: error.stack
                        });
                    });
                }
                else {
                    this.tryHandleMessage(message.data);
                }
            }
            catch (err) {
                logger.error(`[${this.serviceId}]: Unhandled exception when handling ${message.type}`);
            }
        };
        self.addEventListener("message", this.onMessage);
        const isInitializedMessage = {
            service: serviceId,
            type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Initialized
        };
        self.postMessage(isInitializedMessage);
    }
    /**
     * Destroy the `WorkerService`. Cancels all pending requests ad removes itself from the message
     * queue.
     */
    destroy() {
        this.cancelAllPendingRequests();
        self.removeEventListener("message", this.onMessage);
    }
    /**
     * Message handler to be overridden by implementation.
     *
     * @param message - `MessageEvent.data` as received by `WorkerService`.
     */
    handleMessage(message) {
        logger.error(`[${this.serviceId}]: Invalid message ${message.type}`);
    }
    /**
     * Call request handler to be overridden by implementation.
     *
     * @param request - `RequestMessage.request` as received by `WorkerService`.
     */
    handleRequest(request) {
        throw new Error(`ServiceAdapter[${this.serviceId}]: Invalid request '${request.type}'`);
    }
    /**
     * Safety belt over `handleMessage` for correct exception handling & logging.
     */
    tryHandleMessage(message) {
        try {
            this.handleMessage(message);
        }
        catch (error) {
            logger.error(`[${this.serviceId}]: Failed, handling message ${message.type}`);
        }
    }
    /**
     * Safety belt over `handleRequest` for correct exception handling in promise chain.
     */
    tryHandleRequest(request) {
        try {
            return this.handleRequest(request);
        }
        catch (error) {
            // we don't log exceptions here as they are propagated to client as responses
            logger.error(`[${this.serviceId}]: Failure`, error);
            return Promise.reject(error);
        }
    }
    doSendResponse(requestEntry, response, transferList) {
        if (requestEntry.responseSent) {
            return;
        }
        if (transferList !== undefined) {
            self.postMessage(response, transferList);
        }
        else {
            self.postMessage(response);
        }
        requestEntry.responseSent = true;
        this.m_pendingRequests.delete(requestEntry.messageId);
    }
    cancelAllPendingRequests() {
        this.m_pendingRequests.forEach(requestEntry => {
            this.doSendResponse(requestEntry, {
                service: this.serviceId,
                type: harp_datasource_protocol_1.WorkerServiceProtocol.ServiceMessageName.Response,
                messageId: requestEntry.messageId,
                errorMessage: "cancelled"
            });
        });
    }
}
exports.WorkerService = WorkerService;
//# sourceMappingURL=WorkerService.js.map