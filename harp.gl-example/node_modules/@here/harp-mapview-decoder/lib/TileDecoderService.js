"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileDecoderService = void 0;
const harp_datasource_protocol_1 = require("@here/harp-datasource-protocol");
const harp_geoutils_1 = require("@here/harp-geoutils");
const harp_utils_1 = require("@here/harp-utils");
const WorkerService_1 = require("./WorkerService");
const logger = harp_utils_1.LoggerManager.instance.create("TileDecoderService");
/**
 * An extension to [[WorkerService]], the `TileDecoderService` implements an asynchronous
 * (message based) service to decode tile content in web workers. The `TileDecoderService` itself
 * lives in the web worker, and communicates with messages by means of a [[ConcurrentWorkerSet]]
 * with the application.
 *
 * The `TileDecoderService` handles a [[DecodeTileRequest]], which contains a tile and its freshly
 * loaded binary data, decodes the content with the [[ITileDecoder]] that the service is configured
 * to use, and sends the data back in form of a [[WorkerServiceResponse]].
 */
class TileDecoderService extends WorkerService_1.WorkerService {
    /**
     * Set up the `TileDecoderService`. The name of the service must be unique
     *
     * @param serviceId - Service id. Must be unique.
     * @param m_decoder - Decoder to handle the decoding and info requests.
     */
    constructor(serviceId, m_decoder) {
        super(serviceId);
        this.serviceId = serviceId;
        this.m_decoder = m_decoder;
        this.m_decoder.connect();
    }
    /**
     * Start a [[TileDecoderService]] with a given decoder.
     *
     * @param serviceId - Service id. Must be unique.
     * @param decoder -   [[TileDecoder]] instance.
     */
    static start(serviceId, decoder) {
        return new TileDecoderService(serviceId, decoder);
    }
    /**
     * Handle incoming request messages. Identifies message type and processes the request.
     *
     * @param request - Message that is either a DecodeTileRequest or a TileInfoRequest.
     * @returns A promise which resolves to a [[WorkerServiceResponse]].
     * @override
     */
    handleRequest(request) {
        if (harp_datasource_protocol_1.WorkerDecoderProtocol.isDecodeTileRequest(request)) {
            return this.handleDecodeTileRequest(request);
        }
        else if (harp_datasource_protocol_1.WorkerDecoderProtocol.isTileInfoRequest(request)) {
            return this.handleTileInfoRequest(request);
        }
        else {
            return super.handleRequest(request);
        }
    }
    /**
     * Handle incoming configuration message. Configuration message is passed on to decoder.
     *
     * @param request - Message of type [[ConfigurationMessage]].
     * @override
     */
    handleMessage(message) {
        if (harp_datasource_protocol_1.WorkerDecoderProtocol.isConfigurationMessage(message)) {
            this.handleConfigurationMessage(message);
        }
        else {
            logger.error(`[${this.serviceId}]: invalid message ${message.type}`);
        }
    }
    async handleDecodeTileRequest(request) {
        const tileKey = harp_geoutils_1.TileKey.fromMortonCode(request.tileKey);
        const projection = harp_datasource_protocol_1.getProjection(request.projection);
        const decodedTile = await this.m_decoder.decodeTile(request.data, tileKey, projection);
        const transferList = [];
        const transferBufferAttribute = (attribute) => {
            if (attribute !== undefined &&
                attribute.buffer.byteLength > 0 &&
                !transferList.includes(attribute.buffer)) {
                transferList.push(attribute.buffer);
            }
        };
        decodedTile.geometries.forEach(geom => {
            var _a, _b, _c;
            (_a = geom.vertexAttributes) === null || _a === void 0 ? void 0 : _a.forEach(attr => transferBufferAttribute(attr));
            (_b = geom.interleavedVertexAttributes) === null || _b === void 0 ? void 0 : _b.forEach(attr => transferBufferAttribute(attr));
            transferBufferAttribute(geom.index);
            transferBufferAttribute(geom.edgeIndex);
            if (Array.isArray(geom.objInfos) &&
                geom.objInfos.length === 1 &&
                typeof geom.objInfos[0] === "object" && ((_c = geom.objInfos[0]) === null || _c === void 0 ? void 0 : _c.hasOwnProperty("displacementMap"))) {
                const obj = geom.objInfos[0];
                transferBufferAttribute(obj.displacementMap);
            }
            if (Array.isArray(geom.attachments)) {
                geom.attachments.forEach(attachment => {
                    transferBufferAttribute(attachment.index);
                    transferBufferAttribute(attachment.edgeIndex);
                });
            }
        });
        decodedTile.techniques.forEach(technique => {
            harp_datasource_protocol_1.addBuffersToTransferList(technique, transferList);
        });
        return {
            response: decodedTile,
            transferList
        };
    }
    handleTileInfoRequest(request) {
        const tileKey = harp_geoutils_1.TileKey.fromMortonCode(request.tileKey);
        const projection = harp_datasource_protocol_1.getProjection(request.projection);
        return this.m_decoder.getTileInfo(request.data, tileKey, projection).then(tileInfo => {
            const transferList = tileInfo !== undefined && tileInfo.transferList !== undefined
                ? tileInfo.transferList
                : [];
            return {
                response: tileInfo,
                transferList
            };
        });
    }
    handleConfigurationMessage(message) {
        this.m_decoder.configure(message, message.options);
    }
}
exports.TileDecoderService = TileDecoderService;
//# sourceMappingURL=TileDecoderService.js.map