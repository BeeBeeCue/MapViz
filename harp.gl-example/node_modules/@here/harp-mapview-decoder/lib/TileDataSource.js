"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TileDataSource = exports.TileFactory = void 0;
const harp_mapview_1 = require("@here/harp-mapview");
const harp_utils_1 = require("@here/harp-utils");
const TileLoader_1 = require("./TileLoader");
/**
 * Templated factory class to create instances of [[Tile]].
 */
class TileFactory {
    /**
     * Initialize the factory using the constructor of the element to be called when a [[Tile]] is
     * created.
     *
     * @param m_modelConstructor - Constructor of (subclass of) [[Tile]].
     */
    constructor(m_modelConstructor) {
        this.m_modelConstructor = m_modelConstructor;
    }
    /**
     * Create an instance of (subclass of) [[Tile]]. The required parameters are passed as arguments
     * to the constructor of [[Tile]].
     *
     * @param dataSource - [[Datasource]] this class belongs to.
     * @param tileKey - Quadtree address of the [[Tile]].
     */
    create(dataSource, tileKey) {
        const tile = new this.m_modelConstructor(dataSource, tileKey);
        tile.tileLoader = new TileLoader_1.TileLoader(dataSource, tileKey, dataSource.dataProvider(), dataSource.decoder);
        return tile;
    }
}
exports.TileFactory = TileFactory;
/**
 * Common base class for the typical [[DataSource]] which uses an [[ITileDecoder]] to decode the
 * tile content asynchronously. The decoder can be passed in as an option, or a default
 * asynchronous one is generated.
 */
class TileDataSource extends harp_mapview_1.DataSource {
    /**
     * Set up the `TileDataSource`.
     *
     * @param m_tileFactory - Factory to create the [[Tile]] instances.
     * @param m_options - Options specifying the parameters of the [[DataSource]].
     */
    constructor(m_tileFactory, m_options) {
        var _a, _b;
        super({
            name: m_options.name,
            styleSetName: m_options.styleSetName,
            minZoomLevel: m_options.minZoomLevel,
            maxZoomLevel: m_options.maxZoomLevel,
            minDataLevel: m_options.minDataLevel,
            maxDataLevel: m_options.maxDataLevel,
            minDisplayLevel: m_options.minDisplayLevel,
            maxDisplayLevel: m_options.maxDisplayLevel,
            storageLevelOffset: m_options.storageLevelOffset,
            allowOverlappingTiles: m_options.allowOverlappingTiles,
            minGeometryHeight: m_options.minGeometryHeight,
            maxGeometryHeight: m_options.maxGeometryHeight
        });
        this.m_tileFactory = m_tileFactory;
        this.m_options = m_options;
        this.logger = harp_utils_1.LoggerManager.instance.create("TileDataSource");
        this.m_isReady = false;
        if (m_options.decoder) {
            this.m_decoder = m_options.decoder;
        }
        else if (m_options.concurrentDecoderServiceName) {
            this.m_decoder = harp_mapview_1.ConcurrentDecoderFacade.getTileDecoder(m_options.concurrentDecoderServiceName, m_options.concurrentDecoderScriptUrl, m_options.concurrentDecoderWorkerCount);
        }
        else {
            throw new Error(`TileDataSource[${this.name}]: unable to create, missing decoder or ` +
                `concurrentDecoderServiceName`);
        }
        this.useGeometryLoader = true;
        this.cacheable = true;
        this.m_unregisterClearTileCache = (_b = (_a = this.dataProvider()).onDidInvalidate) === null || _b === void 0 ? void 0 : _b.call(_a, () => this.mapView.clearTileCache(this.name));
    }
    /** @override */
    dispose() {
        var _a;
        (_a = this.m_unregisterClearTileCache) === null || _a === void 0 ? void 0 : _a.call(this);
        this.decoder.dispose();
        this.dataProvider().unregister(this);
    }
    /** @override */
    ready() {
        return this.m_isReady && this.m_options.dataProvider.ready();
    }
    /**
     * Get the [[ITileDecoder]] of this `ITileDataSource`, which has either been passed in with
     * the options, or has been supplied by the [[ConcurrentDecoderFacade]].
     */
    get decoder() {
        return this.m_decoder;
    }
    /** @override */
    async connect() {
        await Promise.all([this.m_options.dataProvider.register(this), this.m_decoder.connect()]);
        this.m_isReady = true;
        this.m_decoder.configure(undefined, {
            storageLevelOffset: this.m_options.storageLevelOffset
        });
    }
    /** @override */
    setStyleSet(options, definitions, languages) {
        if (!(options === null || options === void 0 ? void 0 : options.hasOwnProperty("styleSet"))) {
            this.m_decoder.configure({
                styleSet: options,
                definitions,
                languages
            });
        }
        else {
            this.m_decoder.configure(options);
        }
        this.mapView.clearTileCache(this.name);
    }
    /**
     * Apply the [[Theme]] to this data source.
     *
     * Applies new [[StyleSet]] and definitions from theme only if matching styleset (see
     * `styleSetName` property) is found in `theme`.
     * @override
     */
    setTheme(theme, languages) {
        const styleSet = this.styleSetName !== undefined && theme.styles
            ? theme.styles[this.styleSetName]
            : undefined;
        if (styleSet !== undefined) {
            this.setStyleSet({
                styleSet,
                definitions: theme.definitions,
                priorities: theme.priorities,
                labelPriorities: theme.labelPriorities,
                languages
            });
        }
    }
    /**
     * Get the [[DataProvider]] that has been passed in with the options.
     */
    dataProvider() {
        return this.m_options.dataProvider;
    }
    /** @override */
    getTilingScheme() {
        return this.m_options.tilingScheme;
    }
    /**
     * Create a [[Tile]] and start the asynchronous download of the tile content. The [[Tile]] will
     * be empty, but the download and decoding will be scheduled immediately. [[Tile]] instance is
     * initialized with default copyrights, concatenated with copyrights from copyright provider of
     * this data source.
     *
     * @param tileKey - Quadtree address of the requested tile.
     * @param delayLoad - If true, the Tile will be created, but Tile.load will not be called.
     * @default false.
     * @override
     */
    getTile(tileKey, delayLoad = false) {
        const tile = this.m_tileFactory.create(this, tileKey);
        tile.copyrightInfo = this.m_options.copyrightInfo;
        if (this.m_options.copyrightProvider !== undefined) {
            this.m_options.copyrightProvider
                .getCopyrights(tile.geoBox, tileKey.level)
                .then(copyrightInfo => {
                tile.copyrightInfo =
                    tile.copyrightInfo === undefined
                        ? copyrightInfo
                        : [...tile.copyrightInfo, ...copyrightInfo];
                this.requestUpdate();
            });
        }
        if (!delayLoad) {
            tile.load();
        }
        return tile;
    }
    /**
     * Get [[TileInfo]] of a tile.
     *
     * @param tileKey - Quadtree address of the requested tile.
     * @returns A promise which will contain the [[TileInfo]] when resolved.
     */
    getTileInfo(tileKey) {
        const promise = new Promise((resolve, reject) => {
            const tileLoader = new TileLoader_1.TileInfoLoader(this, tileKey, this.m_options.dataProvider, this.decoder);
            tileLoader.loadAndDecode().then(loaderState => {
                if (loaderState === harp_mapview_1.TileLoaderState.Ready) {
                    resolve(tileLoader.tileInfo);
                }
                else {
                    reject(new Error(`TileDataSource#getInfoTile wrong final state: ${loaderState}`));
                }
            });
        });
        return promise;
    }
}
exports.TileDataSource = TileDataSource;
//# sourceMappingURL=TileDataSource.js.map