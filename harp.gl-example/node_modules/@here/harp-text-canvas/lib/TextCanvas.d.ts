import * as THREE from "three";
import { FontCatalog } from "./rendering/FontCatalog";
import { GlyphData } from "./rendering/GlyphData";
import { TextBufferObject } from "./rendering/TextBufferObject";
import { TextGeometry } from "./rendering/TextGeometry";
import { TextLayoutStyle, TextRenderStyle } from "./rendering/TextStyle";
/**
 * Optional parameters passed on [[TextCanvas]].`measureText` function call.
 */
export interface MeasurementParameters {
    /**
     * Path where text should be placed on. Overrides the original position parameter.
     */
    path?: THREE.Path | THREE.CurvePath<THREE.Vector2>;
    /**
     * If `true`, text on a path will be placed even when its size its bigger than the path's size.
     */
    pathOverflow?: boolean;
    /**
     * Output per-character bounds.
     */
    outputCharacterBounds?: THREE.Box2[];
    /**
     * Array containing info on whether the glyphs are upper or lower case. Needed to support
     * `SmallCaps`.
     */
    letterCaseArray?: boolean[];
}
/**
 * Optional parameters passed on [[TextCanvas]].`addText` function call.
 */
export interface AdditionParameters {
    /**
     * Path where text should be placed on. Overrides the original position parameter.
     */
    path?: THREE.Path | THREE.CurvePath<THREE.Vector2>;
    /**
     * If `true`, text on a path will be placed even when its size its bigger than the path's size.
     */
    pathOverflow?: boolean;
    /**
     * Layer where text will be added.
     */
    layer?: number;
    /**
     * If `true`, the input position parameter will be updated to contain the position of the last
     * glyph added.
     */
    updatePosition?: boolean;
    /**
     * Object containing additional data intended to be retrieved during picking.
     */
    pickingData?: any;
    /**
     * Array containing info on whether the glyphs are upper or lower case. Needed to support
     * `SmallCaps`.
     */
    letterCaseArray?: boolean[];
}
/**
 * Optional parameters passed on [[TextCanvas]].`createTextBufferObject` function call.
 */
export interface TextBufferCreationParameters {
    /**
     * Path where text should be placed on. Overrides the original position parameter.
     */
    path?: THREE.Path | THREE.CurvePath<THREE.Vector2>;
    /**
     * If `true`, text on a path will be placed even when its size its bigger than the path's size.
     */
    pathOverflow?: boolean;
    /**
     * Output text bounding-box.
     */
    outputBounds?: boolean;
    /**
     * Output per-character bounds.
     */
    outputCharacterBounds?: boolean;
    /**
     * Array containing info on whether the glyphs are upper or lower case. Needed to support
     * `SmallCaps`.
     */
    letterCaseArray?: boolean[];
    /**
     * If `true`, both the [[TextRenderStyle]] and [[TextLayoutStyle]] used to generate the
     * [[TextBufferObject]] will be stored in it.
     */
    storeStyles?: boolean;
}
/**
 * Optional parameters passed on [[TextCanvas]].`addTextBufferObject` function call.
 */
export interface TextBufferAdditionParameters {
    layer?: number;
    position?: THREE.Vector3;
    scale?: number;
    rotation?: number;
    color?: THREE.Color;
    opacity?: number;
    backgroundColor?: THREE.Color;
    backgroundOpacity?: number;
    pickingData?: any;
}
/**
 * Default's [[TextCanvas]] layer identifier.
 */
export declare const DEFAULT_TEXT_CANVAS_LAYER = 0;
/**
 * [[TextCanvas]] rendering layer.
 */
export interface TextCanvasLayer {
    id: number;
    storage: TextGeometry;
}
/**
 * [[TextCanvas]] construction parameters.
 */
export interface TextCanvasParameters {
    /**
     * WebGLRenderer internally used by this `TextCanvas`.
     */
    renderer: THREE.WebGLRenderer;
    /**
     * Initial [[FontCatalog]].
     */
    fontCatalog: FontCatalog;
    /**
     * Minimum amount of glyphs each [[TextCanvas]] layer can store.
     */
    minGlyphCount: number;
    /**
     * Maximum amount of glyphs each [[TextCanvas]] layer can store.
     */
    maxGlyphCount: number;
    /**
     * Material used to render text.
     */
    material?: THREE.Material;
    /**
     * Material used to render text background.
     */
    backgroundMaterial?: THREE.Material;
}
/**
 * Describes estimated usage of memory on heap and GPU.
 */
export interface MemoryUsage {
    heapSize: number;
    gpuSize: number;
}
/**
 * three.js text rendering engine which can manage and render high-quality, transformable, stylable
 * and properly layout SDF and MSDF text.
 */
export declare class TextCanvas {
    private static readonly defaultTextRenderStyle;
    private static readonly defaultTextLayoutStyle;
    /**
     * Minimum amount of glyphs each [[TextCanvas]] layer can store.
     */
    readonly minGlyphCount: number;
    /**
     * Maximum amount of glyphs each [[TextCanvas]] layer can store.
     */
    readonly maxGlyphCount: number;
    private readonly m_renderer;
    private m_fontCatalog;
    private readonly m_currentTextRenderStyle;
    private readonly m_currentTextLayoutStyle;
    private m_material;
    private m_bgMaterial;
    private m_ownsMaterial;
    private m_ownsBgMaterial;
    private readonly m_defaultLayer;
    private readonly m_layers;
    private readonly m_lineTypesetter;
    private readonly m_pathTypesetter;
    /**
     * Constructs a new `TextCanvas`.
     *
     * @param params - `TextCanvas` construction parameters.
     *
     * @returns New `TextCanvas`.
     */
    constructor(params: TextCanvasParameters);
    /**
     * Currently active [[FontCatalog]].
     */
    get fontCatalog(): FontCatalog;
    set fontCatalog(value: FontCatalog);
    /**
     * Currently active text rendering material.
     */
    get material(): THREE.Material;
    set material(value: THREE.Material);
    /**
     * Currently active text background rendering material.
     */
    get backgroundMaterial(): THREE.Material;
    set backgroundMaterial(value: THREE.Material);
    /**
     * Currently active text rendering style.
     */
    get textRenderStyle(): TextRenderStyle;
    set textRenderStyle(style: TextRenderStyle);
    /**
     * Currently active text layout style.
     */
    get textLayoutStyle(): TextLayoutStyle;
    set textLayoutStyle(style: TextLayoutStyle);
    /**
     * Clears all the placed glyphs in this `TextCanvas` (as well as resetting the current style).
     */
    clear(): void;
    /**
     * Renders the content of this `TextCanvas`.
     *
     * @param camera - Orthographic camera.
     * @param target - Optional render target.
     * @param clear - Optional render target clear operation.
     */
    render(camera: THREE.OrthographicCamera, target?: THREE.WebGLRenderTarget, clear?: boolean): void;
    /**
     * Creates a new `TextCanvas` rendering layer and returns. If there was already a layer for the
     * input `layerId`, it just returns this one instead.
     *
     * @param layerId - Desired layer identifier.
     *
     * @returns Created [[TextCanvasLayer]].
     */
    addLayer(layerId: number): TextCanvasLayer;
    /**
     * Retrieves a specific `TextCanvas` rendering layer.
     *
     * @param layerId - Desired layer identifier.
     *
     * @returns Selected [[TextCanvasLayer]].
     */
    getLayer(layerId: number): TextCanvasLayer | undefined;
    /**
     * Retrieves all `TextCanvas` rendering layers.
     *
     * @returns Array of [[TextCanvasLayer]]s.
     */
    getAllLayers(): TextCanvasLayer[];
    /**
     * Returns the computed bounding box for the input text. The current [[TextRenderStyle]] and
     * [[TextLayoutStyle]] will influence the results of this function.
     *
     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.
     * @param outputBounds - Output text bounding box.
     * @param params - Optional measurement parameters.
     *
     * @returns Result of the measurement. If `false`, some error occurred during execution and the
     * input text couldn't be properly measured.
     */
    measureText(text: string | GlyphData[], outputBounds: THREE.Box2, params?: MeasurementParameters): boolean;
    /**
     * Adds the input text to this `TextCanvas` in the specified screen position. The current
     * [[TextRenderStyle]] and [[TextLayoutStyle]] will influence the results of this function.
     *
     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.
     * @param position - Screen position.
     * @param params - Optional addition parameters.
     *
     * @returns Result of the addition. If `false`, some error occurred during execution and the
     * input text couldn't be properly added.
     */
    addText(text: string | GlyphData[], position: THREE.Vector3, params?: AdditionParameters): boolean;
    /**
     * Creates a new [[TextBufferObject]]. The computed text vertex buffer is equivalent to the
     * result of performing the `addText` function for the input text in the screen origin.
     *
     * @param text - Input text. Provide an array of [[GlyphData]] for better performance.
     * @param params - Optional creation parameters.
     *
     * @returns New [[TextBufferObject]] (or `undefined` if requested text glyphs couldn't be
     * retrieved from the current [[FontCatalog]]).
     */
    createTextBufferObject(text: string | GlyphData[], params?: TextBufferCreationParameters): TextBufferObject | undefined;
    /**
     * Adds a previously created [[TextBufferObject]] to the `TextCanvas`. Additional parameters can
     * be provided to override the attributes stored in the buffer.
     *
     * @param textBufferObject - [[TextBufferObject]] to add.
     * @param params - Optional addition parameters.
     *
     * @returns Result of the addition. If `false`, some error occurred during execution and the
     * input text couldn't be properly added.
     */
    addTextBufferObject(textBufferObject: TextBufferObject, params?: TextBufferAdditionParameters): boolean;
    /**
     * Executes the `pickCallback` for all previously stored picking data for text covering the
     * specified screen position.
     *
     * @param screenPosition - Screen coordinate of picking position.
     * @param pickCallback - Callback to be called for every picked element.
     */
    pickText(position: THREE.Vector2, callback: (pickData: any | undefined) => void): void;
    /**
     * Update the info with the memory footprint caused by objects owned by the `TextCanvas`.
     *
     * @param info - The info object to increment with the values from this `TextCanvas`.
     */
    getMemoryUsage(info: MemoryUsage): void;
    private placeText;
}
//# sourceMappingURL=TextCanvas.d.ts.map