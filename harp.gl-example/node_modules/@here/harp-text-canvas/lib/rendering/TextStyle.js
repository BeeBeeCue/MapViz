"use strict";
/*
 * Copyright (C) 2017-2020 HERE Europe B.V.
 * Licensed under Apache 2.0, see full license in LICENSE
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolvePlacementAndAlignment = exports.TextLayoutStyle = exports.TextRenderStyle = exports.DefaultTextStyle = exports.vPlacementFromAlignment = exports.hPlacementFromAlignment = exports.vAlignFromPlacement = exports.hAlignFromPlacement = exports.WrappingMode = exports.HorizontalPlacement = exports.VerticalPlacement = exports.HorizontalAlignment = exports.VerticalAlignment = exports.FontVariant = exports.FontStyle = exports.FontUnit = void 0;
const THREE = require("three");
/**
 * Unit of measurement used to specify a font's size.
 */
var FontUnit;
(function (FontUnit) {
    FontUnit[FontUnit["Em"] = 0] = "Em";
    FontUnit[FontUnit["Pixel"] = 1] = "Pixel";
    FontUnit[FontUnit["Point"] = 2] = "Point";
    FontUnit[FontUnit["Percent"] = 3] = "Percent";
})(FontUnit = exports.FontUnit || (exports.FontUnit = {}));
/**
 * Style to be used when rendering glyphs.
 */
var FontStyle;
(function (FontStyle) {
    FontStyle[FontStyle["Regular"] = 0] = "Regular";
    FontStyle[FontStyle["Bold"] = 1] = "Bold";
    FontStyle[FontStyle["Italic"] = 2] = "Italic";
    FontStyle[FontStyle["BoldItalic"] = 3] = "BoldItalic";
})(FontStyle = exports.FontStyle || (exports.FontStyle = {}));
/**
 * Variant to be used when rendering.
 */
var FontVariant;
(function (FontVariant) {
    FontVariant[FontVariant["Regular"] = 0] = "Regular";
    FontVariant[FontVariant["AllCaps"] = 1] = "AllCaps";
    FontVariant[FontVariant["SmallCaps"] = 2] = "SmallCaps";
})(FontVariant = exports.FontVariant || (exports.FontVariant = {}));
/**
 * Vertical alignment to be used when placing text.
 */
var VerticalAlignment;
(function (VerticalAlignment) {
    VerticalAlignment[VerticalAlignment["Above"] = 0] = "Above";
    VerticalAlignment[VerticalAlignment["Center"] = -0.5] = "Center";
    VerticalAlignment[VerticalAlignment["Below"] = -1] = "Below";
})(VerticalAlignment = exports.VerticalAlignment || (exports.VerticalAlignment = {}));
/**
 * Horizontal alignment to be used when placing text.
 */
var HorizontalAlignment;
(function (HorizontalAlignment) {
    HorizontalAlignment[HorizontalAlignment["Left"] = 0] = "Left";
    HorizontalAlignment[HorizontalAlignment["Center"] = -0.5] = "Center";
    HorizontalAlignment[HorizontalAlignment["Right"] = -1] = "Right";
})(HorizontalAlignment = exports.HorizontalAlignment || (exports.HorizontalAlignment = {}));
/**
 * Vertical position of text area relative to the placement context (point, line).
 */
var VerticalPlacement;
(function (VerticalPlacement) {
    VerticalPlacement[VerticalPlacement["Top"] = 0] = "Top";
    VerticalPlacement[VerticalPlacement["Center"] = -0.5] = "Center";
    VerticalPlacement[VerticalPlacement["Bottom"] = -1] = "Bottom";
})(VerticalPlacement = exports.VerticalPlacement || (exports.VerticalPlacement = {}));
/**
 * Horizontal position of text element relative to the placement context (point, line).
 *
 * @note [[HorizontalPlacement]] value is exactly opposite to [[HorizontalAlignment]] value,
 * cause when you place text on the right side of point (or icon) it will be left-aligned.
 */
var HorizontalPlacement;
(function (HorizontalPlacement) {
    HorizontalPlacement[HorizontalPlacement["Left"] = -1] = "Left";
    HorizontalPlacement[HorizontalPlacement["Center"] = -0.5] = "Center";
    HorizontalPlacement[HorizontalPlacement["Right"] = 0] = "Right";
})(HorizontalPlacement = exports.HorizontalPlacement || (exports.HorizontalPlacement = {}));
/**
 * Text wrapping rule used when `lineWidth` is reached.
 */
var WrappingMode;
(function (WrappingMode) {
    WrappingMode[WrappingMode["None"] = 0] = "None";
    WrappingMode[WrappingMode["Character"] = 1] = "Character";
    WrappingMode[WrappingMode["Word"] = 2] = "Word";
})(WrappingMode = exports.WrappingMode || (exports.WrappingMode = {}));
/**
 * @hidden
 * @internal
 * Utility function that gets deduced [[HorizontalAlignment]] from [[HorizontalPlacement]].
 * Horizontal alignments are exactly opposite to the placements.
 */
function hAlignFromPlacement(hP) {
    return hP;
}
exports.hAlignFromPlacement = hAlignFromPlacement;
/**
 * @hidden
 * @internal
 * Utility function that gets deduced [[VerticalAlignment]] from [[VerticalPlacement]].
 */
function vAlignFromPlacement(vP) {
    return vP;
}
exports.vAlignFromPlacement = vAlignFromPlacement;
/**
 * @hidden
 * @internal
 * Utility function that gets deduced [[HorizontalPlacement]] from [[HorizontalAlignment]].
 * Horizontal placements are exactly opposite to the alignment values.
 */
function hPlacementFromAlignment(hA) {
    return hA;
}
exports.hPlacementFromAlignment = hPlacementFromAlignment;
/**
 * @hidden
 * @internal
 * Utility function that gets deduced [[VerticalPlacement]] from [[VerticalAlignment]].
 */
function vPlacementFromAlignment(vA) {
    return vA;
}
exports.vPlacementFromAlignment = vPlacementFromAlignment;
/**
 * Namespace containing default values for all members of [[TextRenderParameters]] and
 * [[TextLayoutParameters]].
 */
var DefaultTextStyle;
(function (DefaultTextStyle) {
    DefaultTextStyle.DEFAULT_FONT_NAME = "";
    DefaultTextStyle.DEFAULT_FONT_SIZE = {
        unit: Object.freeze(FontUnit.Pixel),
        size: Object.freeze(16.0),
        backgroundSize: Object.freeze(0.0)
    };
    DefaultTextStyle.DEFAULT_FONT_STYLE = FontStyle.Regular;
    DefaultTextStyle.DEFAULT_FONT_VARIANT = FontVariant.Regular;
    DefaultTextStyle.DEFAULT_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_COLOR = new THREE.Color(0x000000);
    DefaultTextStyle.DEFAULT_OPACITY = 1.0;
    DefaultTextStyle.DEFAULT_BACKGROUND_COLOR = new THREE.Color(0x000000);
    DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY = 0.0;
    DefaultTextStyle.DEFAULT_TRACKING = 0.0;
    DefaultTextStyle.DEFAULT_LEADING = 0.0;
    DefaultTextStyle.DEFAULT_MAX_LINES = Infinity;
    DefaultTextStyle.DEFAULT_LINE_WIDTH = Infinity;
    DefaultTextStyle.DEFAULT_CANVAS_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_LINE_ROTATION = 0.0;
    DefaultTextStyle.DEFAULT_WRAPPING_MODE = WrappingMode.Word;
    DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT = VerticalAlignment.Above;
    DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT = HorizontalAlignment.Left;
    DefaultTextStyle.DEFAULT_PLACEMENTS = [];
})(DefaultTextStyle = exports.DefaultTextStyle || (exports.DefaultTextStyle = {}));
/**
 * [[TextCanvas]] text rendering style.
 */
class TextRenderStyle {
    /**
     * Creates a new `TextRenderStyle`.
     *
     * @param params - Input [[TextRenderParameters]].
     *
     * @returns New `TextRenderStyle`.
     */
    constructor(params = {}) {
        this.m_params = {
            fontName: params.fontName !== undefined
                ? params.fontName
                : DefaultTextStyle.DEFAULT_FONT_NAME,
            fontSize: params.fontSize !== undefined
                ? Object.assign({}, params.fontSize) : {
                unit: DefaultTextStyle.DEFAULT_FONT_SIZE.unit,
                size: DefaultTextStyle.DEFAULT_FONT_SIZE.size,
                backgroundSize: DefaultTextStyle.DEFAULT_FONT_SIZE.backgroundSize
            },
            fontStyle: params.fontStyle !== undefined
                ? params.fontStyle
                : DefaultTextStyle.DEFAULT_FONT_STYLE,
            fontVariant: params.fontVariant !== undefined
                ? params.fontVariant
                : DefaultTextStyle.DEFAULT_FONT_VARIANT,
            rotation: params.rotation !== undefined ? params.rotation : DefaultTextStyle.DEFAULT_ROTATION,
            color: params.color !== undefined
                ? params.color.clone()
                : DefaultTextStyle.DEFAULT_COLOR.clone(),
            opacity: params.opacity !== undefined ? params.opacity : DefaultTextStyle.DEFAULT_OPACITY,
            backgroundColor: params.backgroundColor !== undefined
                ? params.backgroundColor.clone()
                : DefaultTextStyle.DEFAULT_BACKGROUND_COLOR.clone(),
            backgroundOpacity: params.backgroundOpacity !== undefined
                ? params.backgroundOpacity
                : DefaultTextStyle.DEFAULT_BACKGROUND_OPACITY
        };
    }
    /**
     * Current [[TextRenderParameters]] for this style.
     */
    get params() {
        return this.m_params;
    }
    set params(value) {
        this.m_params = Object.assign(Object.assign({}, this.m_params), value);
    }
    /**
     * Name of the preferred [[Font]] to be used when rendering.
     */
    get fontName() {
        return this.m_params.fontName;
    }
    set fontName(value) {
        this.m_params.fontName = value;
    }
    /**
     * Collection of unit and sizes to apply for the currently active [[Font]].
     */
    get fontSize() {
        return this.m_params.fontSize;
    }
    set fontSize(value) {
        this.m_params.fontSize = Object.assign({}, value);
    }
    /**
     * Glyph style to apply for the currently active [[Font]].
     */
    get fontStyle() {
        return this.m_params.fontStyle;
    }
    set fontStyle(value) {
        this.m_params.fontStyle = value;
    }
    /**
     * Glyph variant to apply for the currently active [[Font]].
     */
    get fontVariant() {
        return this.m_params.fontVariant;
    }
    set fontVariant(value) {
        this.m_params.fontVariant = value;
    }
    /**
     * Glyph local rotation (radians).
     */
    get rotation() {
        return this.m_params.rotation;
    }
    set rotation(value) {
        this.m_params.rotation = value;
    }
    /**
     * Glyph color.
     */
    get color() {
        return this.m_params.color;
    }
    set color(value) {
        this.m_params.color.copy(value);
    }
    /**
     * Glyph background color.
     */
    get backgroundColor() {
        return this.m_params.backgroundColor;
    }
    set backgroundColor(value) {
        this.m_params.backgroundColor.copy(value);
    }
    /**
     * Glyph opacity.
     */
    get opacity() {
        return this.m_params.opacity;
    }
    set opacity(value) {
        this.m_params.opacity = value;
    }
    /**
     * Glyph background opacity.
     */
    get backgroundOpacity() {
        return this.m_params.backgroundOpacity;
    }
    set backgroundOpacity(value) {
        this.m_params.backgroundOpacity = value;
    }
    /**
     * Clone this [[TextRenderStyle]].
     *
     * @param params - Input [[TextRenderParameters]].
     *
     * @returns Cloned [[TextRenderStyle]].
     */
    clone(params = {}) {
        return new TextRenderStyle(Object.assign(Object.assign({}, this.m_params), params));
    }
    /**
     * Copy other [[TextRenderStyle]] properties into this object instance.
     *
     * @param source - The source object to be copied.
     *
     * @returns reference to `this` object.
     */
    copy(source) {
        // Given that all source and this params are always defined:
        this.m_params.fontName = source.fontName;
        this.m_params.fontSize = Object.assign({}, source.fontSize);
        this.m_params.fontStyle = source.fontStyle;
        this.m_params.fontVariant = source.fontVariant;
        this.m_params.rotation = source.rotation;
        this.m_params.color.copy(source.color);
        this.m_params.backgroundColor.copy(source.backgroundColor);
        this.m_params.opacity = source.opacity;
        this.m_params.backgroundOpacity = source.backgroundOpacity;
        return this;
    }
}
exports.TextRenderStyle = TextRenderStyle;
/**
 * [[TextCanvas]] text rendering style.
 */
class TextLayoutStyle {
    /**
     * Creates a new `TextLayoutStyle`.
     *
     * @param params - Input [[TextLayoutParameters]].
     *
     * @returns New `TextLayoutStyle`.
     */
    constructor(params = {}) {
        // Solve alignment and placement dependencies and fallbacks.
        const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(params.horizontalAlignment, params.verticalAlignment, params.placements);
        this.m_params = {
            tracking: params.tracking !== undefined ? params.tracking : DefaultTextStyle.DEFAULT_TRACKING,
            leading: params.leading !== undefined ? params.leading : DefaultTextStyle.DEFAULT_LEADING,
            maxLines: params.maxLines !== undefined
                ? params.maxLines
                : DefaultTextStyle.DEFAULT_MAX_LINES,
            lineWidth: params.lineWidth !== undefined
                ? params.lineWidth
                : DefaultTextStyle.DEFAULT_LINE_WIDTH,
            canvasRotation: params.canvasRotation !== undefined
                ? params.canvasRotation
                : DefaultTextStyle.DEFAULT_CANVAS_ROTATION,
            lineRotation: params.lineRotation !== undefined
                ? params.lineRotation
                : DefaultTextStyle.DEFAULT_LINE_ROTATION,
            wrappingMode: params.wrappingMode !== undefined
                ? params.wrappingMode
                : DefaultTextStyle.DEFAULT_WRAPPING_MODE,
            verticalAlignment,
            horizontalAlignment,
            placements
        };
    }
    /**
     * Current [[TextLayoutParameters]] for this style.
     */
    get params() {
        return this.m_params;
    }
    set params(value) {
        this.m_params = Object.assign(Object.assign({}, this.m_params), value);
    }
    /**
     * Inter-glyph spacing (pixels). Scaled by [[FontSize]].
     */
    get tracking() {
        return this.m_params.tracking;
    }
    set tracking(value) {
        this.m_params.tracking = value;
    }
    /**
     * Inter-line spacing (pixels). Scaled by [[FontSize]].
     */
    get leading() {
        return this.m_params.leading;
    }
    set leading(value) {
        this.m_params.leading = value;
    }
    /**
     * Maximum number of lines to be considered when using [[TextCanvas]].
     */
    get maxLines() {
        return this.m_params.maxLines;
    }
    set maxLines(value) {
        this.m_params.maxLines = value;
    }
    /**
     * Maximum line width (pixels).
     */
    get lineWidth() {
        return this.m_params.lineWidth;
    }
    set lineWidth(value) {
        this.m_params.lineWidth = value;
    }
    /**
     * [[TextCanvas]] rotation (radians).
     */
    get canvasRotation() {
        return this.m_params.canvasRotation;
    }
    set canvasRotation(value) {
        this.m_params.canvasRotation = value;
    }
    /**
     * Line typesetting rotation (radians).
     */
    get lineRotation() {
        return this.m_params.lineRotation;
    }
    set lineRotation(value) {
        this.m_params.lineRotation = value;
    }
    /**
     * Wrapping (line-breaking) mode.
     */
    get wrappingMode() {
        return this.m_params.wrappingMode;
    }
    set wrappingMode(value) {
        this.m_params.wrappingMode = value;
    }
    /**
     * Text position regarding the baseline.
     */
    get verticalAlignment() {
        return this.m_params.verticalAlignment;
    }
    set verticalAlignment(value) {
        this.m_params.verticalAlignment = value;
    }
    /**
     * Text position inside a line.
     */
    get horizontalAlignment() {
        return this.m_params.horizontalAlignment;
    }
    set horizontalAlignment(value) {
        this.m_params.horizontalAlignment = value;
    }
    /**
     * Text placement options relative to label anchor (origin).
     *
     * @note [[TextPlacement]]s options may override alignment settings.
     */
    get placements() {
        return this.m_params.placements;
    }
    set placements(value) {
        const { horizontalAlignment, verticalAlignment, placements } = resolvePlacementAndAlignment(this.horizontalAlignment, this.verticalAlignment, value);
        this.m_params.horizontalAlignment = horizontalAlignment;
        this.m_params.verticalAlignment = verticalAlignment;
        this.m_params.placements = placements;
    }
    /**
     * Clone this [[TextLayoutStyle]].
     *
     * @param params - Input [[TextLayoutParameters]].
     *
     * @returns Cloned [[TextLayoutStyle]].
     */
    clone(params = {}) {
        return new TextLayoutStyle(Object.assign(Object.assign({}, this.m_params), params));
    }
    /**
     * Copy other [[TextLayoutStyle]] properties into this object instance.
     *
     * @param other - The object to be copied.
     *
     * @returns reference to `this` object.
     */
    copy(other) {
        this.params = Object.assign({}, other.params);
        return this;
    }
}
exports.TextLayoutStyle = TextLayoutStyle;
/**
 * Deduce alignment and placement attributes depending on the availability.
 *
 * If placement is defined it may override alignment settings, if no attributes are
 * provided they may be retrieved from defaults.
 *
 * @param hAlignment - The optional horizontal alignment.
 * @param vAlignment - The vertical alignment - optional.
 * @param placementsOpt - Possible text placements - optional.
 * @internal
 */
function resolvePlacementAndAlignment(hAlignment, vAlignment, placementsOpt) {
    var _a;
    // Make a deep copy or create new array from defaults.
    const placements = (_a = placementsOpt === null || placementsOpt === void 0 ? void 0 : placementsOpt.map(v => (Object.assign({}, v)))) !== null && _a !== void 0 ? _a : DefaultTextStyle.DEFAULT_PLACEMENTS.map(v => (Object.assign({}, v)));
    // Ignore alignment attributes when placements attributes are defined or provide default
    // values if none of them are provided.
    // NOTE: Alignment override may be removed if we decide to support both attributes.
    const horizontalAlignment = placements.length > 0
        ? hAlignFromPlacement(placements[0].h)
        : hAlignment !== null && hAlignment !== void 0 ? hAlignment : DefaultTextStyle.DEFAULT_HORIZONTAL_ALIGNMENT;
    const verticalAlignment = placements.length > 0
        ? vAlignFromPlacement(placements[0].v)
        : vAlignment !== null && vAlignment !== void 0 ? vAlignment : DefaultTextStyle.DEFAULT_VERTICAL_ALIGNMENT;
    return { horizontalAlignment, verticalAlignment, placements };
}
exports.resolvePlacementAndAlignment = resolvePlacementAndAlignment;
//# sourceMappingURL=TextStyle.js.map