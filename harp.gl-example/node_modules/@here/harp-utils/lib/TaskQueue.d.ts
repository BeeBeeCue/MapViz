/**
 * Task that can be added to the [[TaskQueue]]
 */
export interface Task {
    /**
     * The Function that will be executed when the [[Task]] is processed
     */
    execute: () => void;
    /**
     * The group by which similar tasks in the TaskQueue are combined
     */
    group: string;
    /**
     * A function to retrieve the priority of the [[Task]], with 0 being
     * the highest priority, and the first to be executed
     */
    getPriority: () => number;
    /**
     * An optional function that defines if a [[Task]] is alread expired
     * and therefore can be removed from the [[TaskQueue]]
     */
    isExpired?: () => boolean;
    /**
     * An optional function that returns an estimated process time,
     * this is not directly used by the [[TaskQueue]] but can be used
     * by an Task Scheduler to schedule the processing
     */
    estimatedProcessTime?: () => number;
}
export interface TaskQueueOptions {
    /**
     * Groups to combine specific [[Task]]s in the [[TaskQueue]],
     * [[Task]]s can only be added to the [[TaskQueue]] if their group is available
     */
    groups: string[];
    /**
     * Optional function to sort the priority, if set, i will override the internal TaskQueue.sort
     * function.
     *
     * @remarks
     * Caution, the {@link TaskQueue} uses the last element in the Arrays first, so the
     * highest priorities should be ordered to the end
     */
    prioSortFn?: (a: Task, b: Task) => number;
}
/**
 * A Pull-TaskQueue sorted by priority and group-able {@link Task}s by {@link Task.group}.
 *
 * @remarks
 *
 * @example
 * Sample Usage
 * ```
 *  const taskQueue = new TaskQueue({
 *      group: ["group1"]
 *  })
 *  taskQueue.add({
 *     group: "group1",
 *     execute: () => {
 *         console.log("task of group1 executed");
 *     },
 *     getPrio: () => {
 *         return 0;
 *     }
 *   });
 *
 * taskQueue.update();
 * taskQueue.processNext("group1");
 *
 *  ```
 */
export declare class TaskQueue {
    private readonly m_options;
    private readonly m_taskLists;
    constructor(m_options: TaskQueueOptions);
    /**
     * Updates the lists in the queue depending on their priority functions and removes
     * expired Tasks, based on their isExpired functions result.
     *
     * @param group The Group to update, if not set all groups will be updated.
     */
    update(group?: string): void;
    /**
     * Adds a Task to the Queue
     *
     * @param task
     * @returns true if succesfully added, otherwise false
     */
    add(task: Task): boolean;
    /**
     * Removes a Task from the Queue
     *
     * @param task
     * @returns true if succesfully removed, otherwise false
     */
    remove(task: Task): boolean;
    /**
     * Returns the number of remaining tasks.
     *
     * @param group if group is set, it will return only the remaining tasks for this group,
     * otherwise it will return the complete amount of tasks left.
     */
    numItemsLeft(group?: string): number;
    /**
     * Processes the next Tasks for a group
     *
     * @param group The group the Tasks are pulled from.
     * @param shouldProcess A condition that, if set will be executed before the task is processed,
     * if returns true, the task will run
     * @param n The amount of tasks that should be pulled, @defaults to 1
     * @returns false if thte list was empty
     */
    processNext(group: string, shouldProcess?: (task: Task) => boolean, n?: number): boolean;
    private pull;
    private sort;
    private getTaskList;
    private updateTaskList;
}
//# sourceMappingURL=TaskQueue.d.ts.map